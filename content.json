[{"title":"数据结构和算法-队列","date":"2019-11-09T07:24:13.170Z","path":"2019/11/09/数据结构和算法-队列/","text":"&emsp;&emsp;队列是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作(先入先出原则)，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列的使用场景银行排队案例：&emsp;&emsp;在银行排队办理业务的时候，如果窗口有人正在办理业务，后面等待的人会按照先后顺序排成一个队列，这个队列的人，先到的先从等待队列中出去办理业务，而后到的人要从这个队列的末尾排队，等待先到的人从这个等待队列出去办理业务之后，后到的人才能从等待队列出去。 用数组模拟队列思路分析&emsp;&emsp;队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图所示，其中maxSize是该队列的最大容量。&emsp;&emsp;因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据输入而改变，如图所示：当我们将数据存入队列时称为“addQueue”，addQueue的处理需要有两个步骤：(1)将尾指针往后移：rear+1，当front==rear 时，为空队列。(2)若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear==maxSize-1 时，为队列满。 数组模拟队列的代码实现模拟一个队列实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//使用数组模拟队列（编写一个ArrayQueue类）class ArrayQueue&#123; private int maxSize;//表示数组的最大容量 private int front;//队列头 private int rear;//队列尾 private int[] arr;//该数组用于存放队列，模拟的队列 //创建队列构造器 public ArrayQueue(int arrMaxSize)&#123; maxSize = arrMaxSize; arr = new int[maxSize]; front = -1;//指向队列头部，分析出front是指向队列头的前一个位置 rear = -1;//指向队列尾部，指向队列尾的数据(就是队列最后一个数据) &#125; //判断队列是否满 public boolean isFull()&#123; return rear == maxSize - 1; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return rear == front; &#125; //添加数据到队列 public void addQueue(int n)&#123; //判断队列是否满 if(isFull())&#123; throw new RuntimeException(\"队列满，不能加入数据！\"); &#125; rear++;//让rear后移 arr[rear] = n; &#125; //数据出队列 public int getQueue()&#123; //判断队列是否空 if(isEmpty())&#123; //通过抛出异常处理 throw new RuntimeException(\"队列空，不能取数据\"); &#125; front++; return arr[front]; &#125; //显示队列的所有数据 public void showQueue()&#123; //遍历 if(isEmpty())&#123; System.out.println(\"队列为空，没有数据！\"); return; &#125; for(int i = 0; i&lt;arr.length;i++)&#123; System.out.printf(\"arr[%d]=%d\\n\",i,arr[i]); &#125; &#125; //显示队列的头数据，注意部署去除数据 public int headQueue()&#123; //判断队列是否为空 if(isEmpty())&#123; throw new RuntimeException(\"队列空，没有头！\"); &#125; return arr[front+1]; &#125;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ArrayQueueDemo &#123; public static void main(String[] args) &#123; //创建一个队列 ArrayQueue arrayQueue = new ArrayQueue(3); char key = ' ';//接收用户的输入 Scanner scanner = new Scanner(System.in); boolean loop = true; //输出一个菜单 while(loop)&#123; System.out.print(\"s(show):显示队列;\"); System.out.print(\"e(exit):退出程序;\"); System.out.print(\"a(add):添加队列;\"); System.out.print(\"g(get):从队列取出数据;\"); System.out.println(\"h(head):查看队列头的数据。\"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': arrayQueue.showQueue(); break; case 'e': scanner.close(); loop = false; break; case 'a': try &#123; System.out.println(\"请输入一个数字：\"); int value = scanner.nextInt(); arrayQueue.addQueue(value); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'g': try &#123; int res = arrayQueue.getQueue(); System.out.printf(\"取出的数据是%d\\n\",res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h': try &#123; int head = arrayQueue.headQueue(); System.out.printf(\"队列头为%d\\n\",head); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; default: break; &#125; &#125; System.out.println(\"程序退出\"); &#125;&#125; 结果：目前代码存在的一些问题(1)目前数字使用一次就不能使用，没有达到复用的效果(2)将这个数字使用算法，改成一个环形的数组 数组模拟环形队列 思路：1、front变量的含义做一个调整：front指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，front的初始值 = 02、rear变量的含义也做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为一个约定。rear的初始值 = 03、当队列满时，条件是：( rear + 1 ) % maxSize = front4、当队列为空，条件是：rear == front5、当这样之后，队列中有效的数据的个数为( rear + maxSize - front ) % maxSize 代码实现模拟一个环形队列实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//使用数组模拟环形队列（编写一个CircleQueue类）class CircleArray&#123; private int maxSize;//表示数组的最大容量 private int front;//front变量的含义做一个调整：front指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，front的初始值 = 0 private int rear;//rear变量的含义也做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为一个约定。rear的初始值 = 0 private int[] arr;//该数组用于存放队列，模拟的队列 //创建队列构造器 public CircleArray(int arrMaxSize)&#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; //判断队列是否满 public boolean isFull()&#123; return (rear+1)%maxSize==front; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return rear == front; &#125; //添加数据到环形队列 public void addQueue(int n)&#123; //判断队列是否满 if(isFull())&#123; throw new RuntimeException(\"队列满，不能加入数据！\"); &#125; arr[rear] = n; rear = (rear+1)%maxSize;//将rear后移，这里必须考虑取模 &#125; //数据出队列 public int getQueue()&#123; //判断队列是否空 if(isEmpty())&#123; //通过抛出异常处理 throw new RuntimeException(\"队列空，不能取数据\"); &#125; //front是指向队列的第一个元素 //1、先把front对应的值保存到一个临时的变量 //2、将front后移 //3、将临时保存的变量返回 int value = arr[front]; front = (front+1)%maxSize; return value; &#125; //显示队列的所有数据 public void showQueue()&#123; //遍历 if(isEmpty())&#123; System.out.println(\"队列为空，没有数据！\"); return; &#125; //从fron开始遍历，遍历多少个元素 for(int i = front; i&lt;front+size();i++)&#123; System.out.printf(\"arr[%d]=%d\\n\",i%maxSize,arr[i%maxSize]); &#125; &#125; //求出当前队列的有效数据 public int size()&#123; return (rear+maxSize-front)%maxSize; &#125; //显示队列的头数据，注意不是去除数据 public int headQueue()&#123; //判断队列是否为空 if(isEmpty())&#123; throw new RuntimeException(\"队列空，没有头！\"); &#125; return arr[front]; &#125;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void main(String[] args) &#123; //测试 System.out.println(\"测试环形队列\"); //创建一个队列 CircleArray circleQueue = new CircleArray(4);//起队列的有效数据最大为3 char key = ' ';//接收用户的输入 Scanner scanner = new Scanner(System.in); boolean loop = true; //输出一个菜单 while(loop)&#123; System.out.print(\"s(show):显示队列;\"); System.out.print(\"e(exit):退出程序;\"); System.out.print(\"a(add):添加队列;\"); System.out.print(\"g(get):从队列取出数据;\"); System.out.println(\"h(head):查看队列头的数据。\"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': circleQueue.showQueue(); break; case 'e': scanner.close(); loop = false; break; case 'a': try &#123; System.out.println(\"请输入一个数字：\"); int value = scanner.nextInt(); circleQueue.addQueue(value); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'g': try &#123; int res = circleQueue.getQueue(); System.out.printf(\"取出的数据是%d\\n\",res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h': try &#123; int head = circleQueue.headQueue(); System.out.printf(\"队列头为%d\\n\",head); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; default: break; &#125; &#125; System.out.println(\"程序退出\");&#125; 结果：","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-稀疏数组","date":"2019-11-05T13:54:41.952Z","path":"2019/11/05/数据结构和算法-稀疏数组/","text":"实际需求 编写的五子棋程序中，有存盘退出和继续上盘的功能使用二维数组记录棋盘(用1记录玩家1，用2记录玩家2)0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;1&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;2&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0 分析存在的问题&emsp;&emsp;因为二维数组的很多值都是默认的值0，因此记录了很多没有意义的数据，这个时候就可以使用稀疏数组解决这个问题。稀疏数组 基本介绍当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存改数组。稀疏数组的处理方法是：（1）记录数组一共有几行几列，有多少个不同的值（2）把具有不同值的元素行列及值记录在一个小规模得数组中，从而缩小程序得规模 举例说明实际二维数组转换为稀疏二维数组&emsp;&emsp;从上面两个数组可以看出，原始的二维数组一共记录了42个数据，而转换为稀疏二维数组之后只需要记录27个数据。 应用实例（1）使用稀疏数组，来保存类似前面的二维数组（棋盘、地图等等）（2）把稀疏数组存盘，并且可以从新恢复原来的二维数组（3）思路分析将原始二维数组转换为稀疏数组的思路①遍历原始的二维数组，得到有效数据的个数sum②根据sum就可以创建稀疏二维数组sparseArr int[sum+1][3]③将原始二维数组的有效数据存入到稀疏数组将稀疏数组转换为原始二维数组的思路①先读取稀疏数组的第一行，根据第一行的数据创建原始的二维数组②在读取稀疏数组后几行的数据，并赋值给原始二维数组即可 稀疏数组的代码实现 此部分是将上面的思路分析转换成代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class SparseArray &#123; public static void main(String[] args) &#123; /** * 将原始二维数组转换为稀疏数组 */ //创建一个原始的二维数组10 * 10 //0：表示每一棋子，1表示黑棋，2表示白棋 int chessArr1[][] = new int[10][10]; chessArr1[3][3]=1; chessArr1[4][4]=2; //输出原始的二维数组 System.out.println(\"原始二维数组：\"); for(int[] row: chessArr1)&#123; for(int data : row)&#123; System.out.printf(\"%d\\t\",data); &#125; System.out.println(); &#125; //将二维数组转换为稀疏数组 //1.先遍历二维数组，得到非0数据的个数 int sum=0; for(int i = 0; i&lt;10;i++)&#123; for(int j = 0; j&lt;10;j++)&#123; if(chessArr1[i][j]!=0)&#123; sum++; &#125; &#125; &#125; //2.创建对应的稀疏数组 int sparseArr[][] = new int[sum+1][3]; //给稀疏数组赋值 sparseArr[0][0] = 10; sparseArr[0][1] = 10; sparseArr[0][2] = 2; //遍历原始二维数组，将非0的值存放到sparseArr中 int count = 0;//count用于记录是第几个非0数据 for(int i = 0; i&lt;10;i++)&#123; for(int j = 0; j&lt;10;j++)&#123; if(chessArr1[i][j]!=0)&#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; //输出稀疏数组的形式 System.out.println(); System.out.println(\"得到的稀疏数组为：\"); for(int i = 0;i&lt;sparseArr.length;i++)&#123; System.out.printf(\"%d\\t%d\\t%d\\t\",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]); System.out.println(); &#125; /** * 将稀疏数组转换为原始二维数组 */ //1.读取稀疏数组第一行，根据第一行数据创建原始二维数组 int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]]; //2.根据稀疏数组第二行以及之后行的数据赋值给原始二维数组 for(int i = 1;i&lt;sparseArr.length;i++)&#123; chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; //输出还原的二维数组 System.out.println(\"恢复之后的二维数组：\"); for(int[] row: chessArr2)&#123; for(int data : row)&#123; System.out.printf(\"%d\\t\",data); &#125; System.out.println(); &#125; &#125;&#125; 运行结果：","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"Maven的核心概念","date":"2019-10-27T13:06:14.588Z","path":"2019/10/27/Maven的核心概念/","text":"Maven的目录结构，POM，坐标，仓库，依赖，生命周期，继承，聚合分别是什么呢？ Maven的目录结构这一部分的内容在我的上一篇《快速上手Maven》已经讲过，在这就不在过多赘述。HelloMaven：根目录（工程名）src：源码pom.xml：Maven工程的核心配置文件main：存放主程序test：存放测试程序java：存放java源文件resources：存放框架或者其它工具的配置文件 POM[1]含义：Project Object Model 项目对象模型，类似与DOM Document Object Model 文档对象模型[2]pom.xml对于Maven工程是核心的配置文件，与构建过程相关的一切设置都在这个文件中进行配置。重要程度相当于web.xml对于动态Web工程。 坐标 在Maven中坐标是使用三个向量在仓库中唯一定位一个Maven工程[1]groupId：公司或者组织的唯一标志，一般用公司或组织域名倒序+项目名 1&lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt; [2]artifactId：模块名，项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 1&lt;artifactId&gt;HelloMaven&lt;/artifactId&gt; [3]version：版本号 1&lt;version&gt;1.0&lt;/version&gt; Maven坐标与仓库中路径的对应关系如com.xiezhenyu.maven，maven会将该项目打成的jar包放本地仓库路径：/com/xiezhenyu/maven-1.0.jar。我们自己的 Maven 工程必须执行安装操作才会进入仓库，安装的命令是：mvn install。 仓库 仓库的分类[1]本地仓库：为当前本机电脑上所有的Maven工程服务[2]远程仓库：远程仓库分为私服、中央仓库、中央镜像仓库。私服：架设在当前局域网环境下，为当前局域网范围内的所有Maven工程服务；中央仓库：架设在Internet上，为全世界所有的Maven工程服务；中央仓库镜像：架设在各个大洲上，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。其中仓库的关系可以参照下图： 仓库中的文件(仓库中保存的内容)[1]Maven自身所需要的插件[2]第三方框架或工具的jar包[3]我们自己开发的Maven工程 依赖 概念&emsp;&emsp;当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖，这是概念上的描述。Maven解析依赖信息时会到仓库中查找被依赖的jar包。 如果要使用我们自己开发的jar包，要使用mvn install命令安装后就可以进入仓库。 依赖的范围 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在上面test就是描述依赖的范围，其值可以有 其文字描述为： compile范围依赖※对主程序是否有效：有效※对测试程序是否有效：有效※是否参与打包：参与※是否参与部署：参与※典型例子：spring-core test范围依赖 ※对主程序是否有效：无效 ※对测试程序是否有效：有效 ※是否参与打包：不参与 ※是否参与部署：不参与 ※典型例子：Junit 从开发和运行这两个阶段理解compile 和 provided 的区别 compile围依赖 provided 范围依赖 依赖的传递性&emsp;&emsp;比如A.jar依赖B.jar，B.jar依赖C.jar，A.jar能否使用C.jar呢？这时就需要看B.jar依赖C.jar的范围是不是compile范围的依赖。这就说明，C.jar只是给B.jar单独使用的。 依赖的排除&emsp;&emsp;如果我们当前工程中引入了一个依赖是A.jar，而A.jar又依赖了B.jar，那么Maven会自动将A依赖的B引入当前工程，但是个别情况下B.jar有可能是一个不稳定版本，或对当前工程有不良影响。这时我们可以在引入A.jar的时候将B.jar排除。①情景②配置方式 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt; &lt;artifactId&gt;HelloMaven&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;!-- 配置需要排除的依赖信息 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ③排除后的结果 依赖的原则，解决jar包冲突①路径最短者优先会根据jar包的路径最短的原则依赖jar包②路径相同时先声明者优先，先生命指的是dependency标签声明的顺序。 统一管理所依赖的版本&emsp;&emsp;对同一个框架的一组jar包最好使用相同的版本。为了方便升级架构，可以将jar包的版本信息统一提取出来。①统一声明版本号(其中 jackson.version 部分是自定义标签。) 123&lt;properties&gt; &lt;jackson.version&gt;2.9.6&lt;/jackson.version&gt;&lt;/properties&gt; ②引用前面声明的版本号 (在这里就会统一引用声明好的版本号) 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;&lt;/dependency&gt; ③其实properties标签配合自定义标签声明数据的配置并不是只能用于声明依赖的版本号。凡是需要统一声明后再引用的场合都可以使用。 生命周期 各个构建环节执行的顺序：不能打乱顺序，必须按照既定的正确顺序来执行。 Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。 Maven核心程序为了更好的实现自动化构建，按照这一特点执行生命周期中各个阶段：不论现在要执行生命周期中的哪一阶段，都是从这个生命周期最初的位置开始执行。 Maven有三套相互独立的生命周期，分别是：①Clean Lifecycle 在进行真正的构建之前进行一些清理工作。②Default Lifecycle 构建的核心部分，编译、测试、打包、安装、部署等等。③Site Lifecycle 生成项目报告，站点，发布站点。&emsp;&emsp;他们相互独立。也可以直接运行 mvn clean install site 运行所有这三套生命周期。每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。 Clean声明周期①pre-clean 执行一些需要在clean之前完成的工作②clean 移除所有上一次构建生成的文件③post-clean 执行一些需要在clean 之后立刻完成的工作 Default声明周期Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里标红一些比较重要和常用的阶段：validate（校验） 校验项目是否正确并且所有必要的信息可以完成项目的构建过程。initialize（初始化） 初始化构建状态，比如设置属性值。generate-sources（生成源代码） 生成包含在编译阶段中的任何源代码。process-sources（处理源代码） 处理源代码，比如说，过滤任意值。generate-resources（生成资源文件） 生成将会包含在项目包中的资源文件。process-resources （处理资源文件） 复制和处理资源到目标目录，为打包阶段最好准备。compile（编译） 编译项目的源代码。process-classes（处理类文件） 处理编译生成的文件，比如说对Java class文件做字节码改善优化。generate-test-sources（生成测试源代码） 生成包含在编译阶段中的任何测试源代码。process-test-sources（处理测试源代码） 处理测试源代码，比如说，过滤任意值。generate-test-resources（生成测试资源文件） 为测试创建资源文件。process-test-resources（处理测试资源文件） 复制和处理测试资源到目标目录。test-compile（编译测试源码） 编译测试源代码到测试目标目录.process-test-classes（处理测试类文件） 处理测试源码编译生成的文件。test（测试） 使用合适的单元测试框架运行测试（Juint是其中之一）。prepare-package（准备打包） 在实际打包之前，执行任何的必要的操作为打包做准备。package（打包） 将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件。pre-integration-test（集成测试前） 在执行集成测试前进行必要的动作。比如说，搭建需要的环境。integration-test（集成测试） 处理和部署项目到可以运行集成测试环境中。post-integration-test（集成测试后） 在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境。verify （验证） 运行任意的检查来验证项目包有效且达到质量标准。install（安装） 安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。deploy（部署） 将最终的项目包复制到远程仓库中与其他开发者和项目共享。 Site生命周期①pre-site 执行一些需要在生成站点文档之前完成的工作②site 生成项目的站点文档③post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备④site-deploy 将生成的站点文档部署到特定的服务器上 插件和目标①生命周期的各个阶段仅仅定义了要执行的任务是生命②各个阶段和插件的目标是对应的③相似的目标由特定的插件来完成例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。 继承 现状Hello依赖的Junit：4.0HelloFriend依赖的Junit：4.0MakeFriends依赖的Junit：4.9由于test范围的依赖不能传递，所以必然会分散在各个模块工程中，很容易造成版本不一致。 需求：统一管理各个模块工程中对Junit依赖的版本。 解决思路：将Junit依赖统一提取到“父”工程中，在子工程中声明Junit依赖是不指定版本，以父工程中统一设定的为准。同时也便于修改。 操作步骤：①创建一个Maven工程作为父工程。注意：打包方式为pom 1234&lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt;&lt;artifactId&gt;Parent&lt;/artifactId&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt; ②在子工程中声明对父工程的引用 12345678&lt;!-- 在子过程中声明父工程 --&gt;&lt;parent&gt; &lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!-- 以当前工程的pom.xml文件为基准的父工程pom.xml文件的相对路径 --&gt; &lt;relativePath&gt;&lt;/relativePath&gt;&lt;/parent&gt; ③将子工程的坐标中与父工程坐标中重复的内容删除 ④在父工程中统一管理Junit的依赖 1234567891011&lt;!-- 配置依赖的管理 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; ⑤在子工程中删除Junit依赖的版本号部分 注意：配置集成后，执行安装命令时要先安装父工程。 聚合&emsp;&emsp;如果我们写了很多模块，在我们安装的时候就需要我们一个个安装，这样就整加了工作量，而聚合可以解决这个问题。 聚合作用：一键安装各个模块工程。 配置方式：在一个“总的聚合工程”中配置各个参与聚合的模块（比如说在父工程配置） 1234567&lt;!-- 配置聚合 --&gt;&lt;modules&gt; &lt;!-- 配置一起安装的各个工程 --&gt; &lt;module&gt;../Hello&lt;/module&gt; &lt;module&gt;../HelloFriend&lt;/module&gt; &lt;module&gt;../MakeFriends&lt;/module&gt;&lt;/modules&gt; 使用方式：在聚合工程的pom.xml 上点右键-&gt;run as-&gt;maven install","tags":[{"name":"Maven","slug":"Maven","permalink":"https://Xiezhenyu98.github.io/tags/Maven/"}]},{"title":"【快速上手】Maven的使用","date":"2019-10-27T05:02:36.618Z","path":"2019/10/27/[快速上手]Maven的使用/","text":"首先需要了解一下为什么要使用Maven 一个项目就是一个工程&emsp;&emsp;如果一个项目非常庞大，就不适合继续使用Package来划分模块。最好是每一个模块对应一个工程，利于分工协作。而利用Maven就可以将一个项目拆分为多个工程。 项目中需要jar包必须手动“复制”、“粘贴”到WEB-INF/lib目录下&emsp;&emsp;带来的问题：同样的jar包文件重复出现在不同的项目工程中，一方面浪费存储空间，另外也让工程比较臃肿。借助Maven，可以将jar包仅仅保存在“仓库”中，有需要使用的工程“引用”这个文件接口，并不需要真的把jar包复制过来。 jar包需要别人替我们准备好，或者到官网下载&emsp;&emsp;不同技术的官网提供的jar包下载方式是不同的，有些jar包我们进不去别人的官网，只能从第三方网站下载，而第三方的网站的jar包可能是不规范的。而借助于Maven我们可以以一种规范的方式下载jar包。因为所有知名的jar包都会以规范的方式下载jar包，内容可靠。 一个jar包依赖的其它jar包需要自己手动加入工程中&emsp;&emsp;有些jar包会依赖很多个jar包，而被依赖的jar包也可能依赖其它jar包，这些依赖关系我们必须记下来，这样就会使程序员整加学习成本。不然我们把不完整的jar包导入到工程中，将会出现报错。而使用Maven将会自动把依赖的jar包导入进来。我们来了解一下什么是Maven&emsp;&emsp;Maven是一款服务于java平台的自动化构建工具。构建就是以java源文件、框架配置文件、JSP、HTML、图片等资源为原材料，去生产一个可运行的项目的过程。这个过程主要分为编译、部署、搭建。构建的各个环节：[1]清理：将以前编译得到的旧的class字节码文件删除，为下一次编译做准备[2]编译：将Java源程序编译为字节码文件。[3]测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。[4]报告：将每一次测试后以标准的格式记录和展示测试结果。[5]打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java工程对应jar包，Web工程对象war包。[6]安装：在Maven环境下特指将打包的结果——Jar包或War包安装到本地仓库中。[7]部署：将打包的结果部署到远程仓库或将war包部署到服务器上运行。如何使用和创建一个Maven工程 安装jdk、配置java环境变量 下载并解压Maven核心程序压缩包 【点击下载http://maven.apache.org/download.cgi】 配置Maven环境变量MAVEN_HOME：解压Maven核心程序的路径\\apache-maven-3.6.1-binpath：%MAVEN_HOME%\\bin 验证Maven是否配置成功（在控制台输入mvn -v） 创建Maven工程&emsp;&emsp;在创建之前必须要知道Maven所约定的Maven目录结构，我们创建这个工程必须按照这个约定的结构去创建，因为我们写的代码最终是要交给Maven去处理的，比如说java源代码编译，只有按照这个Maven约定好的目录去创建，Maven才知道去哪找java源代码编译。Maven的目录结构：HelloMaven：根目录（工程名）src：源码pom.xml：Maven工程的核心配置文件main：存放主程序test：存放测试程序java：存放java源文件resources：存放框架或者其它工具的配置文件 编写Maven项目[1]编写pom.xml文件1234567891011121314151617181920212223&lt;?xml version=\"1.0\" ?&gt;&lt;project xmlns = \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;!-- 模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt; &lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt; &lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt; &lt;artifactId&gt;HelloMaven&lt;/artifactId&gt; &lt;!-- 版本号 --&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!-- 依赖的jar包 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; [2]编写主程序代码&emsp;&emsp;在src/main/java/com/xiezhenyu/maven（一般以公司域名倒写的方式命名）目录下新建文件HelloMaven.java，其内容如下 1234567package com.xiezhenyu.maven;public class HelloMaven&#123; public String sayHelloMaven(String name)&#123; System.out.println(\"HelloMaven!\"); return \"Hello \"+name+\"!\"; &#125;&#125; [3]编写测试代码&emsp;&emsp;在src/test/java/com/xiezhenyu/maven（一般以公司域名倒写的方式命名）目录下新建文件HelloMavenTest.java，其内容如下 1234567891011package com.xiezhenyu.maven;import org.junit.Test;import static junit.framework.Assert.*;public class HelloMavenTest&#123; @Test public void testHelloMaven()&#123; HelloMaven helloMaven = new HelloMaven(); String results = helloMaven.sayHelloMaven(\"xiezhenyu\"); assertEquals(\"Hello xiezhenyu!\",results); &#125;&#125; 以上一个简单的Maven项目就搭建起来了。 如何测试运行一个Maven项目在测试之前先要了解一下Maven的常用命令 注意：执行与构建过程有关的Maven命令的时候，必须进入pom.xml所在的目录 常用命令[1]mvn clean : 清理[2]mvn compile : 编译主程序[3]mvn test-compile : 编译测试程序[4]mvn test : 执行测试[5]mvn package : 打包[6]mvn install ： 安装[7]mvn site ：生成站点 在编译之前，我们如果是第一次使用maven我们本地仓库中没有项目所需的jar包，我们需要联网[1]Maven 的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须有特定的插件来完成。而插件本身不包含在Maven核心程序中。[2]当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。[3]本地仓库的默认位置：[系统登陆用户的家目录] \\ .m2\\repository[4]Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载。[5]如果此时无法连接外网，则构建失败。[6]修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找插件&emsp;①找到Maven解压目录\\conf\\settings.xml&emsp;②在setting.xml 文件中找到 localRepository 标签&emsp;③将 &lt; localRepository&gt;/path/to/local/repo&lt; /localRepository&gt;从注释中取出&emsp;④将标签体内容修改为自定义的Maven仓库目录 执行mvn compile命令（cmd必须进入pom.xml所在的目录）&emsp;&emsp;可以发现我们在目录中生成了target目录，里面有classes，里面生成的是主程序编译后的结果（其中生成的maven-status目录是maven的状态，保存一些创建和输出的信息等） 执行mvn test-compile命令可以发现target目录新加了test-class目录，里面，里面生成的是测试程序编译后的结果 执行mvn test命令可以发现target目录新加了surefire-reports目录，里面生成的是测试报告相关的文件，控制台输出如下可以发现，我们的测试运行已经成功了。 执行mvn package命令&emsp;&emsp;可以发现，在target目录新生成了一个目录和一个jar包，maven-archiver目录存放的是这个jar包的基本信息，jar包是主程序编译结果打成的一个jar包，将jar包解压，我们可以看一下jar包的内容&emsp;&emsp;我们可以发现打包出来的并没有测试程序的内容，只有主程序的内容，里面也并没有这个工程所依赖的jar包，这样我们的工程就不会显得臃肿，如果我们将我们开发的这个模块导入到其它工程中就会方便很多。我们再看一下执行mvn package命令控制台的输出可以发现我们在执行打包命令时它也执行了测试，这就涉及到Maven的生命周期了。（与本篇无关，详情查看下一篇Maven） 以上就是如何快速使用Maven的方法","tags":[{"name":"Maven","slug":"Maven","permalink":"https://Xiezhenyu98.github.io/tags/Maven/"}]},{"title":"学习Python的第一步-卸载Python","date":"2019-10-27T02:55:14.363Z","path":"2019/10/27/学习Python的第一步-卸载Python/","text":"&emsp;&emsp;相信很多人都已经听说过或者学过Python了，但是有的人没有坚持下去，过了几个月一年或者更久之后Python的版本发生了很大的变化，我们学习当然要学习最新的内容。而要学习最新的内容就必须把电脑里已经安装过的Python旧版本卸载掉（没有安装过的当我没说） 检查是否安装PythonWin+R→输入cmd→打开→在cmd输入python→回车如果出现这个界面就证明你已经安装了Python，如果没有安装，是windows10系统的话会自动弹出python获取界面或者会出现 12'python' 不是内部或外部命令，也不是可运行的程序或批处理文件。 卸载Python进入电脑的控制面版。找到Python 3.7.3(或者不是Python的其它不是最新的版本)和Python Launcher，并把这两个卸载掉。 Python卸载成功","tags":[{"name":"Python","slug":"Python","permalink":"https://Xiezhenyu98.github.io/tags/Python/"}]},{"title":"Spring的模块","date":"2019-10-20T09:48:48.999Z","path":"2019/10/20/Spring的模块/","text":"Spring下载：http://repo.spring.io/release/org/springframework/spring/ Test：Spring的单元测试模块spring-test-5.0.8.RELEASE.jar Core Container：核心容器（IOC）；黑色代表这部分的功能由哪些jar包组成，要使用这个部分的完整功能们这些jar都需要导入：spring-beans-5.0.8.RELEASE.jarspring-core-5.0.8.RELEASE.jarspring-context-5.0.8.RELEASE.jarspring-expression-5.0.8.RELEASE.jar AOP+Aspects：面向切面编程模块spring-aop-5.0.8.RELEASE.jarspring-aspects-5.0.8.RELEASE.jar Data Access/Integration：数据访问（Spring访问数据库的模块）spring-jdbc-5.0.8.RELEASE.jarspring-orm-5.0.8.RELEASE.jar（Object Relation Mapping 对象关系映射）spring-oxm-5.0.8.RELEASE.jar（x表示xml）spring-jms-5.0.8.RELEASE.jarspring-tx-5.0.8.RELEASE.jar Web：Spring开发web应用的模块spring-websocket-5.0.8.RELEASE.jarspring-web-5.0.8.RELEASE.jar（和原生的web相关的(servlet)）spring-webmvc-5.0.8.RELEASE.jar（开发web应用的组件集成） Instrumentation：该模块提供了为JVM添加代理的功能，该模块包含spring-instrument，spring-instrument-tomcat组件，使用较少，不必过分关注。 用哪个模块导哪个包","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Mybatis和Spring整合","date":"2019-10-20T06:20:57.133Z","path":"2019/10/20/Mybatis和Spring整合/","text":"1、Mybatis和Spring框架整合1.1、导入所需的包我所需要的包是 1.2、创建Mybatis主配置文件sqlMapConfig.xml1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 类型别名,推荐使用package包的形式 --&gt; &lt;typeAliases&gt; &lt;!-- 扫描该包主包及子包下的所有类都起别名,别名为类名,而且大小写不敏感,推荐使用小写 --&gt; &lt;package name=\"com.xiezhenyu.bean\"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 1.3、创建Spring主配置文件applicationContext.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd \"&gt; &lt;!-- 读取db.properties --&gt; &lt;context:property-placeholder location=\"db.properties\"/&gt; &lt;!-- 配置c3p0连接池 --&gt; &lt;bean name=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.jdbcUrl&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.user&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 配置MyBatis sqlSessionFactory --&gt; &lt;bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 配置数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!-- 告诉spring mybatis的核心配置文件 --&gt; &lt;property name=\"configLocation\" value=\"classpath:sqlMapConfig.xml\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.4、创建log4j.properties和db.properties123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 1234jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql://localhost:3306/ssm_mybatis?serverTimezone=Asia/Shanghaijdbc.user=rootjdbc.password=p123456 1.5、测试12345public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); SqlSessionFactoryBean bean = ac.getBean(SqlSessionFactoryBean.class); System.out.println(bean);&#125; 1.6、结果1org.mybatis.spring.SqlSessionFactoryBean@708f5957 输出以上结果代表已经成功！ 2、Dao式开发在传统dao层上使用MyBatis和spring整合开发 2.1、创建实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.xiezhenyu.bean;import java.util.Date;public class User &#123; private Integer u_id; private String u_username; private String u_password; private String u_sex; private Date u_createTime; private Integer u_cid; public Integer getU_id() &#123; return u_id; &#125; public void setU_id(Integer u_id) &#123; this.u_id = u_id; &#125; public String getU_username() &#123; return u_username; &#125; public void setU_username(String u_username) &#123; this.u_username = u_username; &#125; public String getU_password() &#123; return u_password; &#125; public void setU_password(String u_password) &#123; this.u_password = u_password; &#125; public String getU_sex() &#123; return u_sex; &#125; public void setU_sex(String u_sex) &#123; this.u_sex = u_sex; &#125; public Date getU_createTime() &#123; return u_createTime; &#125; public void setU_createTime(Date u_createTime) &#123; this.u_createTime = u_createTime; &#125; public Integer getU_cid() &#123; return u_cid; &#125; public void setU_cid(Integer u_cid) &#123; this.u_cid = u_cid; &#125; @Override public String toString() &#123; return \"User [u_id=\" + u_id + \", u_username=\" + u_username + \", u_password=\" + u_password + \", u_sex=\" + u_sex + \", u_createTime=\" + u_createTime + \", u_cid=\" + u_cid + \"]\"; &#125;&#125; 2.2、书写Dao和DaoImpldao 123456package com.xiezhenyu.dao;import com.xiezhenyu.bean.User;public interface UserDao &#123; //根据id查询用户 public User getUserById(Integer id);&#125; &emsp;&emsp;daoImpl继承SqlSessionDaoSupport，可以通过父类的getSqlSession()方法直接获得session，而父类中的sqlSessionFactory可以通过spring注入。 123456789101112package com.xiezhenyu.dao;import org.apache.ibatis.session.SqlSession;import org.mybatis.spring.support.SqlSessionDaoSupport;import com.xiezhenyu.bean.User;public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123; @Override public User getUserById(Integer id) &#123; //通过父类的方法直接获得session SqlSession session = getSqlSession(); return session.selectOne(\"UserMapper.selectUserById\",id); &#125;&#125; 2.3、配置spring配置文件applicationContext.xml将工厂注入dao的父类 sqlSessionFactory属性中 1234&lt;!-- 将工厂注入dao的父类 sqlSessionFactory属性中 --&gt;&lt;bean id=\"userDaoImpl\" class=\"com.xiezhenyu.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactoryBean\"/&gt;&lt;/bean&gt; 2.4、配置mybatis配置文件123&lt;mappers&gt; &lt;mapper resource=\"com/xiezhenyu/mapper/UserMapper.xml\"/&gt;&lt;/mappers&gt; 2.5、测试1234567@Testpublic void DaoTest() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDaoImpl userDao = ac.getBean(UserDaoImpl.class); User user = userDao.getUserById(1); System.out.println(user);&#125; 2.6、结果1User [u_id=1, u_username=老王, u_password=123, u_sex=1, u_createTime=null, u_cid=1] 3、Mapper动态代理开发3.1、创建实体类该过程和上面dao层开发的实体类一致，就不给出代码。 3.2、创建UserMapper接口，修改UserMapper.xml将UserMapper.xml的namespace修改为UserMapper接口的路径 123public interface UserMapper &#123; public User selectUserById(Integer id);&#125; 123456&lt;mapper namespace=\"com.xiezhenyu.mapper.UserMapper\"&gt; &lt;!-- 查找用户 --&gt; &lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"user\"&gt; select * from user where u_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 3.3、让sqlMapConfig.xml以包的形式扫描mapper.xml123&lt;mappers&gt; &lt;package name=\"com.xiezhenyu.mapper\"/&gt;&lt;/mappers&gt; 3.4、配置spring配置文件applicationContext.xml&emsp;&emsp;将MapperFactoryBean交给Spring管理。MapperFactoryBean中拥有属性mapperInterface可以配置mapper的接口，而MapperFactoryBean是继承SqlSessionDaoSupport，使用可以注入sqlSessionFactory。 1234567&lt;!-- Mapper动态代理开发 --&gt;&lt;bean id=\"UserMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactoryBean\"/&gt; &lt;!-- 配置接口 --&gt; &lt;property name=\"mapperInterface\" value=\"com.xiezhenyu.mapper.UserMapper\"/&gt;&lt;/bean&gt; 3.5、编写测试方法获取mapper的方法可以用传递applicationContext.xml中id的方法，也可以直接传递接口。 123456789@Testpublic void Test1() &#123; //获取主配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //UserMapper mapper = (UserMapper)ac.getBean(\"UserMapper\"); UserMapper mapper = ac.getBean(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user);&#125; 3.6、结果1User [u_id=1, u_username=老王, u_password=123, u_sex=1, u_createTime=null, u_cid=1] 4、Mapper动态扫描开发(推荐使用)&emsp;&emsp;在mapper动态扫描开发中只需要配置以下即可，他会自动扫描某个包下的全部mapper，它不用手动注入sqlSessionFactory。 1234&lt;!-- mapper动态扫描开发 --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.xiezhenyu.mapper\"/&gt;&lt;/bean&gt;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"MyBatis动态sql：更方便的拼接sql语句","date":"2019-10-19T08:06:18.167Z","path":"2019/10/19/MyBatis动态sql：更方便的拼接sql语句/","text":"if标签&emsp;&emsp;if标签是最常用的判断语句，相当于java中的if语句。在MyBatis中使用if标签，我们先看一下不使用if标签的时候会有什么情况。 12345678910&lt;!-- 多条件查询 用过用户对象中的条件查询用户列表 --&gt;&lt;select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\"&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍id --&gt; select * from user where u_sex = #&#123;u_sex&#125; and u_username like \"%\"#&#123;u_username&#125;\"%\" and u_cid = #&#123;u_cid&#125;&lt;/select&gt; &emsp;&emsp;在上面的案例中，多条件查询用户性别u_sex，模糊查询用户名u_username，查询用户国籍c_id，返回一个集合。我们在使用条sql语句的时候，我们必须把所有的参数传过来，如果出现我只有查询用户性别u_sex，模糊查询用户名u_username的情况，我们又必须再写一条sql语句。而使用了if标签之后可以解决这个问题。 12345678910111213141516&lt;!-- 多条件查询 用过用户对象中的条件查询用户列表 --&gt;&lt;select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\"&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍id --&gt; select * from user where &lt;if test=\"u_sex!=null\"&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt;';l., &lt;if test=\"u_username!=null\"&gt; and u_username like \"%\"#&#123;u_username&#125;\"%\" &lt;/if&gt; &lt;if test=\"u_cid!=null\"&gt; and u_cid = #&#123;u_cid&#125; &lt;/if&gt;&lt;/select&gt; &emsp;&emsp;在上面的案例中，当参数u_username传递进映射器时，如果参数不为空则再sql语句上拼接上对用户名的模糊查询，如果为空，则不拼接。这样我们就可以不用写多条sql语句了。但是，如果我们u_sex为空u_username不为空，在sql语句拼接时就会出现select * from user where and u_username like &quot;%&quot;#{u_username}&quot;%&quot;的错误语法格式。接下来的where标签可以解决这个问题。 where标签&emsp;&emsp;where标签，当标签内的条件成立时，才会加入where这个SQL关键字到组装的SQL里面，否则就不加入，where还可以去掉一些特殊的SQL语法，比如说and、or，它去掉的时前缀的and和or。 12345678910111213141516&lt;select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\"&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍id --&gt; select * from user &lt;where&gt; &lt;if test=\"u_sex!=null\"&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt; &lt;if test=\"u_username!=null\"&gt; and u_username like \"%\"#&#123;u_username&#125;\"%\" &lt;/if&gt; &lt;if test=\"u_cid!=null\"&gt; and u_cid = #&#123;u_cid&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; &emsp;&emsp;在上面的案例中，如果and全写在sql拼接语句的后面，当c_cid==null的话，使用where语句就去不掉结尾的and。接下来的trim标签可以解决这个问题。 trim标签&emsp;&emsp;trim标签是要去掉一些特殊的字符串，它又四个属性，prefix、suffix、prefixOverrides、suffixOverrides。下面通过一个例子说一下这四个属性分别代表的意义。 12345678910111213141516&lt;select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\"&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍id --&gt; select * from user &lt;trim prefix=\"where\" suffixOverrides=\"and\"&gt; &lt;if test=\"u_sex!=null\"&gt; u_sex = #&#123;u_sex&#125; and &lt;/if&gt; &lt;if test=\"u_username!=null\"&gt; u_username like \"%\"#&#123;u_username&#125;\"%\" and &lt;/if&gt; &lt;if test=\"u_cid!=null\"&gt; u_cid = #&#123;u_cid&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; &emsp;&emsp;prefix=”where”，的意思是在trim头标签加上where之后再拼接上trim内的SQL语句，如果将其换成suffix=”where”的话，就会在trim内的的SQL语句后面接上where，显然在上面的案例中是不对的。&emsp;&emsp;suffixOverrides=”and”，的意思是去掉拼接语句尾部一些不合法的一些特殊字符，比如说and、or，如果将其换成prefixOverrides=”and”的话，就是去掉拼接语句开头一些不合法的的特殊字符。 set标签set标签在跟新表属性的时候，如果遇上不合法的逗号，会将其去掉。例如： 123456789101112131415&lt;update id=\"updateSetUser\" parameterType=\"User\"&gt; &lt;!-- 修改用户名和用户密码以及性别以id为限制 --&gt; update user set &lt;if test=\"u_username!=null and u_username!=''\"&gt; u_username = #&#123;u_username&#125;, &lt;/if&gt; &lt;if test=\"u_password!=null and u_password!=''\"&gt; u_password = #&#123;u_password&#125;, &lt;/if&gt; &lt;if test=\"u_sex!=null and u_sex!=''\"&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt; where u_id = #&#123;u_id&#125;&lt;/update&gt; &emsp;&emsp;在上面这个案例中，如果if语句最后一个不成立而它上一个if语句成立的时候，在拼接SQL语句的时候，就会出现SQL语法的错误，而使用set标签可以很好的解决这个错误。下面是使用set标签的案例。 12345678910111213141516&lt;update id=\"updateSetUser\" parameterType=\"User\"&gt; &lt;!-- 修改用户名和用户密码以及性别以id为限制 --&gt; update user &lt;set&gt; &lt;if test=\"u_username!=null and u_username!=''\"&gt; u_username = #&#123;u_username&#125;, &lt;/if&gt; &lt;if test=\"u_password!=null and u_password!=''\"&gt; u_password = #&#123;u_password&#125;, &lt;/if&gt; &lt;if test=\"u_sex!=null and u_sex!=''\"&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt; &lt;/set&gt; where u_id = #&#123;u_id&#125;&lt;/update&gt; &emsp;&emsp;如果最后一个条件12345678910111213### foreach标签&amp;emsp;&amp;emsp;foreach标签是一个循环语句，它的作用是遍历集合，它能够很好地支持数组和List、Set接口的集合，对此提供遍历的功能。&amp;emsp;&amp;emsp;比如说，我要查找数据库中id为1、3、5的用户，SQL语句应该这样写```select * from user where u_id in(1,3,5)```只能固定查3个id的用户，如果要查4个，必须再写一条sql语句，而foreach可以很好的解决这个问题。```xml&lt;select id=&quot;selectUserListByIds&quot; resultType=&quot;User&quot;&gt; select * from user where u_id in &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; collection表示传入的是数组还是集合是数组用array，是集合用list、set等，但如果是包装类的话，则需要使用包装类里面数组或集合的字段名。 item表示用什么表示数据或者集合里面的数，即循环中当前的元素。 open、close表示用什么元素把集合两端包起来。 separate表示用什么分隔。 index表示当前元素在集合中的位置。choose、when、otherwise标签&emsp;&emsp;choose、when、otherwise标签类似于java里面的wsitch…case…default…功能语句。下面是一个简单的案例。1234567891011121314151617&lt;select id=\"selectUserByUser\" parameterType=\"com.xiezhenyu.bean.User\" resultType=\"com.xiezhenyu.bean.User\"&gt; select * from user &lt;where&gt; &lt;choose&gt; &lt;when test=\"u_id!=null\"&gt; and u_id=#&#123;u_id&#125; &lt;/when&gt; &lt;when test=\"u_username!=null\"&gt; and u_username=#&#123;u_username&#125; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; &emsp;&emsp;当传过来的user的id不为空时，按照id为条件去查找，当传过来的id为空而username不为空时按照username去查找，当两个都为空时，查找不到。 sql标签&emsp;&emsp;在写sql语句的时候，有很多重复的语句片段，比如说，* from user```这句话就被重复了很多次，而使用sql标签可以将这些重复的字段提出来，什么时候用就引入一下就可以了。12345678910111213```xml&lt;sql id=&quot;selectUser&quot;&gt; select * from user&lt;/sql&gt;&lt;select id=&quot;selectUserListByIds&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; where u_id in &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; index=&quot;2&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; bind标签&emsp;&emsp;bind标签的作用是用过ONGL表达式去定义一个上下文变量，这样更方便使用，例如在进行模糊查询时，MySQL需要用到%和参数连接。定义接口方法 1public List&lt;User&gt; selectUserLikeUsername(@Param(\"str\")String str); 定义映射文件和一个新的变量，然后执行模糊查询 1234567&lt;select id=\"selectUserLikeUsername\" parameterType=\"string\" resultType=\"com.xiezhenyu.bean.User\"&gt; &lt;bind name=\"pattern\" value=\"'%'+str+'%'\"/&gt; select * from user where u_username like #&#123;pattern&#125;&lt;/select&gt; 测试方法 1234567891011121314151617@Testpublic void Test11() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; list = mapper.selectUserLikeUsername(\"王\"); for(User u : list) &#123; System.out.println(u); &#125;&#125;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"MyBatis的输入和输出映射","date":"2019-10-17T11:11:41.165Z","path":"2019/10/17/MyBatis的输入和输出映射/","text":"&emsp;&emsp;MyBatis的输入和输出映射，通过parameterType完成输入映射，通过resultType和resultMap完成输出映射。 1、输入映射parameterType&emsp;&emsp;输入映射中，可以给出类的全名，也可以给出类的别名，但是别名必须是MyBatis内部定义或者自定义的，可以选择JavaBean、Map等简单的参数类型传递给SQL。 1.1基本类型&emsp;&emsp;基本类型可以使用别名的方式，如果想要查看常见的 Java 类型内建的相应的类型别名，点击这里，它们都是不区分大小写的。(具体的测试方法可以看我上一篇写的博客) 123&lt;delete id=\"deleteUserById\" parameterType=\"Integer\"&gt; delete from user where u_id = #&#123;id&#125;&lt;/delete&gt; 1.2自定义对象&emsp;&emsp;输入类型还可以为自定义的对象，在书写Sql语句获取数值的时候，可以使用”#{对象字段名}”的方式取得数值。以下就是通过输入一个自定义对象的方式将参数传递给SQL，实现修改指定用户名的功能。(具体的测试方法可以看我上一篇写的博客) 123&lt;update id=\"updateUser\" parameterType=\"io.xiezhenyu98.bean.User\"&gt; update user set u_username = #&#123;u_username&#125; where u_id=#&#123;u_id&#125;&lt;/update&gt; 1.3自定义包装类&emsp;&emsp;输入类型还可以为自定义的包装类，在书写SQL语句获取数值的时候，可以使用”#{包装类字段.被包装类字段}”的方法获得数值。UserVo.java包装类 123456789101112public class UserVo &#123; //包装类 //需要全部的user对象信息 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; //需要表B的id name属性&#125; UserMapper.java接口 12//通过UserVo id查询一个用户public User selectUserByUserVoId(UserVo vo); UserMapper.xml映射文件 1234&lt;!-- 查找用户UserVo --&gt;&lt;select id=\"selectUserByUserVoId\" parameterType=\"UserVo\" resultType=\"user\"&gt; select * from user where u_id = #&#123;user.u_id&#125;&lt;/select&gt; 测试方法 12345678910111213141516171819@Testpublic void Test3() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserVo vo = new UserVo(); User user = new User(); user.setU_id(1); vo.setUser(user); User resultUser = mapper.selectUserByUserVoId(vo); System.out.println(resultUser);&#125; 结果 1User [u_id=1, u_username=老王, u_password=123, u_sex=1, u_createTime=null, u_cid=1] 2、输出映射resultType、resultMap2.1resultType&emsp;&emsp;resultType，定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射，数据库中表的字段名和JavaBean中的字段名对应，或定义为int、double、float、map等参数，也可以使用别名，但是要符合别名的规范，且不能和resultMap同时使用。resultType是常用的参数之一，比如统计总条数时可以把它设置为int。 2.1.1基本类型&emsp;&emsp;输出映射的基本类型和输入映射的基本类型一样，可以使用别名的方式，如果想要查看常见的 Java 类型内建的相应的类型别名，点击这里，它们都是不区分大小写的。以下是查询用户总数返回Integer的返回值。 1234&lt;!-- 查询用户总条数 --&gt;&lt;select id=\"selectUserCount\" resultType=\"Integer\"&gt; select count(*) from user&lt;/select&gt; 2.1.2自定义类型输出映射的自定义类型(具体的测试方法可以看我上一篇写的博客) 1234&lt;!-- 查找用户 --&gt;&lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"user\"&gt; select * from user where u_id = #&#123;id&#125;&lt;/select&gt; 2.2resultMap&emsp;&emsp;resultMap，它是映射集的引用，将执行强大的映射功能。可以使用resultType、resultMap的其中一个，resultMap能提供自定义映射规则的机会，数据库中表的字段名和JavaBean中的字段名不对应，则需要添加自定义映射。resultMap是MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler等等。 2.2.1Bean对象字段与数据库中字段不匹配创建Country实例，实例中Country的id与数据库中的不匹配(数据库中的为c_id) 123456789101112131415161718192021222324252627public class Country &#123; private Integer id; private String c_countryname; private String c_capital; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getC_countryname() &#123; return c_countryname; &#125; public void setC_countryname(String c_countryname) &#123; this.c_countryname = c_countryname; &#125; public String getC_capital() &#123; return c_capital; &#125; public void setC_capital(String c_capital) &#123; this.c_capital = c_capital; &#125; @Override public String toString() &#123; return \"Country [id=\" + id + \", c_countryname=\" + c_countryname + \", c_capital=\" + c_capital + \"]\"; &#125;&#125; 创建CountryMapper接口 123456import java.util.List;import com.siliedu.bean.Country;public interface CountryMapper &#123; //查询所有 public List&lt;Country&gt; selectAll();&#125; 创建CountryMapper映射文件 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.siliedu.mapper.CountryMapper\"&gt; &lt;!-- 查询所有 --&gt; &lt;!-- country为resultMap起一个名字 --&gt; &lt;resultMap type=\"Country\" id=\"country\"&gt; &lt;!-- id为javaBean中的字段，c_id为数据库中的字段，两个字段不匹配 --&gt; &lt;result property=\"id\" column=\"c_id\"/&gt; &lt;/resultMap&gt; &lt;!-- country为使用名为country的resultMap --&gt; &lt;select id=\"selectAll\" resultMap=\"country\"&gt; select * from country &lt;/select&gt;&lt;/mapper&gt; 测试方法 1234567891011121314151617@Testpublic void Test5() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); CountryMapper mapper = session.getMapper(CountryMapper.class); List&lt;Country&gt; list = mapper.selectAll(); for(Country c : list) &#123; System.out.println(c); &#125;&#125; 结果 1234Country [id=1, c_countryname=中国, c_capital=北京]Country [id=3, c_countryname=美国, c_capital=华盛顿]Country [id=4, c_countryname=英国, c_capital=伦敦]Country [id=5, c_countryname=日本, c_capital=东京] 在这里如果我们将resultMap改成resultType的话，id将查询不到。 123&lt;select id=\"selectAll\" resultType=\"country\"&gt; select * from country&lt;/select&gt; 结果 1234Country [id=null, c_countryname=中国, c_capital=北京]Country [id=null, c_countryname=美国, c_capital=华盛顿]Country [id=null, c_countryname=英国, c_capital=伦敦]Country [id=null, c_countryname=日本, c_capital=东京] 2.2.2关联查询2.2.2.1一对一&emsp;&emsp;一个用户只对应一个国家。(在单表查询的时候，javaBean对象的字段和数据库字段一致的时候可以省略但在多表查询的时候，我们要查询什么字段，就必须把什么字段列在映射文件上)UserVo包装类 1234567891011121314public class UserVo extends User&#123; private Country country; public Country getCountry() &#123; return country; &#125; public void setCountry(Country country) &#123; this.country = country; &#125; @Override public String toString() &#123; return \"UserVo [country=\" + country + \", getU_id()=\" + getU_id() + \", getU_username()=\" + getU_username() + \", getU_sex()=\" + getU_sex() + \"]\"; &#125;&#125; UserMapper接口 12//查询所有用户的包装类public List&lt;UserVo&gt; selectAllUserVo(); UserMapper.xml映射文件 123456789101112131415&lt;!-- 查询所有用户的包装类 --&gt;&lt;resultMap type=\"UserVo\" id=\"uservolist\"&gt; &lt;!-- 在单表查询的时候，javaBean对象的字段和数据库字段一致的时候可以省略 但在多表查询的时候，我们要查询什么字段，就必须把什么字段列上去 --&gt; &lt;id property=\"u_id\" column=\"u_id\"/&gt; &lt;id property=\"u_username\" column=\"u_username\"/&gt; &lt;id property=\"u_sex\" column=\"u_sex\"/&gt; &lt;association property=\"country\" javaType=\"Country\"&gt; &lt;result property=\"id\" column=\"c_id\"/&gt; &lt;result property=\"c_countryname\" column=\"c_countryname\"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"selectAllUserVo\" resultMap=\"uservolist\"&gt; select u.u_id,u.u_username,u.u_sex,c.c_id,c.c_countryname from user u left join country c on u.u_cid=c.c_id&lt;/select&gt; 测试方法 1234567891011121314151617@Testpublic void Test6() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;UserVo&gt; list = mapper.selectAllUserVo(); for(UserVo userVo : list) &#123; System.out.println(userVo); &#125;&#125; 结果：查询到了所有的用户，以及用户的国家，没有国家的用户也查询到了 123456789101112UserVo [country=Country [id=1, c_countryname=中国, c_capital=null], getU_id()=1, getU_username()=老王, getU_sex()=1]UserVo [country=Country [id=3, c_countryname=美国, c_capital=null], getU_id()=2, getU_username()=jack, getU_sex()=1]UserVo [country=Country [id=3, c_countryname=美国, c_capital=null], getU_id()=3, getU_username()=alice, getU_sex()=0]UserVo [country=Country [id=1, c_countryname=中国, c_capital=null], getU_id()=4, getU_username()=王司机, getU_sex()=1]UserVo [country=Country [id=4, c_countryname=英国, c_capital=null], getU_id()=5, getU_username()=anna, getU_sex()=0]UserVo [country=Country [id=1, c_countryname=中国, c_capital=null], getU_id()=6, getU_username()=李师傅, getU_sex()=1]UserVo [country=Country [id=5, c_countryname=日本, c_capital=null], getU_id()=7, getU_username()=漩涡鸣人, getU_sex()=1]UserVo [country=Country [id=5, c_countryname=日本, c_capital=null], getU_id()=8, getU_username()=娜美, getU_sex()=0]UserVo [country=Country [id=1, c_countryname=中国, c_capital=null], getU_id()=9, getU_username()=王五, getU_sex()=1]UserVo [country=null, getU_id()=10, getU_username()=老赵, getU_sex()=null]UserVo [country=null, getU_id()=11, getU_username()=老孙, getU_sex()=null]UserVo [country=null, getU_id()=12, getU_username()=98k, getU_sex()=null] 2.2.2.1一对多一个国家有多个用户。CountryVo包装类 123456789101112131415import java.util.List;public class CountryVo extends Country&#123; //需要维护一个User集合 private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() &#123; return userList; &#125; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; @Override public String toString() &#123; return \"CountryVo [userList=\" + userList + \", toString()=\" + super.toString() + \"]\"; &#125;&#125; CountryMapper接口 12//查询所有的CountryVopublic List&lt;CountryVo&gt; selectAllCountryVo(); CountryMapper映射文件 1234567891011121314151617181920212223&lt;!-- 查询所有的CountryVo --&gt;&lt;resultMap type=\"CountryVo\" id=\"countryvo\"&gt; &lt;id property=\"id\" column=\"c_id\"/&gt; &lt;result property=\"c_countryname\" column=\"c_countryname\"/&gt; &lt;result property=\"c_capital\" column=\"c_capital\"/&gt; &lt;!-- 一对多关系 --&gt; &lt;collection property=\"userList\" ofType=\"User\"&gt; &lt;id property=\"u_id\" column=\"u_id\"/&gt; &lt;result property=\"u_username\" column=\"u_username\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"selectAllCountryVo\" resultMap=\"countryvo\"&gt; select c.c_id, c.c_countryname, c.c_capital, u.u_id, u.u_username from country c left join user u on u.u_cid=c.c_id&lt;/select&gt; 测试方法 1234567891011121314151617@Testpublic void Test7() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); CountryMapper mapper = session.getMapper(CountryMapper.class); List&lt;CountryVo&gt; list = mapper.selectAllCountryVo(); for(CountryVo countryVo : list) &#123; System.out.println(countryVo); &#125;&#125; 结果：查询出了，一个国家有几个用户 1234CountryVo [userList=[User [u_id=1, u_username=老王, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=4, u_username=王司机, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=6, u_username=李师傅, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=9, u_username=王五, u_password=null, u_sex=null, u_createTime=null, u_cid=null]], toString()=Country [id=1, c_countryname=中国, c_capital=北京]]CountryVo [userList=[User [u_id=2, u_username=jack, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=3, u_username=alice, u_password=null, u_sex=null, u_createTime=null, u_cid=null]], toString()=Country [id=3, c_countryname=美国, c_capital=华盛顿]]CountryVo [userList=[User [u_id=5, u_username=anna, u_password=null, u_sex=null, u_createTime=null, u_cid=null]], toString()=Country [id=4, c_countryname=英国, c_capital=伦敦]]CountryVo [userList=[User [u_id=7, u_username=漩涡鸣人, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=8, u_username=娜美, u_password=null, u_sex=null, u_createTime=null, u_cid=null]], toString()=Country [id=5, c_countryname=日本, c_capital=东京]]","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"MaBatis的Mapper动态代理开发","date":"2019-10-17T03:53:03.885Z","path":"2019/10/17/MaBatis的Mapper动态代理开发/","text":"1 SqlSession的介绍&emsp;&emsp;SqlSession中封装了对数据库的操作，比如：更新、删除、查询等。通过SqlSessionFactory创建SqlSession，而SqlSessionFactory是由SqlSessionFactoryBuilder来创建的。 1.1 SqlSessionFactoryBuilderSqlSessionFactoryBuilder的作用是创建SqlSessionFacoty，SqlSessionFacoty创建了之后就不需要SqlSessionFactoryBuilder了，由于SqlSession是通过SqlSessionFactory生产，所以一般是将SqlSessionFactoryBuilder当成一个工具类使用，需要创建sqlSessionFactory时就new一个 SqlSessionFactoryBuilder，和Spring整合后由Spring以单例方式管理sqlSessionFactory。 1.2 SqlSessionFactorySqlSession是一个面向用户的接口， sqlSession中定义了数据库操作，默认使用DefaultSqlSession实现类。 2 MaBatis对Dao层的开发方式2.1 不使用Mapper动态代理开发编写dao层接口 1234public interface UserDao &#123; //根据id查询用户 public User getUserById(Integer id);&#125; 编写dao层接口实现类 1234567891011121314151617public class UserDaoImpl implements UserDao &#123; //sqlSession 工厂 private SqlSessionFactory ssf; //通过构造器给ssf赋值 public UserDaoImpl(SqlSessionFactory ssf) &#123; super(); this.ssf = ssf; &#125; @Override public User getUserById(Integer id) &#123; //生产一个sqlSession SqlSession session = ssf.openSession(); User user session.selectOne(\"UserMapper.selectUserById\",id); session.close(); return user; &#125;&#125; 编写测试方法 12345678910111213141516171819202122public class UserDaoTest &#123; //sqlSession 工厂 private static SqlSessionFactory ssf; static &#123; String resource = \"sqlMapConfig.xml\"; InputStream in; try &#123; in = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); ssf = ssfb.build(in); in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void DaoTest() &#123; UserDao dao = new UserDaoImpl(ssf); User user = dao.getUserById(1); System.out.println(user); &#125;&#125; &emsp;&emsp;不使用Mapper动态代理开发可以从代码中看到一些问题，每次我们调用SqlSession都要完成打开session、调用session完成与数据库的交互、关闭session，这三步，这些都是重复的代码。 2.2 使用Mapper动态代理开发首先想使用Mapper动态代理开发必须遵循四大原则加一个注意： 接口方法名需要与mapper.xml的要调用的sql语句的id一致 接口的形参类型需要与mapper.xml中的parameterType一致 接口的返回值需要与mapper.xml中的resultType一致 mapper.xml中的namespace要与接口的全包名一致注意：mapper动态代理开发中，根据返回值类型自动选择方法 UserMapper接口(mybatis提出mapper接口,相当于dao接口,mapper接口的命名方式建议为表名加Mapper) 1234public interface UserMapper &#123; //通过id查询一个用户 public User selectUserById(Integer id);&#125; UserMapper映射文件(mapper映射文件的命名方式建议表名加Mapper.xml,namespace指定为mapper接口的全限定名) 1234567&lt;!-- mapper.xml中的namespace要与接口的全包名一致 --&gt;&lt;mapper namespace=\"com.xiezhenyu.mapper.UserMapper\"&gt; &lt;!-- 查找用户 --&gt; &lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"user\"&gt; select * from user where u_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 将mapper.xml在SqlMapConfing.xml中进行注册 123&lt;mappers&gt; &lt;package name=\"com.xiezhenyu.mapper\"/&gt;&lt;/mappers&gt; 编写测试方法 123456789101112131415@Testpublic void Test1() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user);&#125; 结果： 1User [u_id=1, u_username=老王, u_password=123, u_sex=1, u_createTime=null, u_cid=1] 总结：使用Mapper代理进行开发&emsp;&emsp;优点：可以使我们只需要关注UserMapper.java接口中的方法，它的实现类由Mapper自动为我们生成，带来了很大的方便。&emsp;&emsp;缺点：如果UserMapper.java接口中的方法调用的statement中返回是多条记录，而mapper.java方法的返回值为JavaBean对象，此时代理对象通过selectOne调用，但由于返回的是多条记录所以会报错。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"傻瓜式使用MyBatis","date":"2019-10-13T09:59:27.728Z","path":"2019/10/13/傻瓜式使用MyBatis/","text":"MyBatis如何快速使用？ MyBatis框架图 1、下载MyBatis、创建项目、导包&emsp;&emsp;下载MyBatis：https://github.com/mybatis/mybatis-3/releases&emsp;&emsp;创建项目之后导入MyBatis的核心包和依赖包以及MySQL的连接包 2、创建测试用例，测试数据库、测试Bean对象&emsp;&emsp;创建测试数据库，直接运行以下SQL语句即可 123456789101112131415161718192021222324252627282930313233343536373839404142/*SQLyog Professional v12.08 (64 bit)MySQL - 5.5.49 : Database - ssm_mybatis**********************************************************************//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`ssm_mybatis` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `ssm_mybatis`;/*Table structure for table `country` */DROP TABLE IF EXISTS `country`;CREATE TABLE `country` ( `c_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '国家id', `c_countryname` varchar(128) NOT NULL COMMENT '国家名称', `c_capital` varchar(128) DEFAULT NULL COMMENT '国家首都名称', PRIMARY KEY (`c_id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;/*Data for the table `country` */insert into `country`(`c_id`,`c_countryname`,`c_capital`) values (1,'中国','北京'),(3,'美国','华盛顿'),(4,'英国','伦敦'),(5,'日本','东京');/*Table structure for table `user` */DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `u_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id', `u_username` varchar(64) NOT NULL COMMENT '用户名', `u_password` varchar(64) DEFAULT NULL COMMENT '用户密码', `u_sex` varchar(16) DEFAULT NULL COMMENT '用户性别', `u_createTime` datetime DEFAULT NULL COMMENT '用户创建时间', `u_cid` int(11) DEFAULT NULL COMMENT '用户国家id', PRIMARY KEY (`u_id`), KEY `FK_user_cid` (`u_cid`), CONSTRAINT `FK_user_cid` FOREIGN KEY (`u_cid`) REFERENCES `country` (`c_Id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;/*Data for the table `user` */insert into `user`(`u_id`,`u_username`,`u_password`,`u_sex`,`u_createTime`,`u_cid`) values (1,'老王','123','1',NULL,1),(2,'jack','123321','1',NULL,3),(3,'alice','ali111','0',NULL,3),(4,'王司机','666','1',NULL,1),(5,'anna','ali111','0',NULL,4),(6,'李师傅','222','1',NULL,1),(7,'漩涡鸣人','233','1',NULL,5),(8,'娜美','233','0',NULL,5),(9,'王五','abc','1',NULL,1),(10,'老赵',NULL,NULL,NULL,NULL),(11,'老孙',NULL,NULL,NULL,NULL),(12,'98k',NULL,NULL,NULL,NULL);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; &emsp;&emsp;创建测试Bean对象，与数据库创建的字段一致，并生成GET和SET方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class User &#123; private Integer u_id; private String u_username; private String u_password; private String u_sex; private Date u_createTime; private Integer u_cid; public Integer getU_id() &#123; return u_id; &#125; public void setU_id(Integer u_id) &#123; this.u_id = u_id; &#125; public String getU_username() &#123; return u_username; &#125; public void setU_username(String u_username) &#123; this.u_username = u_username; &#125; public String getU_password() &#123; return u_password; &#125; public void setU_password(String u_password) &#123; this.u_password = u_password; &#125; public String getU_sex() &#123; return u_sex; &#125; public void setU_sex(String u_sex) &#123; this.u_sex = u_sex; &#125; public Date getU_createTime() &#123; return u_createTime; &#125; public void setU_createTime(Date u_createTime) &#123; this.u_createTime = u_createTime; &#125; public Integer getU_cid() &#123; return u_cid; &#125; public void setU_cid(Integer u_cid) &#123; this.u_cid = u_cid; &#125; @Override public String toString() &#123; return \"User [u_id=\" + u_id + \", u_username=\" + u_username + \", u_password=\" + u_password + \", u_sex=\" + u_sex + \", u_createTime=\" + u_createTime + \", u_cid=\" + u_cid + \"]\"; &#125;&#125; 3、创建sqlMapConfig.xml主配置文件&emsp;&emsp;以下只是sqlMapConfig.xml主配置文件的一部分(会在快速使用MyBatis中使用到的一部分)，如果想要查看完整的配置文件请查看官方文档：https://mybatis.org/mybatis-3/zh/configuration.html 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 在集成spring时不用 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 使用jdbc的事务 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 使用连接池 链接数据库 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm_mybatis?serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf-8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"p123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4、创建Mapper.xml映射文件&emsp;&emsp;Mapper.xml映射文件中可以书写了查找用户、模糊查找用户、添加用户、修改用户、删除用户的sql语句，其中模糊查找中如果用字符串拼接的形式是不安全的，推荐使用占位符模糊查找。&emsp;&emsp;由于使用占位符查找，如果这样使用#{id}，如果传过来的id为1，他会在#{id}这个位置上显示’1’，加上了单引号，我们都知道模糊查找是 1select * from user where u_username like %你% &emsp;&emsp;如果我们使用占位符的话%’你’%这样是不行的，所以我们书写SQL语句的时候可以这样用 1select * from user where u_username like \"%\"'你'\"%\" &emsp;&emsp;以下是Mapper.xml映射文件 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"UserMapper\"&gt; &lt;!-- 查找用户 --&gt; &lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"com.siliedu.bean.User\"&gt; select * from user where u_id = #&#123;id&#125; &lt;/select&gt; &lt;!-- #&#123;&#125;占位符 尽量选用占位符解决问题 --&gt; &lt;!-- $&#123;&#125;字符串拼接 --&gt; &lt;!-- 模糊查找用户 --&gt; &lt;select id=\"selectUserByName\" parameterType=\"String\" resultType=\"com.siliedu.bean.User\"&gt; &lt;!-- select * from user where u_username like '%$&#123;value&#125;%' --&gt; select * from user where u_username like \"%\"#&#123;name&#125;\"%\" &lt;/select&gt; &lt;!-- 添加用户 --&gt; &lt;insert id=\"insertUser\" parameterType=\"com.siliedu.bean.User\"&gt; insert into user values(null,#&#123;u_username&#125;,#&#123;u_password&#125;,#&#123;u_sex&#125;,#&#123;u_createTime&#125;,#&#123;u_cid&#125;) &lt;/insert&gt; &lt;!-- 修改用户 --&gt; &lt;update id=\"updateUser\" parameterType=\"com.siliedu.bean.User\"&gt; update user set u_username = #&#123;u_username&#125; where u_id=#&#123;u_id&#125; &lt;/update&gt; &lt;!-- 删除用户 --&gt; &lt;delete id=\"deleteUserById\" parameterType=\"Integer\"&gt; delete from user where u_id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 5、书写测试方法测试通过id查找用户1234567891011121314151617@Test//通过ID查询用户public void Test1() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 User user = session.selectOne(\"UserMapper.selectUserById\", 1); System.out.println(user);&#125; 测试通过名字模糊查询用户12345678910111213141516171819@Test//通过name模糊查询用户public void Test2() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 List&lt;User&gt; list = session.selectList(\"UserMapper.selectUserByName\", \"王\"); for(User u : list) &#123; System.out.println(u); &#125;&#125; 测试新增用户由于对数据库进行了更新，session必须commit才能使事务提交，数据库才会更新 1234567891011121314151617181920212223@Test//通过新增用户public void Test3() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 User user = new User(); user.setU_username(\"小明\"); user.setU_password(\"123456789\"); user.setU_sex(\"1\"); user.setU_createTime(new Date()); user.setU_cid(1); session.insert(\"UserMapper.insertUser\", user); session.commit();&#125; 测试修改用户1234567891011121314151617181920@Test//修改用户public void Test4() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 User user = new User(); user.setU_id(13); user.setU_username(\"小刚\"); session.update(\"UserMapper.updateUser\", user); session.commit();&#125; 测试删除用户1234567891011121314151617@Test//删除用户public void Test5() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 session.delete(\"UserMapper.deleteUserById\", 13); session.commit();&#125; 以上就是MyBatis的简单使用。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"聊聊struts.xml配置文件-Struts(二)","date":"2019-10-08T11:47:44.023Z","path":"2019/10/08/聊聊struts.xml配置文件-Struts(二)/","text":"&emsp;&emsp;上一篇写了一下struts怎么快速上手使用，下面是struts的配置文件struts.xml中一些配置的解释(●’◡’●)。 &emsp;&emsp;struts.xml是整个程序的工作流程的依据，该文件的根元素是&lt;struts&gt;，其中可以包含4个子元素，分别是：&lt;include&gt;、&lt;constant&gt;、&lt;bean&gt;、&lt;package&gt; &lt;include&gt;元素&emsp;&emsp;由于用struts开发一个大型的项目时，struts中的配置信息会越来越多，这样就会使配置文件的可读性和维护性变差，但使用了&lt;include&gt;就会解决这个问题，我们可以按照不同的功能或者模块将配置文件分割成多个配置文件。 1234&lt;struts&gt; &lt;include file=\"login.xml\"&gt;&lt;/include&gt; &lt;include file=\"register.xml\"&gt;&lt;/include&gt;&lt;/struts&gt; &lt;constant&gt;元素&emsp;&emsp;&lt;constant&gt;元素用于配置一些常量信息，这些常量用于控制struts2的某些特性，相当于当他运行时，给你准备哪些功能。由于&lt;constant&gt;元素的常量值过多，我只列一些常用的，以下例子是&lt;constant&gt;元素使用的常用设置 12345678910111213141516171819202122232425&lt;struts&gt; &lt;!-- 匹配所有以\".action\"为后缀的请求都由struts处理，其中action可变 如果需要匹配多个后缀都由struts处理，则使用英文\",\"号分隔，例如value=\"do,action\" 如果不写这一句，则会默认映射Action名字 --&gt; &lt;constant name=\"struts.action.extension\" value=\"action\" /&gt; &lt;!-- 是否启用开发者模式，在开发者模式下可打印出更加详细的报错信息 --&gt; &lt;constant name=\"struts.devMode\" value=\"true\" /&gt; &lt;!-- 当struts配置文件改动后，是否重新加载，默认不写是false --&gt; &lt;constant name=\"struts.configuration.xml.reload\" value=\"true\" /&gt; &lt;!-- 设置浏览器是否缓存静态内容，默认不写为true缓存，在开发环境下最好关闭，可以提高开发效率 --&gt; &lt;constant name=\"struts.serve.static.browserCache\" value=\"true\" /&gt; &lt;!-- 设置请求参数的编码方式，实际上相当于相当调用HttpServletRequest中的setCharacterEncoding方法 --&gt; &lt;constant name=\"struts.i18n.encoding\" value=\"utf-8\" /&gt; &lt;!-- 每次HTTP请求系统都重新加载资源文件 --&gt; &lt;constant name=\"struts.i18n.reload\" value=\"false\" /&gt; &lt;!-- 文件上传的最大值，单位为字节 --&gt; &lt;constant name=\"struts.multipart.maxSize\" value=\"1024\" /&gt; &lt;!-- 让Struts支持动态方法调用 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" /&gt; &lt;!-- 在URL中的Action段中是否支持斜线 --&gt; &lt;constant name=\"struts.enable.SlashesInActionNames\" value=\"false\" /&gt; &lt;!-- 标签中是否支持ognl表达式 --&gt; &lt;constant name=\"struts.tag.altSyntax\" value=\"true\" /&gt;&lt;/struts&gt; &lt;bean&gt;元素&emsp;&emsp;struts2是一个可扩展的框架，核心组件都是可以配置的，当我们需要扩展或替换struts2的核心组件时，只需要提供自己的组件实现类，并部署到struts2的容器中即可。&emsp;&emsp;例子：使用一个自定义的ObjectFactory替换struts2内置的ObjectFactory： 1&lt;bean name=\"myFactory\" type=\"com.opensymphony.xwork2.ObjectFactory\" class=\"xiezhenyu.ObjectFactory\" /&gt; &lt;package&gt;元素&emsp;&emsp;&lt;package&gt;元素提供了将多个Action组织为一个模块的方式，package的name在整个struts配置文件中必须是唯一的，并且一个package可以扩展自另一个package。此时改package会在本身配置的基础上加入扩展package的配置，但要注意父package必须在子package前配置。 123456789&lt;!-- package的属性name:package名称，作为其他包引用本包的标识，必填属性extends:继承的父package名称，可选属性。通常设置为struts-default，继承struts-default.xml，它里面定义了许多跳转类型、拦截器等一些常用的东西abstract:设置package的属性为抽象的，抽象的package不能定义Action，可选属性。namespace:可选属性。浏览器地址是根据namespace/action名称去访问的action其中namespace可以是虚路径--&gt;&lt;package name=\"MyStruts\" extends=\"struts-default\" namespace=\"/\"&gt;&lt;/package&gt; &lt;package&gt;子元素列表 子元素 功能 default-action-ref 配置默认的Action default-class-ref 配置默认class default-interceptor-ref 配置默认拦截器，对package范围内的所有Action有效 global-results 配置全局结果集，对package范围内的所有Action有效 global-exception-mapping 配置全局异常映射，对package范围内的所有Action有效 result-types 配置定义返回结果类型 interceptors 配置拦截器信息 action 配置Action信息 &lt;default-action-ref&gt;&emsp;&emsp;&lt;default-action-ref&gt;元素用于配置默认的Action，当一个Action请求在配置文件中找不到时，就会执行这个默认的Action，该元素只有一个name属性。 1&lt;default-action-ref name=\"Error\"&gt;&lt;/default-action-ref&gt; &lt;default-class-ref&gt;&emsp;&emsp;&lt;default-class-ref&gt;元素用户配置默认的类，在配置Action时，如果没有指定具体的class属性，系统就会使用&lt;default-class-ref&gt;元素中的配置。&lt;default-class-ref&gt;只有一个class属性。当使用&lt;default-class-ref&gt;元素指定了默认类后，Struts原来默认的类会被覆盖，而且默认的Action类必须包含execute()方法。 &lt;default-interceptor-ref&gt;&emsp;&emsp;&lt;default-interceptor-ref&gt;元素用于配置默认类拦截器，如果package继承了“struts-default”，那么也会继承父类package的默认拦截器。 &lt;global-result&gt;&emsp;&emsp;&lt;global-result&gt;元素用于配置package范围内的全局结果集。他的子元素是&lt;result&gt;。当一个package中多个Action都使用了一个或多个结果的时候，则将其配置在全局结果集中，增强代码的可读性和维护性。例如下面这个案列：当每个Action都返回了error的时候，全都使用这个全局结果去执行。 123&lt;global-result&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt;&lt;/global-result&gt; &lt;global-exception-mapping&gt;&emsp;&emsp;&lt;global-exception-mapping&gt;元素用于配置全局异常映射，如果&lt;action&gt;元素内配置了自己的异常映射，则Action内的优先级高于此配置。他的子元素是&lt;exception-mapping&gt;。 123&lt;global-exception-mapping&gt; &lt;exception-mapping result=\"error\" exception=\"异常类型\"&gt;&lt;/exception-mapping&gt;&lt;/global-exception-mapping&gt; &lt;result-type&gt;&emsp;&emsp;&lt;result-type&gt;元素用于配置自定义返回结果类型，该元素基本不用。 &lt;interceptors&gt;&emsp;&emsp;&lt;interceptors&gt;元素用于配置拦截器的拦截器栈，他有两个子元素：&lt;interceptor&gt;和&lt;interceptor-stack&gt;，分别用来定义拦截器和拦截器栈。 &lt;action&gt;&lt;action&gt;元素是比较重要的一个元素，也是我们开发中使用最多的一个元素。它有4个属性： name：必选属性，Action的名字。 class：可选属性，Action处理类的名字。 method：可选属性，指定Action中的方法。如果没有配置该属性，所有请求都会被转发到execute()方法去处理。如果有多个请求需要分别交给不同的方法去处理，就可以使用该属性来指明。 converter：可选属性，指定Action使用的类型转换器。 &emsp;&emsp;method属性除了可以填固定的函数名外，还可以使用通配符的方法实现动态方法调用，使用它的前提是必须要配置&lt;constant&gt;元素和&lt;global-allowed-methods&gt;，使其能实现动态方法调用和适配所有的方法。 123456789101112 &lt;struts&gt; &lt;!-- 让Struts支持动态方法调用 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" /&gt; &lt;package name=\"Struts\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 适配所有的通配符方法 --&gt; &lt;global-allowed-methods&gt;regex:.*&lt;/global-allowed-methods&gt; &lt;action name=\"*User\" class=\"xiezhenyu.UserAction\" method=\"&#123;1&#125;User\"&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt; &lt;result name=\"success\"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; &emsp;&emsp;如上代码所示，name属性值中的”*“就是通配符，表示所有以User结尾的亲求都会有这个Action处理；method属性值中的“{1}”是表达式，表示name属性中”*“的值，比如请求为loginUser，那么将传递给method属性，这是会调用Action中loginUser()方法。 &lt;action&gt;中还有以下几个子元素 &lt;interceptor-ref&gt;：用于配置拦截器 &lt;exception-mapping&gt;：用于配置异常映射 &lt;result&gt;：用于配置Action的结果映射，除了常规的结果映射外，也可以像method属性值一样使用表达式，实行动态结果。&lt;result&gt;有两个属性，name、type。name为Action类在处理完成返回的都是字符串类型的结果，这个结果作为逻辑视图存在，对应&lt;result&gt;元素的name属性值，然后找到与之对应的视图资源。type为指定结果的类型，其取值如下表所示。（我们只需要记住dispatcher、redirect和chain三个常用的即可，其它的略作了解） type可取值 解释 dispatcher 转发，默认结果类型，对应视图为JSP界面 chain 将Action和另一个Action链接起来 freemarker 返回结果的对应视图为FreeMarker模板 HttpHeaderResult 返回一个已配置好的HTTP头信息响应 redirect 将用户重定向到一个配置好的URL redirectAction 将用户重定向到一个已定义好的Action stream 将原数据作为流传递会浏览器，一般用于下载 velocity 返回结果的对应视图为Velocity模板 xslt 呈现XML到浏览器，该XML可以通过XSL模板进行转换 plaintext 返回普通文本内容 以上就是struts2配置文件的大部分内容。","tags":[{"name":"struts","slug":"struts","permalink":"https://Xiezhenyu98.github.io/tags/struts/"}]},{"title":"傻瓜式使用Struts-Struts(一)","date":"2019-10-07T06:53:12.957Z","path":"2019/10/07/傻瓜式使用Struts-Struts(一)/","text":"我现在大三了，很多同学都想转行JAVA(还好我大一就确定目标学java了(●’◡’●))，今天有人问我struts怎么用，为了同学的方便，我写了这篇傻瓜式使用struts框架的博客，希望能让同学们快速使用struts框架。(本篇本着可复现的态度写的，测试可用) 1、导入strurs需要用到的jar包经过本人整理出以下需要用到的一些包commons-fileupload-1.3.3.jarcommons-io-2.5.jarcommons-lang3-3.6.jarcommons-logging-1.1.3.jarfreemarker-2.3.26-incubating.jarjavassist-3.20.0-GA.jarlog4j-api-2.10.0.jarlog4j-core-2.11.0.jarognl-3.1.15.jarstruts2-core-2.5.16.jar你可以通过 点击这里下载 2、配置web.xml在web.xml中配置struts(添加filter) 12345678&lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3、创建Action创建一个Action并继承ActionSupport，从写里面的execute方法或者写一个带有String返回值并抛出一个异常的函数（异常可以抛出也可以不抛出） 123456public class SturtsAction extends ActionSupport&#123; public String test() throws Exception &#123; System.out.println(\"sss\"); return \"index\"; &#125;&#125; 4、配置struts.xmlstruts.xml必须创建在src根目录下 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- name:可以随便写 namespace:浏览器地址是根据namespace/action名称去访问的action其中namespace可以是虚路径 extends:struts-default 为继承struts的默认结果集，就是继承struts-default.xml，它里面定义了许多跳转类型、拦截器等一些常用的东西 --&gt; &lt;package name=\"Struts\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- name:浏览器访问的路径 class:这个类的路径 method:方法名 这三个连起来可以理解为：浏览器访问的路径是访问的哪个类中的哪个方法 --&gt; &lt;action name=\"StrutsAction\" class=\"com.xiezhenyu.web.SturtsAction\" method=\"test\"&gt; &lt;!-- name:与test方法中返回的字符串对应，后面的是跳转到哪一个页面 --&gt; &lt;result name=\"index\"&gt;/index.html&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 5、测试struts在eclipse跑起来之后输入地址，使用struts成功！！ 注意：其中struts.xml的配置文件只是其中一部分配置，目前并不能当成万金油使用，本篇只是介绍struts如何快速使用，就不一一介绍struts的详细配置文件，后续我会一一写出。","tags":[{"name":"struts","slug":"struts","permalink":"https://Xiezhenyu98.github.io/tags/struts/"}]}]