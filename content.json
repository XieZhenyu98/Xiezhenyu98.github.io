[{"title":"Spring Boot学习笔记(十三) -整合持久层技术(MyBatis篇)","date":"2020-04-13T11:02:07.966Z","path":"2020/04/13/Spring Boot学习笔记(十三) -异常处理与单元测试/","text":"1、异常处理SpringBoot对于异常处理提供了五种处理方式。 1.1、自定义错误页面&emsp;&emsp;SpringBoot 默认的处理异常的机制：SpringBoot默认的已经提供了一套处理异常的机制。一旦程序出现了异常SpringBoot会向/error 的 url 发送请求。在SpringBoot中提供了一个名为 BasicErrorController 来处理 /error 请求，然后跳转到默认显示异常的页面来展示异常信息。&emsp;&emsp;如果我们需要将所有的异常同一跳转到自定义的错误页面，需要再src/main/resources/templates 目录下创建 error.html 页面。注意：页面名称必须叫 error。 1.2、通过@ExceptionHandler注解处理异常当controller中出现空指针异常的时候，都会执行下面这个函数。 1234567@ExceptionHandler(value = &#123;java.lang.NullPointerException.class&#125;)public ModelAndView nullpointExcetionHandler(Exception e)&#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"err\",e.toString()); mv.setViewName(\"error1\");//跳转到哪个视图 return mv;&#125; 弊端：处理异常的方法必须要和出现异常的方法在同一个Controller上面，达不到代码的复用。 1.3、通过@ControllerAdvice与@ExceptionHandler注解处理异常，实现全局异常处理&emsp;&emsp;只要Controller中出现异常，都会找标有@ControllerAdvice注释的类去找对应的处理方法。 1234567891011121314151617181920/** * 全局异常处理类 */@ControllerAdvicepublic class GlobalException &#123; @ExceptionHandler(value = &#123;java.lang.NullPointerException.class&#125;) public ModelAndView nullpointExcetionHandler(Exception e)&#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"err\",e.toString()); mv.setViewName(\"error1\");//跳转到哪个视图 return mv; &#125; @ExceptionHandler(value = &#123;java.lang.ArithmeticException.class&#125;) public ModelAndView arithmeticException(Exception e)&#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"err\",e.toString()); mv.setViewName(\"error2\");//跳转到哪个视图 return mv; &#125;&#125; 弊端：在全局异常处理类中的方法会特别多。 1.4、通过SimpleMappingExceptionResolver对象处理异常&emsp;&emsp;做异常和视图的映射实现异常的处理。 1234567891011121314151617181920@Configurationpublic class GlobalException2 &#123; /** * 此方法返回值必须是SimpleMappingExceptionResolver * @return */ @Bean public SimpleMappingExceptionResolver getSimpleMappingExceptionResolver()&#123; SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver(); Properties properties = new Properties(); /** * 参数一：异常类型，并且是全名 * 参数二：视图名称 */ properties.put(\"java.lang.NullPointerException\",\"error\"); properties.put(\"java.lang.ArithmeticException\",\"error2\"); resolver.setExceptionMappings(properties); return resolver; &#125;&#125; 弊端：只能做视图和异常的映射，不能传递异常信息。 1.5、通过自定义HandlerExceptionResolver对象处理异常&emsp;&emsp;通过实现HandlerExceptionResolver接口的方式进行异常处理。 12345678910111213141516171819202122232425262728/** * 自定义HandlerExceptionResolver对象处理异常 * 必须实现HandlerExceptionResolver接口 */@Configurationpublic class GlobalException3 implements HandlerExceptionResolver &#123; /** * * @param httpServletRequest 请求 * @param httpServletResponse 响应 * @param o handler 参数异常的handler对象 * @param e 产出异常的对象 * @return */ @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; ModelAndView mv = new ModelAndView(); //判断不同异常的类型，做不同视图的跳转 if(e instanceof NullPointerException)&#123; mv.setViewName(\"error\"); &#125; if(e instanceof ArithmeticException)&#123; mv.setViewName(\"error2\"); &#125; mv.addObject(\"error\",e.toString()); return mv; &#125;&#125; 2、Spring Boot 整合 Junit 单元测试&emsp;&esmp;Spring Boot2.x 使用 Junit5 作为测试平台 2.1、修改POM文件添加测试启动器123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- junit-vintage-engine 提供junit3与junit4的运行平台 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 2.2、编写测试代码1234567891011121314/** * 在Junit5中可以不写启动器的类 * 如果需要不同的启动器启动项目就可以配 * 例如@SpringBootTest(classpath = XXX.class) */@SpringBootTestpublic class UsersTest &#123; @Autowired private UsersService usersService; @Test void suibian()&#123; this.usersService.addUser(); &#125;&#125;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Spring Boot学习笔记(十二) -整合持久层技术(MyBatis篇)","date":"2020-04-13T09:15:48.840Z","path":"2020/04/13/Spring Boot学习笔记(十二) -整合持久层技术(MyBatis篇)/","text":"&emsp;&emsp;通过使用Spring Boot+Spring MVC + Mybatis 整合实现一个对数据库中的users表的CRUD的操作。 1、创建项目1.1、修改POM文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xiezhenyu&lt;/groupId&gt; &lt;artifactId&gt;springbootmybatis2&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootmybatis2&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- thymeleaf 启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot web启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis 启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Druid数据源依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql数据库驱动坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 测试启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 1.2、添加application.properties全部配置文件123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test?userUnicode=true&amp;characterEncoding=UTF-8&amp;userSSL=false&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=p123456spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.xiezhenyu.springbootmybatis2.pojo 1.3、数据库表设计 2、添加用户2.1、创建实体类12345678910111213141516171819202122232425package com.xiezhenyu.springbootmybatis2.pojo;public class Users &#123; private Integer userid; private String username; private String usersex; public Integer getUserid() &#123; return userid; &#125; public void setUserid(Integer userid) &#123; this.userid = userid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getUsersex() &#123; return usersex; &#125; public void setUsersex(String usersex) &#123; this.usersex = usersex; &#125;&#125; 2.2、创建mapper接口以及映射配置文件mapper接口 123public interface UsersMapper &#123; void insertUser(Users users);&#125; 映射配置文件 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xiezhenyu.springbootmybatis2.mapper.UsersMapper\"&gt; &lt;insert id=\"inserUser\" parameterType=\"users\"&gt; insert into users(username,usersex) values(#&#123;username&#125;,#&#123;usersex&#125;) &lt;/insert&gt;&lt;/mapper&gt; 2.3、创建业务层123456789public class UsersServiceImpl implements UsersService &#123; @Autowired private UsersMapper usersMapper; @Override public void addUser(Users users) &#123; this.usersMapper.insertUser(users); &#125;&#125; 2.4、创建Controller123456789101112131415161718192021@Controller@RequestMapping(\"/users\")public class UsersController &#123; @Autowired private UsersService usersService; /** * 页面跳转 */ @RequestMapping(\"/&#123;page&#125;\") public String showPage(@PathVariable String page)&#123; return page; &#125; /** * 添加用户 */ @PostMapping(\"/addUser\") public String addUser(Users users)&#123; this.addUser(users); return \"ok\"; &#125;&#125; 2.5、编写页面123456789101112131415&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;link rel=\"shortcut icon\" href=\"../resource/favicon.ico\" th:href=\"@&#123;/static/favicon.ico&#125;\"/&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=\"@&#123;/users/addUser&#125;\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"usersex\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"ok\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678910&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;操作成功！&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 2.6、启动类1234567@SpringBootApplication@MapperScan(\"com.xiezhenyu.mapper\") //@MapperScan 用于扫描Mybatis的mapper接口public class Springbootmybatis2Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Spirngbootmybatis2Application.class, args); &#125;&#125; 3、查询用户3.1、创建mapper及映射配置文件1234public interface UsersMapper &#123; void insertUser(Users users); List&lt;Users&gt; selectUsersAll();&#125; 123&lt;select id=\"selectUsersAll\" resultType=\"users\"&gt; select * from users&lt;/select&gt; 3.2、在业务层中添加查询方法1234@Overridepublic List&lt;Users&gt; findUserAll() &#123; return this.usersMapper.selectUsersAll();&#125; 3.3、在Controller中添加方法123456789/** * 查询用户 */@RequestMapping(\"/findUserAll\")public String findUser(Model model)&#123; List&lt;Users&gt; list = this.usersService.findUserAll(); model.addAttribute(\"list\",list); return \"showUser\";&#125; 3.4、编写页面1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" width=\"50%\" align=\"center\"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"u : $&#123;list&#125;\"&gt; &lt;td th:text=\"$&#123;u.userid&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;u.username&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;u.usersex&#125;\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a th:href=\"@&#123;/user/preUpdateUser(id=$&#123;u.userid&#125;)&#125;\"&gt;修改&lt;/a&gt; &lt;a th:href=\"@&#123;/user/deleteUser(id=$&#123;u.userid&#125;)&#125;\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 4、用户预更新4.1、创建mapper及映射配置文件12345public interface UsersMapper &#123; void insertUser(Users users); List&lt;Users&gt; selectUsersAll(); Users selectUserById(Integer id);&#125; 123&lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"users\"&gt; select * from users where userid = #&#123;userid&#125;&lt;/select&gt; 4.2、在业务层中添加查询方法1234@Overridepublic Users findUserById(Integer id) &#123; return this.usersMapper.selectUserById(id);&#125; 4.3、在Controller中添加方法123456789/** * 预更新查询 */@RequestMapping(\"/preUpdateUser\")public String findUserById(Integer id,Model model)&#123; Users user = this.usersService.findUserById(id); model.addAttribute(\"user\",user); return \"updateUser\";&#125; 4.4、编写页面123456789101112131415&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=\"@&#123;/user/updateUser&#125;\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"userid\" th:value=\"$&#123;user.userid&#125;\"/&gt; &lt;input type=\"text\" name=\"username\" th:value=\"$&#123;user.username&#125;\"/&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"usersex\" th:value=\"$&#123;user.usersex&#125;\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"修改\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 5、用户修改5.1、创建mapper及映射配置文件123456public interface UsersMapper &#123; void insertUser(Users users); List&lt;Users&gt; selectUsersAll(); Users selectUserById(Integer id); void updateUser(Users users);&#125; 123&lt;update id=\"updateUser\" parameterType=\"users\"&gt; update users set username=#&#123;username&#125;,usersex=#&#123;usersex&#125; where userid = #&#123;userid&#125;&lt;/update&gt; 5.2、在业务层中添加查询方法1234@Overridepublic void updateUser(Users users) &#123; this.usersMapper.updateUser(users);&#125; 5.3、在Controller中添加方法12345678/** * 用户更新 */@RequestMapping(\"updateUser\")public String updateUser(Users users)&#123; this.usersService.updateUser(users); return \"ok\";&#125; 6、用户删除6.1、创建mapper及映射配置文件1234567public interface UsersMapper &#123; void insertUser(Users users); List&lt;Users&gt; selectUsersAll(); Users selectUserById(Integer id); void updateUser(Users users); void deleteUserById(Integer id);&#125; 123&lt;delete id=\"deleteUserById\" parameterType=\"Integer\"&gt; delete from users where userid = #&#123;userid&#125;&lt;/delete&gt; 6.2、在业务层中添加查询方法1234@Overridepublic void deleteUserById(Integer id) &#123; this.usersMapper.deleteUserById(id);&#125; 6.3、在Controller中添加方法12345678/** * 删除用户 */@RequestMapping(\"deleteUser\")public String deleteUserById(Integer id)&#123; this.usersService.deleteUserById(id); return \"ok\";&#125;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"【BUG】org.apache.ibatis.binding.BindingException_ Invalid bound statement (not found)_ com.xiezhenyu.","date":"2020-04-13T06:02:23.774Z","path":"2020/04/13/【BUG】org.apache.ibatis.binding.BindingException_ Invalid bound statement (not found)_ com.xiezhenyu./","text":"控制台错误如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172732020-04-13 13:46:11.962 ERROR 23544 --- [nio-8080-exec-3] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.xiezhenyu.springbootmybatis2.mapper.UsersMapper.insertUser] with root causeorg.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.xiezhenyu.springbootmybatis2.mapper.UsersMapper.insertUser at org.apache.ibatis.binding.MapperMethod$SqlCommand.&lt;init&gt;(MapperMethod.java:235) ~[mybatis-3.5.4.jar:3.5.4] at org.apache.ibatis.binding.MapperMethod.&lt;init&gt;(MapperMethod.java:53) ~[mybatis-3.5.4.jar:3.5.4] at org.apache.ibatis.binding.MapperProxy.lambda$cachedInvoker$0(MapperProxy.java:107) ~[mybatis-3.5.4.jar:3.5.4] at java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1660) ~[na:1.8.0_221] at org.apache.ibatis.binding.MapperProxy.cachedInvoker(MapperProxy.java:94) ~[mybatis-3.5.4.jar:3.5.4] at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:85) ~[mybatis-3.5.4.jar:3.5.4] at com.sun.proxy.$Proxy63.insertUser(Unknown Source) ~[na:na] at com.xiezhenyu.springbootmybatis2.service.impl.UsersServiceImpl.addUser(UsersServiceImpl.java:19) ~[classes/:na] at com.xiezhenyu.springbootmybatis2.service.impl.UsersServiceImpl$$FastClassBySpringCGLIB$$da59c2a6.invoke(&lt;generated&gt;) ~[classes/:na] at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:366) ~[spring-tx-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:118) ~[spring-tx-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE] at com.xiezhenyu.springbootmybatis2.service.impl.UsersServiceImpl$$EnhancerBySpringCGLIB$$1d8137dd.addUser(&lt;generated&gt;) ~[classes/:na] at com.xiezhenyu.springbootmybatis2.controller.UsersController.addUser(UsersController.java:29) ~[classes/:na] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_221] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_221] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_221] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_221] at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_221] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_221] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_221] 在遇到这个错误之后，在网上找了很多解决方案：1：检查xml文件所在的package名称是否和interface对应的package名称一一对应。 2：检查xml文件的namespace是否和xml文件的package名称一一对应。 3：检查函数名称能否对应上。 4：去掉xml文件中的中文注释。 5：随意在xml文件中加一个空格或者空行然后保存。 经过我一 一排查之后，问题依然存在，最后我发现，我编译后的工程没有把xml一起导入（即使我把接口和接口映射文件放在同一个目录下src/main/java/mapper） 解决：在POM.xml中添加以下配置，将src/main/java，中的xml全部参与编译： 123456789101112&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 问题最终得到解决： 希望我的解答能对大家有帮助！","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"},{"name":"BUG","slug":"BUG","permalink":"https://Xiezhenyu98.github.io/tags/BUG/"}]},{"title":"Spring Boot学习笔记(十一) -整合持久层技术(JDBC篇)","date":"2020-04-09T07:46:50.210Z","path":"2020/04/09/Spring Boot学习笔记(十一) -整合持久层技术(JDBC篇)/","text":"1、整合JDBC1.1、搭建项目环境1.1.1、创建表12345CREATE TABLE `test`.`user` ( `userid` INT NOT NULL AUTO_INCREMENT, `username` VARCHAR(30) NULL, `usersex` VARCHAR(10) NULL, PRIMARY KEY (`userid`)); 1.1.2、创建项目 1.1.3、修改POM文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xiezhenyu&lt;/groupId&gt; &lt;artifactId&gt;springbootjdbc&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootjdbc&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Thymeleaf启动器坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jdbc启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql数据库驱动坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 1.2、配置数据源1.2.1、通过自定义配置文件方式配置数据源信息1.2.1.1、通过@PropertySource注解读取配置信息 添加Druid数据源依赖 123456&lt;!-- Druid数据源依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt; 创建Properties文件 1234jdbc.driverClassName=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/test?userUnicode=true&amp;characterEncoding=UTF-8&amp;userSSL=false&amp;serverTimezone=Asia/Shanghaijdbc.username=rootjdbc.password=p123456 创建配置类 12345678910111213141516171819202122232425262728293031323334package com.xiezhenyu.springbootjdbc.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import javax.sql.DataSource;/** * 数据源jdbc的配置类 */@Configuration@PropertySource(\"classpath:/jdbc.properties\")//加载指定的properties配置文件public class JdbcConfiguration &#123; @Value(\"$&#123;jdbc.driverClassName&#125;\") private String driverClassName; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; /** * 实例化Druid */ @Bean public DataSource getDatasource()&#123; DruidDataSource source = new DruidDataSource(); source.setUsername(this.username); source.setPassword(this.password); source.setUrl(this.url); source.setDriverClassName(this.driverClassName); return source; &#125;&#125; 1.2.1.2、通过@ConfigurationProperties注解读取配置信息 创建配置信息实体类 12345678910111213141516171819202122232425262728293031323334/** * JDBC配置信息属性类 */@ConfigurationProperties(prefix = \"jdbc\") //是SpringBoot的注解，不能读取其他的配置文件，只能读取SpringBoot的application配置文件public class JdbcProperties &#123; private String driverClassName; private String url; private String username; private String password; public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 修改配置类 123456789101112131415161718192021/** * 数据源jdbc的配置类 */@Configuration@EnableConfigurationProperties(JdbcProperties.class)//指定加载哪个配置信息属性类public class JdbcConfiguration &#123; @Autowired private JdbcProperties jdbcProperties; /** * 实例化Druid */ @Bean public DataSource getDatasource()&#123; DruidDataSource source = new DruidDataSource(); source.setUsername(this.jdbcProperties.getUsername()); source.setPassword(this.jdbcProperties.getPassword()); source.setUrl(this.jdbcProperties.getUrl()); source.setDriverClassName(this.jdbcProperties.getDriverClassName()); return source; &#125;&#125; 1.2.1.3、@ConfigurationProperties注解的优雅使用方式&emsp;&emsp;在上面使用@ConfigurationProperties的时候，需要通过@ConfigurationProperties配置信息的实体类，进而在数据源配置类中通过注入的方式读取配置信息实体类，来获取信息。&emsp;&emsp;其实@ConfigurationProperties还可以在方法中使用当实例化Druid的时候可以直接在方法上添加@ConfigurationProperties注解，来获取配置信息。而这个注解就会自动把配置信息中的uername、password等数据自动调用DruidDataSource 的setUsername、setPassword等方法来设置信息。 123456789101112131415/** * 数据源jdbc的配置类 */@Configurationpublic class JdbcConfiguration &#123; /** * 实例化Druid */ @Bean @ConfigurationProperties(prefix = \"jdbc\") public DataSource getDatasource()&#123; DruidDataSource source = new DruidDataSource(); return source; &#125;&#125; 1.2.2、通过Spring Boot配置文件配置数据源信息&emsp;&emsp;在Spring Boot1.x版本中的spring-boot-starter-jdbc启动器中默认使用的是org.apache.tomcat.jdbc.pool.DataSource作为数据源。&emsp;&emsp;在Spring Boot2.x版本中的spring-boot-starter-jdbc启动器默认使用的是com.zaxxer.hikariDataSource作为数据源。 1.2.2.1、使用Spring Boot默认的HikariDataSource数据源&emsp;&emsp;在application.properties中配置以下信息之后，在需要到数据源的时候直接注入即可。 1234spring.datasource.url=jdbc:mysql://localhost:3306/test?userUnicode=true&amp;characterEncoding=UTF-8&amp;userSSL=false&amp;serverTimezone=Asia/Shanghaispring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.username=rootspring.datasource.password=p123456 测试代码 123456789@Controllerpublic class UsersController &#123; @Autowired private DataSource dataSource; @GetMapping(\"/showInfo\") public String showInfo()&#123; return \"OK\"; &#125;&#125; 1.2.2.2、使用第三方的Druid数据源&emsp;&emsp;在application.properties配置文件中配置spring.datasource.type就可以更换数据源了。 12345spring.datasource.url=jdbc:mysql://localhost:3306/test?userUnicode=true&amp;characterEncoding=UTF-8&amp;userSSL=false&amp;serverTimezone=Asia/Shanghaispring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.username=rootspring.datasource.password=p123456spring.datasource.type=com.alibaba.druid.pool.DruidDataSource 1.3、实现添加用户功能1.3.1、创建POJO1234567891011121314151617181920212223public class Users &#123; private Integer userid; private String username; private String usersex; public Integer getUserid() &#123; return userid; &#125; public void setUserid(Integer userid) &#123; this.userid = userid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getUsersex() &#123; return usersex; &#125; public void setUsersex(String usersex) &#123; this.usersex = usersex; &#125;&#125; 1.3.2、创建页面1234567891011121314&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;from th:action=\"@&#123;/user/addUser&#125;\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"usersex\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"ok\"/&gt; &lt;/from&gt;&lt;/body&gt;&lt;/html&gt; 1.3.3、创建Controller PageController 1234567891011/** * 页面跳转Controller */@Controllerpublic class PageController &#123; //页面跳转方法 @RequestMapping(\"/&#123;page&#125;\") public String showPage(@PathVariable String page)&#123; return page; &#125;&#125; UserController 123456789101112131415161718192021@Controller@RequestMapping(\"/user\")public class UsersController &#123; @Autowired private UsersService usersService; @GetMapping(\"/showInfo\") public String showInfo()&#123; return \"OK\"; &#125; //添加用户 @PostMapping(\"/addUser\") public String addUser(Users users)&#123; try&#123; this.usersService.addUser(users); &#125;catch (Exception e)&#123; e.printStackTrace(); return \"error\"; &#125; return \"redirect:/ok\"; &#125;&#125; 1.3.4、创建Service123456789101112131415161718/** * 用户管理业务层 */@Servicepublic class UserServiceImpl implements UsersService &#123; @Autowired private UserDao userDao; /** * 添加用户 * @param users */ @Override @Transactional public void addUser(Users users) &#123; this.userDao.insertUsers(users); &#125;&#125; 1.3.5、创建Dao123456789101112131415161718/** * 用户管理持久层 */@Repositorypublic class UserDaoImpl implements UserDao &#123; @Autowired private JdbcTemplate jdbcTemplate; /** * 添加用户 * @param users */ @Override public void insertUsers(Users users) &#123; String sql = \"insert into user(username,usersex) values(?,?)\"; this.jdbcTemplate.update(sql,users.getUsername(),users.getUsersex()); &#125;&#125; 1.3.4、解决favicon.ico解析问题1&lt;link rel=\"shortcut icon\" href=\"../resource/favicon.ico\" th:href=\"@&#123;/static/favicon.ico&#125;\"/&gt; 1.4、实现查询全部用户功能1.4.1、修改Controller12345678910111213//查询用户@GetMapping(\"/showUser\")public String showUser(Model model)&#123; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); try&#123; list = this.usersService.showUsers(); &#125;catch (Exception e)&#123; e.printStackTrace(); return \"error\"; &#125; model.addAttribute(\"list\",list); return \"showUser\";&#125; 1.4.2、修改业务层123456789/** * 查询用户 * @return */@Override@Transactionalpublic List&lt;Users&gt; showUsers()&#123; return this.userDao.showUsers();&#125; 1.4.3、修改持久层使用RowMapper返回自定义对象。 12345678910111213141516171819/** * 查询用户 * @return */@Overridepublic List&lt;Users&gt; showUsers()&#123; String sql = \"select * from user\"; List&lt;Users&gt; users = this.jdbcTemplate.query(sql, new RowMapper&lt;Users&gt;() &#123; @Override public Users mapRow(ResultSet resultSet, int i) throws SQLException &#123; Users user = new Users(); user.setUsername(resultSet.getString(\"username\")); user.setUsersex(resultSet.getString(\"usersex\")); user.setUserid(resultSet.getInt(\"userid\")); return user; &#125; &#125;); return users;&#125; 1.4.4、创建用户更新页面1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" width=\"50%\" align=\"center\"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"u : $&#123;list&#125;\"&gt; &lt;td th:text=\"$&#123;u.userid&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;u.username&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;u.usersex&#125;\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a th:href=\"@&#123;/user/updateUser&#125;\"&gt;修改&lt;/a&gt; &lt;a th:href=\"@&#123;/user/deleteUser&#125;\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 1.5、实现用户更新功能1.5.1、预更新查询1.5.1.1、修改Controller123456789101112//预更新用户的查询@GetMapping(\"/preUpdateUser\")public String preUpdateUser(Integer id,Model model)&#123; try&#123; Users user = this.usersService.findUserById(id); model.addAttribute(\"user\",user); &#125;catch (Exception e)&#123; e.printStackTrace(); return \"error\"; &#125; return \"updateUser\";&#125; 1.5.1.2、修改业务层12345678/** * 用户预更新查询 */@Override@Transactionalpublic Users findUserById(int id)&#123; return this.userDao.selectUserById(id);&#125; 1.5.1.3、修改持久层1234567891011121314151617/** * 预更新用户查询 */public Users selectUserById(int id)&#123; Users user = new Users(); String sql = \"select * from user where userid = ?\"; Object[] arr = new Object[]&#123;id&#125;; this.jdbcTemplate.query(sql, arr,new RowCallbackHandler() &#123; @Override public void processRow(ResultSet resultSet) throws SQLException &#123; user.setUserid(resultSet.getInt(\"userid\")); user.setUsersex(resultSet.getString(\"usersex\")); user.setUsername(resultSet.getString(\"username\")); &#125; &#125;); return user;&#125; 1.5.1.4、创建用户更新页面123456789101112131415&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=\"@&#123;/user/updateUser&#125;\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"userid\" th:value=\"$&#123;user.userid&#125;\"/&gt; &lt;input type=\"text\" name=\"username\" th:value=\"$&#123;user.username&#125;\"/&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"usersex\" th:value=\"$&#123;user.usersex&#125;\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"修改\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1.5.2、更新用户1.5.2.1、修改Controller1234567891011//更新用户@PostMapping(\"/updateUser\")public String updateUser(Users user)&#123; try&#123; this.usersService.modifyUser(user); &#125;catch (Exception e)&#123; e.printStackTrace(); return \"error\"; &#125; return \"ok\";&#125; 1.5.2.2、修改业务层123456789/** * 用户更新 * @param user */@Override@Transactionalpublic void modifyUser(Users user)&#123; this.userDao.updateUser(user);&#125; 1.5.2.3、修改持久层1234567/** * 更新用户 */public void updateUser(Users user)&#123; String sql = \"update user set username = ?,usersex = ? where userid = ?\"; jdbcTemplate.update(sql,user.getUsername(),user.getUsersex(),user.getUserid());&#125; 1.5.3、删除用户1.5.3.1、修改Controller1234567891011//删除用户@GetMapping(\"/deleteUser\")public String deleteUser(Integer id)&#123; try&#123; this.usersService.dropUser(id); &#125;catch (Exception e)&#123; e.printStackTrace(); return \"error\"; &#125; return \"redirect:/ok\";&#125; 1.5.3.2、修改业务层1234567/** * 删除用户 */@Overridepublic void dropUser(Integer id)&#123; this.userDao.deleteUser(id);&#125; 1.5.3.3、修改持久层1234567/** * 删除用户 */public void deleteUser(Integer id)&#123; String sql = \"delete from user where userid = ?\"; jdbcTemplate.update(sql,id);&#125;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Spring Boot学习笔记(十) -整合Thymeleaf","date":"2020-04-07T12:47:54.960Z","path":"2020/04/07/Spring Boot学习笔记(十) -整合Thymeleaf/","text":"&emsp;&emsp;Thymeleaf的主要目标是将优雅的自然模板带到开发工作流程中，并将HTML在浏览器中正确显示，并且可以作为静态原型，让开发团队能更容易地协作。Thymeleaf能够处理HTML，XML，JavaScript，CSS甚至纯文本。&emsp;&emsp;长期以来，jsp在视图领域有非常重要的地位，随着时间的变迁，出现了以为新的挑战者：Thymeleaf，Thymeleaf是原生的，不依赖标签库，他能够在接收原始HTML的地方进行编译和渲染。因为它没有与Servlet规范耦合，因此Thymeleaf模板能进入jsp所无法涉足的领域。. 1、Thymeleaf基本使用1.1、创建项目 1.2、修改POM文件，添加Thymeleaf依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xiezhenyu&lt;/groupId&gt; &lt;artifactId&gt;springbootthymeleaf&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootthymeleaf&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加thymeleaf启动器依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 1.3、创建Controller1234567891011121314/** * 页面跳转Controller */@Controllerpublic class PageController &#123; /** * 页面跳转方法 */ @GetMapping(\"/show\") public String showPage(Model model)&#123; model.addAttribute(\"msg\",\"Hello Thymeleaf！\"); return \"index\"; &#125;&#125; 1.4、创建视图1234567891011&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;span th:text=\"谢振瑜\"&gt;&lt;/span&gt; &lt;hr/&gt; &lt;span th:text=\"$&#123;msg&#125;\"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 1.5、运行结果 2、Thymeleaf语法命名空间： xmlns:th=”http://www.thymeleaf.org&quot; 2.1、字符串与变量输出操作2.1.1、th:text作用：在页面中输出值。注意：如果标签中含有内容，它会被th:text标记的内容替换掉。 12&lt;span th:text=\"谢振瑜\"&gt;&lt;/span&gt;&lt;span th:text=\"$&#123;msg&#125;\"&gt;&lt;/span&gt; 2.1.2、th:value作用：可以将一个值放入到input标签的value中。 1&lt;input th:value=\"$&#123;msg&#125;\"/&gt; 2.2、字符串操作&emsp;&emsp;Thymeleaf提供了一些内置对象，内置对象可直接在模板中使用。这些对象是以#引用的。 2.2.1、使用内置对象的语法 引用内置对象需要使用 # 大部分内置对象的名称都以 s 结尾。如：strings、numbers、datas 1$&#123;#strings.isEmpty(key)&#125; 判断字符串是否为空，如果为空返回true，否则返回false。 1&lt;span th:text=\"$&#123;#strings.isEmpty(msg)&#125;\"&gt;&lt;/span&gt; 1$&#123;#strings.contains(msg,&apos;T&apos;)&#125; 判断字符串是否包含指定的子串，如果包含返回true，否则返回false。 1&lt;span th:text=\"$&#123;#strings.contains(msg,'T')&#125;\"&gt;&lt;/span&gt; 1$&#123;#strings.startWith(msg,&apos;a&apos;)&#125; 判断字符串是否以子串开头，如果是返回true，否则返回false。 1&lt;span th:text=\"$&#123;#strings.startWith(msg,'a')&#125;\"&gt;&lt;/span&gt; 1$&#123;#strings.endWith(msg,&apos;a&apos;)&#125; 判断字符串是否以子串结尾，如果是返回true，否则返回false。 1&lt;span th:text=\"$&#123;#strings.endWith(msg,'a')&#125;\"&gt;&lt;/span&gt; 1$&#123;#strings.length(msg)&#125; 返回字符串的长度。 1&lt;span th:text=\"$&#123;#strings.length(msg)&#125;\"&gt;&lt;/span&gt; 1$&#123;#strings.indexOf(msg,&apos;a&apos;)&#125; 查找子串的位置，并返回子串的下标，如果没有找到则返回-1。 1&lt;span th:text=\"$&#123;#strings.indexOf(msg,'a')&#125;\"&gt;&lt;/span&gt; 12$&#123;#strings.substring(msg,2)&#125;$&#123;#strings.substring(msg,2,5)&#125; 截取子串，用法与jdk String类下 SubString方法相同。 1&lt;span th:text=\"$&#123;#strings.substring(msg,2,5)&#125;\"&gt;&lt;/span&gt; 12$&#123;#strings.toUpperCase(msg)&#125;$&#123;#strings.toLowerCase(msg)&#125; 字符串大小写转换。 1&lt;span th:text=\"$&#123;#strings.toLowerCase(msg)&#125;\"&gt;&lt;/span&gt; 2.3、日期格式化处理1$&#123;#dates.format(key)&#125; 格式化日期，默认的以浏览器默认语言为格式标准。 1$&#123;#dates.format(key,&apos;yyy/MM/dd&apos;)&#125; 按自定义的格式做日期转换 123$&#123;#dates.yrear(key)&#125;$&#123;#dates.month(key)&#125;$&#123;#dates.day(key)&#125; year：取年 month：取月 day：取日 2.4、条件判断2.4.1、th:if作用：条件判断 12345678&lt;div&gt; &lt;span th:if=\"$&#123;sex&#125; == '男'\"&gt; 性别：男 &lt;/span&gt; &lt;span th:if=\"$&#123;sex&#125; == '女'\"&gt; 性别：女 &lt;/span&gt;&lt;/div&gt; 2.4.2、th:switch / th:case作用：&emsp;&emsp;th:switch / th:case 与 java 中的 switch 语句等效，有条件地显示匹配内容。如果有多个匹配结果只选择第一个显示。&emsp;&emsp;th:case=”*” 表示 Java 中 switch 的 default，即没有 case 的值为true时则显示th:case=”*”的内容。 12345678&lt;div th:switch=\"$&#123;id&#125;\"&gt; &lt;span th:case=\"1\"&gt;id：1&lt;/span&gt; &lt;span th:case=\"2\"&gt;id：2&lt;/span&gt; &lt;span th:case=\"3\"&gt;id：3&lt;/span&gt; &lt;span th:case=\"4\"&gt;id：4&lt;/span&gt; &lt;span th:case=\"5\"&gt;id：5&lt;/span&gt; &lt;span th:case=\"*\"&gt;id：*&lt;/span&gt;&lt;/div&gt; 2.5、迭代遍历2.5.1、th:each作用：迭代器，用于循环迭代集合。 123456789101112&lt;table border=\"1\" width=\"50%\"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;AGE&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"u : $&#123;list&#125;\"&gt; &lt;td th:text=\"$&#123;u.id&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;u.name&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;u.age&#125;\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 2.5.2、th:each 状态变化 index: 当前迭代器的索引 从0开始 count: 当前迭代器对象的计数 从1开始 size: 被迭代器对象的长度 odd/even: 布尔值，当前循环是否是奇数/偶数 从0开始 first: 布尔值，当前循环的是否是第一条，如果是返回true否则返回false last: 布尔值，当前循环是否是最后一条，如果是返回true否则返回false1234567891011121314151617181920212223242526&lt;table border=\"1\" width=\"50%\"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;AGE&lt;/th&gt; &lt;th&gt;Index&lt;/th&gt; &lt;th&gt;Count&lt;/th&gt; &lt;th&gt;Size&lt;/th&gt; &lt;th&gt;Odd&lt;/th&gt; &lt;th&gt;Even&lt;/th&gt; &lt;th&gt;First&lt;/th&gt; &lt;th&gt;Last&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"u,suibian : $&#123;list&#125;\"&gt; &lt;td th:text=\"$&#123;u.id&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;u.name&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;u.age&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;suibian.index&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;suibian.count&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;suibian.size&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;suibian.odd&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;suibian.even&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;suibian.first&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;suibian.last&#125;\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 结果： 2.6、th:each 迭代 Map1234567891011121314&lt;table border=\"1\" width=\"50%\"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;AGE&lt;/th&gt; &lt;th&gt;Key&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"m : $&#123;map&#125;\"&gt; &lt;td th:text=\"$&#123;m.value.id&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;m.value.name&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;m.value.age&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;m.key&#125;\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 2.7、操作域对象HttpServletRequestHttpSessionServletContext 123request.setAttribute(\"req\",\"HttpServletRequest\");request.getSession().setAttribute(\"ses\",\"HttpSession\");request.getSession().getServletContext().setAttribute(\"app\",\"application\"); 123456HttpServletRequest方式一:&lt;span th:text=\"$&#123;#request.getAttribute('req')&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;HttpServletRequest方式二:&lt;span th:text=\"$&#123;#httpServletRequest.getAttribute('req')&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;HttpSession方式一:&lt;span th:text=\"$&#123;#session.getAttribute('ses')&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;HttpSession方式二:&lt;span th:text=\"$&#123;session.ses&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;Application方式一::&lt;span th:text=\"$&#123;#session.getServletContext().getAttribute('app')&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;Application方式二:&lt;span th:text=\"$&#123;application.app&#125;\"&gt;&lt;/span&gt; 2.8、URL表达式2.8.1、语法在Thymeleaf中URL表达式的语法格式为@{} 2.8.2、URL类型 绝对路径 1&lt;a th:href=\"@&#123;http://baidu.com&#125;\"&gt;绝对路径&lt;/a&gt; 相对路径 1234&lt;!--相当于当前项目的根--&gt;&lt;a th:href=\"@&#123;/show&#125;\"&gt;相对路径&lt;/a&gt;&lt;!--相当于服务器路径的根--&gt;&lt;a th:href=\"@&#123;~/project2/resourcename&#125;\"&gt;相对于服务器的根&lt;/a&gt; 2.8.3、在URL中传递参数 在普通格式的URL中传递参数 1234&lt;a th:href=\"@&#123;/show?id=1&amp;name=zhansan&#125;\"&gt;普通URL格式传参&lt;/a&gt;&lt;a th:href=\"@&#123;/show(id=1,name=zhansan)&#125;\"&gt;普通URL格式传参&lt;/a&gt;&lt;a th:href=\"@&#123;/'show?id=' + $&#123;id&#125; + '&amp;name=' + $&#123;name&#125;&#125;\"&gt;普通URL格式传参&lt;/a&gt;&lt;a th:href=\"@&#123;/show(id=$&#123;id&#125;,name=$&#123;name&#125;)&#125;\"&gt;普通URL格式传参&lt;/a&gt; 在restful格式的URL中传递参数 1234&lt;a th:href=\"@&#123;/show/&#123;id&#125;(id=1)&#125;\"&gt;restful格式传参&lt;/a&gt;&lt;a th:href=\"@&#123;/show/&#123;id&#125;/&#123;name&#125;(id=1,name=admin)&#125;\"&gt;restful格式传参&lt;/a&gt;&lt;a th:href=\"@&#123;/show/&#123;id&#125;(id=1,name=admin)&#125;\"&gt;restful格式传参&lt;/a&gt;&lt;a th:href=\"@&#123;/show/&#123;id&#125;(id=$&#123;id&#125;,name=$&#123;name&#125;)&#125;\"&gt;restful格式传参&lt;/a&gt; 2.9、在配置文件中配置Thymeleaf123456789101112#默认路径spring.thymeleaf.prefix=classpath:/templates/suibian/#默认扩展名spring.thymeleaf.suffix=.html#配置视图模板类型，HTML4、HTML5,(如果视图模板使用的html5则需要配置)spring.thymeleaf.mode=HTML#配置thymeleaf引擎的编码spring.thymeleaf.encoding=UTF-8#配置相应类型spring.thymeleaf.servlet.content-type=text/html#配置thymeleaf的页面缓存，true为缓存，false为不缓存spring.thymeleaf.cache=false","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Spring Boot学习笔记(六) -整合Web层技术","date":"2020-04-07T12:02:11.979Z","path":"2020/04/07/Spring Boot学习笔记(六) -整合Web层技术/","text":"1、整合Servlet方式一1.1、通过注解扫描完成Servlet组件的注册&emsp;&emsp;在启动类中添加@ServletComponentScan注解，SpirngBoot启动时会扫描@WebServlet和@WebListener以及@WebFilter注解。 1.2、创建Servlet1234567891011package com.xiezhenyu.springbootweb.servlet;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = \"FirstServlet\",urlPatterns = \"/first\")public class FirstServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; System.out.println(\"First Servlet......\"); &#125;&#125; 1.3、修改启动类&emsp;&emsp;在启动类中添加@ServletComponentScan注解，作用是在SpirngBoot启动时会扫描@WebServlet和@WebListener以及@WebFilter注解，并将该类实例化。 1234567@SpringBootApplication@ServletComponentScan//在SpirngBoot启动时会扫描@WebServlet和@WebFilter注解，并将该类实例化public class SpringbootwebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootwebApplication.class, args); &#125;&#125; 2、整合Servlet方式22.1、通过方法完成Servlet组件的注册&emsp;&emsp;通过创建方法的方式完成Servlet组件的注册。 2.2、创建Servlet12345678/** * 整合servlet方式2 */public class SecondServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response)&#123; System.out.println(\"Second Servlet......\"); &#125;&#125; 2.3、创建Servlet配置类&emsp;&emsp;Servlet配置类可以直接在启动类中配置，因为启动类中@SpringBootApplication注解也包含了@Configuration注解。也可以新建一个类中添加@Configuration注解。 1234567891011121314151617181920package com.xiezhenyu.springbootweb.config;import com.xiezhenyu.springbootweb.servlet.SecondServlet;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/***Servlet注册类*/@Configurationpublic class ServletConfig &#123; /** * 完成servlet组件的注册 */ @Bean public ServletRegistrationBean getServletRegistrationBean()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new SecondServlet()); bean.addUrlMappings(\"/second\"); return bean; &#125;&#125; 3、整合Filter方式一3.1、通过注解扫描完成Filter组件注册&emsp;&emsp;在启动类中添加@ServletComponentScan注解，SpirngBoot启动时会扫描@WebFilter和@WebListener以及@WebServlet注解。 3.2、创建Filter1234567891011121314151617181920212223package com.xiezhenyu.springbootweb.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;/** *整合Filter方式一 *///@WebFilter(filterName = \"FirstFiltet\",urlPatterns = &#123;\"*.do\",\"*.jsp\"&#125;)@WebFilter(filterName = \"FirstFiltet\",urlPatterns = \"/first\")public class FirstFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"进入First Filter。。。。。。\"); filterChain.doFilter(servletRequest,servletResponse); System.out.println(\"离开First Filter。。。。。。\"); &#125; @Override public void destroy() &#123; &#125;&#125; 3.3、修改启动类&emsp;&emsp;在启动类中添加@ServletComponentScan注解会自动扫描@WebFilter注解和@WebListener以及@WebServlet注解。 1234567@SpringBootApplication@ServletComponentScan//在SpirngBoot启动时会扫描@WebServlet注解，并将该类实例化public class SpringbootwebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootwebApplication.class, args); &#125;&#125; 4、整合Filter方式二4.1、通过方法完成Filter组件注册&emsp;&emsp;通过创建方法的方式完成Filter组件的注册。 4.2、创建Filter1234567891011121314151617181920package com.xiezhenyu.springbootweb.filter;import javax.servlet.*;import java.io.IOException;/** * 整合Filter方式二 */public class SecondFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"进入Seond Filter。。。。。。\"); filterChain.doFilter(servletRequest,servletResponse); System.out.println(\"离开Second Filter。。。。。。\"); &#125; @Override public void destroy() &#123; &#125;&#125; 4.3、创建Filter配置类&emsp;&emsp;Filter配置类可以直接在启动类中配置，因为启动类中@SpringBootApplication注解也包含了@Configuration注解。也可以新建一个类中添加@Configuration注解。 123456789101112131415161718package com.xiezhenyu.springbootweb.config;import com.xiezhenyu.springbootweb.filter.SecondFilter;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Filter配置类 */@Configurationpublic class FilterConfig &#123; @Bean public FilterRegistrationBean getFilterRegistrationBean()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(new SecondFilter()); //bean.addUrlPatterns(new String[]&#123;\"*.do\",\"*.jsp\"&#125;); bean.addUrlPatterns(\"/second\"); return bean; &#125;&#125; 5、整合Listener方式一5.1、通过注解扫描完成Listener组件注册&emsp;&emsp;在启动类中添加@ServletComponentScan注解，SpirngBoot启动时会扫描@WebServlet和@WebListener以及@WebFilter注解。 5.2、编写Listener123456789101112131415package com.xiezhenyu.springbootweb.listener;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;/** * 整合Listener方式一 */@WebListenerpublic class FirstListener implements ServletContextListener &#123; public void contextDestroyed(ServletContextEvent event)&#123; &#125; public void contextInitialized(ServletContextEvent event)&#123; System.out.println(\"Listener..init...\"); &#125;&#125; 5.3、修改启动类&emsp;&emsp;Listener配置类可以直接在启动类中配置，因为启动类中@SpringBootApplication注解也包含了@Configuration注解。也可以新建一个类中添加@Configuration注解。 1234567@SpringBootApplication@ServletComponentScan//在SpirngBoot启动时会扫描@WebServlet注解，并将该类实例化public class SpringbootwebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootwebApplication.class, args); &#125;&#125; 6、整合Listener方式二6.1、通过方法完成Listener组件注册&emsp;&emsp;通过创建方法的方式完成Listener组件的注册。 6.2、编写Listener12345678910111213package com.xiezhenyu.springbootweb.listener;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;/** * 整合Listener方式二 */public class SecondListener implements ServletContextListener &#123; public void contextDestroyed(ServletContextEvent event)&#123; &#125; public void contextInitialized(ServletContextEvent event)&#123; System.out.println(\"Listener..init...\"); &#125;&#125; 6.3、创建Listener配置类&emsp;&emsp;Listener配置类可以直接在启动类中配置，因为启动类中@SpringBootApplication注解也包含了@Configuration注解。也可以新建一个类中添加@Configuration注解。 1234567891011/** * listener配置类 */@Configurationpublic class ListenerConfig &#123; @Bean public ServletListenerRegistrationBean getServletListenerRegistrationBean()&#123; ServletListenerRegistrationBean bean = new ServletListenerRegistrationBean(new SecondListener()); return bean; &#125;&#125;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Spring Boot学习笔记(九) -整合视图层技术","date":"2020-04-07T07:29:59.746Z","path":"2020/04/07/Spring Boot学习笔记(九) -整合视图层技术/","text":"1、Spring Boot 整合JSP技术&emsp;&emsp;在Spring Boot中不推荐使用JSP，但是支持使用。 1.1、创建项目 1.2、修改POM文件，添加JSP引擎与JSTL标签库JSP引擎：JSP是在tomcat中编译运行的，处理这个环节的就是JSP引擎。在SpringBoot内嵌的tomcat中并没有JSP引擎，所以要添加JSP引擎的依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xiezhenyu&lt;/groupId&gt; &lt;artifactId&gt;springbootjsp&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootjsp&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加jsp引擎,Spring Boot 内置的tomcat中，没有此依赖。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加JSTL坐标依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 1.3、创建webapp目录 1.4、标记为web目录&emsp;&emsp;经过这个操作后就可以把webapp标记为web目录，可以方便的在这个目录中创建jsp等文件。 1.5、创建JSP注意：webapp/WEB-INF是安全的，不能直接访问，必须通过Controller做跳转。 1.6、修改配置文件，配置视图解析器12spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp 1.7、创建Controller1234567891011121314151617package com.xiezhenyu.springbootjsp.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;/** * 页面跳转Controller */@Controllerpublic class PageController &#123; /** * 页面跳转方法 */ @GetMapping(\"/&#123;page&#125;\") public String showPage(@PathVariable String page)&#123; return page; &#125;&#125; &emsp;&emsp;如果在IDEA中项目结构为聚合工程，那么在运行jsp时，需要指定路径。如果项目结构为独立项目，则不需要。 1.8、运行 2、Spring Boot 整合 Freemarker2.1、创建项目 2.2、修改POM文件，添加Freemarker启动器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xiezhenyu&lt;/groupId&gt; &lt;artifactId&gt;springbootfreemarker&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootfreemarker&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- freemarker启动器依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.3、创建Users实体12345678910111213141516171819202122232425262728293031package com.xiezhenyu.springbootfreemarker.pojo;public class Users &#123; private String username; private String usersex; private String userage; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getUsersex() &#123; return usersex; &#125; public void setUsersex(String usersex) &#123; this.usersex = usersex; &#125; public String getUserage() &#123; return userage; &#125; public void setUserage(String userage) &#123; this.userage = userage; &#125; public Users(String username, String usersex, String userage) &#123; this.username = username; this.usersex = usersex; this.userage = userage; &#125; public Users() &#123; &#125;&#125; 2.4、创建Controller123456789101112131415161718/** * UsersController */@Controllerpublic class UsersController &#123; /** * 处理请求，返回数据 */ @GetMapping(\"/showUsers\") public String showUsers(Model model) &#123; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(new Users(\"admin\",\"F\",\"32\")); list.add(new Users(\"zhangshang\",\"M\",\"23\")); list.add(new Users(\"lisi\",\"M\",\"18\")); model.addAttribute(\"list\",list); return \"usersList\"; &#125;&#125; 2.5、创建视图1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" align=\"center\" width=\"50%\"&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Sex&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;#list list as user&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.usersex&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.userage&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 2.6、修改配置文件在application.properties中配置freemarker的拓展名 1spring.freemarker.suffix=.ftl 2.7、运行结果","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Spring Boot学习笔记(八) -文件上传","date":"2020-04-06T12:53:01.021Z","path":"2020/04/06/Spring Boot学习笔记(八) -文件上传/","text":"1、创建项目 2、POM文件123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xiezhenyu&lt;/groupId&gt; &lt;artifactId&gt;springbootfileupload&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootfileupload&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3、启动类123456789package com.xiezhenyu.springbootfileupload;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringbootfileuploadApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootfileuploadApplication.class, args); &#125;&#125; 4、编写上传页面12345678910&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/fileUploadController\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file\"/&gt; &lt;input type=\"submit\" value=\"okok\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 5、编写Controller注意：在文件上传方法中，参数的名字必须和html中的name相同。 1234567891011121314151617package com.xiezhenyu.springbootfileupload.controller;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;import java.io.File;@RestControllerpublic class FileUploadController &#123; /** * 文件上传 */ @PostMapping(\"/fileUploadController\") public String fileUpload(MultipartFile file) throws Exception&#123; System.out.println(file.getOriginalFilename()); file.transferTo(new File(\"d:/\"+file.getOriginalFilename())); return \"yes\"; &#125;&#125; 6、修改上传文件大小默认上传的大小为1M一下，要使上传大小变化必须修改application.properties配置文件。 1234#配置单个上传文件的大小限制spring.servlet.multipart.max-file-size=2MB#配置一次请求（批量）上传文件的总大小spring.servlet.multipart.max-request-size=20MB","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Spring Boot学习笔记(七) -访问静态资源","date":"2020-04-06T12:14:22.648Z","path":"2020/04/06/Spring Boot学习笔记(七) -访问静态资源/","text":"&emsp;&emsp;在SpringBoot项目中没有我们之前常规web开发的WebContent(WebApp)，它只有src目录。在src/main/resource下面有两个文件夹，static和template。SpringBoot默认在static目录中存放静态页面，而templates中放动态页面。 1、static目录&emsp;&emsp;Spring Boot 通过 classpath/static 目录访问静态资源。注意存放静态资源的目录名称必须是static。) 2、templates目录&emsp;&emsp;在Spring Boot中不推荐使用jsp作为视图层技术，而是默认使用Thymeleaf来做动态页面。Templates目录这是存放Thymeleaf的页面。 3、静态资源存放其他位置3.1、Spring Boot 访问静态资源的位置classpath:/META - INF/resources/calsspath:/resources/classpath:/static/classpath:/public/&emsp;&emsp;这里的classpath指的是resource这个跟目录，扫描的顺序为上面的从上到下，如下图所示： 3.2、自定义静态资源位置&emsp;&emsp;在根目录下创建目录suibian。&emsp;&emsp;在application.properties中设置。 1spring.resources.static-locations=classpath:/suibian/","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Spring Boot学习笔记(五) -Controller中常用注解","date":"2020-04-06T06:44:18.945Z","path":"2020/04/06/Spring Boot学习笔记(五) -Controller中常用注解/","text":"@RestController&emsp;&emsp;@RestController相当于@Controller+@ResponseBody注解&emsp;&emsp;如果使用@RestController注解Controller中的方法无法返回页面，相当于在方法上面自动加了@RespinseBody注解，所以没办法跳转并传输数据到另一个页面，所以InternalResourceViewResolver也不起作用，返回的内容就是Return里的内容。 @GetMapping&emsp;&emsp;@GetMapping注解是@RequestMapping(method = RequestMethod.GET)的缩写。 @PostMapping&emsp;&emsp;@PostMapping注解是@RequestMapping(method = RequestMethod.POST)的缩写。 @PutMapping&emsp;&emsp;@PutMapping注解是@RequestMapping(method = RequestMethod.PUT)的缩写。 @DeleteMapping&emsp;&emsp;@DeleteMapping注解是@RequestMapping(method = RequestMethod.DELETE)的缩写。 案例12345678910111213141516171819202122232425262728package com.xiezhenyu.controller;import org.springframework.web.bind.annotation.*;/** * 处理请求Controller */@RestControllerpublic class HelloWorldController &#123; @RequestMapping(\"/HelloWorld\") public String ShowHelloWorld()&#123; return \"HelloWorld\"; &#125; @GetMapping(\"/HelloWorld2\") public String ShowHelloWorld2()&#123; return \"HelloWorld2\"; &#125; @PostMapping(\"/HelloWorld3\") public String ShowHelloWorld3()&#123; return \"HelloWorld3\"; &#125; @PutMapping(\"/HelloWorld4\") public String ShowHelloWorld4()&#123; return \"HelloWorld4\"; &#125; @DeleteMapping(\"/HelloWorld5\") public String ShowHelloWorld5()&#123; return \"HelloWorld5\"; &#125;&#125;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Spring Boot学习笔记(四) -编写HelloWorld","date":"2020-04-06T06:29:43.951Z","path":"2020/04/06/Spring Boot学习笔记(四) -编写HelloWorld/","text":"创建项目 创建一个空项目 创建模块))))编写POM文件12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xiezhenyu&lt;/groupId&gt; &lt;artifactId&gt;springboothellowrold2&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 继承 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- 依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 插件 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 修改Tomacat端口12server: port: 8888 创建启动类123456789101112package com.xiezhenyu;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 启动类 */@SpringBootApplicationpublic class SpringBootHelloWorld2Application &#123; public static void main(String[] args)&#123; SpringApplication.run(SpringBootHelloWorld2Application.class,args); &#125;&#125; 创建Controller12345678910111213package com.xiezhenyu.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * 处理请求Controller */@RestController //@Controller+@ResponsBody的复合体,加了这个之后，下面的所有操作都不进行页面跳转，直接返回json串（字符串）等。public class HelloWorldController &#123; @RequestMapping(\"/HelloWorld\") public String ShowHelloWorld()&#123; return \"HelloWorld\"; &#125;&#125; 运行结果","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Spring Boot学习笔记(三) -Spring Boot 项目结构","date":"2020-04-05T11:09:38.399Z","path":"2020/04/05/Spring Boot学习笔记(三) -Spring Boot 项目结构/","text":"1、POM文件1.1、继承123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; &emsp;&emsp;Spring Boot 的父类依赖，只有继承它项目才是Spring Boot 项目。&emsp;&emsp;spring-boot-starter-parent 是一个特殊的starter，它用来提供相关的Maven默认依赖。使用它之后，常用的包依赖可以省去version标签。 1.2、依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; &emsp;&emsp;启动器依赖 1.3、插件12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; &emsp;&emsp;spring-boot-maven-plugin插件是将spring boot 的应用程序打包成jar包的插件。将所有应用启动运行所需要的jar包都包含进来，逻辑上将具备了独立运行的条件。当运行“mvnpackage”进行打包后，使用“java -jar”命令就可以直接运行。 2、启动类&emsp;&emsp;Spring Boot 的启动类的作用是启动Spring Boot项目，是基于Main方法运行的。&emsp;&emsp;注意：启动类在启动时会做注解扫描（@Controller、@Service、@Repository……），扫描位置为同包或者子包下的注释，所以启动类的位置应放于包的根下。 2.1、启动类于启动器的区别 启动类表示项目的启动入口 启动器表示jar包的坐标2.2、创建启动类12345678910111213package com.xiezhenyu;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * Spring Boot 的启动类 * 启动类必须添加@SpringBootApplication注解 */@SpringBootApplicationpublic class SpringBootDemo3Application &#123; public static void main(String[] args)&#123; SpringApplication.run(SpringBootDemo3Application.class,args); &#125;&#125; 3、启动器&emsp;&emsp;Spring Boot将所有的功能场景都抽取出来，做成一个个的starter（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来，要用扫描功能就导入扫描场景，在jar包管理上非常方便，最终实现一站式开发。 &emsp;&emsp;Spring Boot 提供了多达44个启动器。 &emsp;&emsp;spring-boot-starter&emsp;&emsp;这是Spring Boot的核心启动器，包含了自动配置、日志和YAML。 &emsp;&emsp;spring-boot-starter-actuator&emsp;&emsp;帮助监控和管理应用。 &emsp;&emsp;spring-boot-starter-web&emsp;&emsp;支持全栈式Web开发，包括Tomcat和spring-webmvc。 &emsp;&emsp;spring-boot-starter-amqp&emsp;&emsp;通过spring-rabbit来支持AMQP协议（Advanced Message Queuing Protocol） &emsp;&emsp;spring-boot-starter-aop&emsp;&emsp;支持面向切面编程即AOP，包含spring-aop和AspectJ。 &emsp;&emsp;spring-boot-starter-artemis&emsp;&emsp;通过Apache Artemis 支持JMS的API（Java Message Service API）。 &emsp;&emsp;spring-boot-starter-batch&emsp;&emsp;支持Spring Batch，包含HSQLDB数据库。 &emsp;&emsp;spring-boot-starter-cache&emsp;&emsp;支持Spring的Cache抽象 &emsp;&emsp;spring-boot-starter-cloud-connectors&emsp;&emsp;支持Spring Cloud Connectors，简化了在像Cloud Foundry 或 Heroku 这样的云平台上连接服务。 &emsp;&emsp;spring-boot-starter-data-elasticsearch&emsp;&emsp;支持ElasticSearch搜索和分析引擎，包含spring-data-elasticsearch。 &emsp;&emsp;spring-boot-starter-data-gemfire&emsp;&emsp;支持GemFire分布式数据存储，包含spring-data-gemfire。 &emsp;&emsp;spring-boot-starter-data-jpa&emsp;&emsp;支持JPA（Java Persistence API），包括spring-data-jpa、spring-orm、Hibernate。 等等。。。。 4、配置文件&emsp;&emsp;Spring Boot 提供一个名称为application的全局配置文件，支持两种properties格式于YAML格式。 4.1、Peoperties格式配置Tomcat监听端口 1server.port=8888 4.2、YAML格式YAML格式配置文件的拓展名可以是yaml或者yml。 4.2.1基本格式要求 大小写敏感 使用缩进代表层级关系 相同的部分只能出现一次 配置Tomcat监听端口 123server: port: 8888 host: 4.3、配置文件存放位置 当前项目根目录中 当前项目根目录下的一个/config子目录 项目的resource即classpath根路径中 项目的resource即classpath根路径下的/config目录中4.4、配置文件加载顺序4.4.1、不同格式的加载顺序&emsp;&emsp;如果同一个目录下，有application.yml也有application.properties,默认先读取application.properties。&emsp;&emsp;如果同一个配置属性，在多个配置文件都配置了，默认使用第一个读取到的，后面读取的不覆盖前面读取到的。4.4.2、 不同位置的加载顺序4.4.2.1、当前项目根目录下的一个/config子目录中（最高）config/application.propertiesconfig/application.yml4.4.2.2、当前项目根目录中（其次）application.propertiesapplication.yml4.4.2.3、项目的resources即classpath根路径下的/config目录中（一般）‘resources/config/application.propertiesresources/config/application.yml4.4.2.4、项目的resources即classpath根路径中（最后）resources/application.propertiesresources/application.yml4.5、配置文件中的占位符4.5.1、占位符语法语法：${ }4.5.2、占位符作用 “${ }”中可以获取框架中提供的方法中的值如：random.int等。 占位符可以获取配置文件中的键的值赋给另一个键作为值。4.5.3、生成随机数${random.value} - 类似uuid的随机数，没有”-“连接${random.int} - 随机取整型范围内的一个值${random.long} - 随机取长整型范围内的一个值${random.long(100,200)} - 随机生成长整型100-200范围内的一个值${random.uuid} - 生成一个uuid，有短杠连接${random.int(10)} - 随机生成一个10以内的数${random.int(100,200)} - 随机生成一个100-200范围以内的数 4.6、bootstrap配置文件4.6.1、bootstrap配置文件介绍&emsp;&emsp;Spring Boot 中有两种上下文对象，一种是bootstrap，另一种是application，bootstrap是应用程序的夫上下文，也就是说bootstrap加载优先于application。bootstrap主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。 4.6.2、bootstrap配置文件特征 bootstrap由父ApplicationContext加载，比application优先加载。 bootstrap里面的属性不能被覆盖。4.6.3、bootstrap与application的应用场景application 配置文件主要用于Spring Boot 项目的自动化配置。bootstrap 配置文件由一下几个应用场景。 使用Spring Cloud Config 配置中心时，这时需要在bootstrap配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息。 一些固定的不能被覆盖的属性。 一些加密/解密的场景。 5、Spring Boot 的核心注解5.1、@SpringBootApplication是SpringBoot的启动类。此注解等同于@Configuration+@EnableAutoConfiguration+@ComponentScan的组合。 5.2、@SpringBootConfiguration&emsp;&emsp;@SpringBootConfiguration注解是@Configuration注解的派生注解，跟@Configuration注解的功能一致，标注这个类是一个配置类，只不过@SpringBootConfiguration是springboot的注解，而@Configuration是spring的注解。 5.3、@Configuration通过对bean对象的操作代替spring中xml文件 5.4、@EnableAutoConfiguration&emsp;&emsp;Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。是@AutoConfigurationPackage和@Import(AutoConfigurationImportSelector.class)注解的组合。 5.5、AutoConfigurationPackage&emsp;&emsp;@AutoConfigurationPackage注解，自动注入主类下所在包下所有的加了注解的类（@Controller、@Service等），以及配置类（@Configuration） 5.6、@Import({AutoConfigurationImportSelect.class})直接导入普通类导入实现ImportSelect接口的类导入事项ImportBeanDefinitionRegistrar接口的类 5.7、@ComponentScan主键扫描，可自动发现和装配一些Bean。 5.8、@ConfigurationPropertiesScan@ConfigurationPropertiesScan扫描配置属性。@EnableConfigurationProperties注解的作用是使用@ConfigurationProperties注解的类失效。","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Spring Boot学习笔记(二) -创建基于Spring Boot的项目","date":"2020-04-05T08:29:27.455Z","path":"2020/04/05/Spring Boot学习笔记(二) -创建基于Spring Boot的项目/","text":"通过官网创建项目)将项目下载将项目导入idea) 通过IDEA的脚手架工具创建项目 通过IDEA的Maven创建项目修改pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xiezhenyu&lt;/groupId&gt; &lt;artifactId&gt;springbootdemo3&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 继承父包 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring-boot的web启动的jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--maven的插件 springboot打包插件 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Spring Boot学习笔记(一) -Spring Boot介绍","date":"2020-04-05T06:07:30.330Z","path":"2020/04/05/Spring Boot学习笔记(一) -Spring Boot介绍/","text":"&emsp;&emsp;Spring Boot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需要的大量且繁琐的配置文件，所以Spring Boot是一个服务于框架的框架，服务范围是简化配置文件。所以从本质上来说，Spring Boot其实就是Spring框架的另一种表现形式。 Spring Boot 特征 使用Spring Boot 可以创建独立的Spring应用程序； 在Spring Boot 中直接嵌入了Tomcat、Jetty、Undertow等Web容器，所以在使用Spring Boot 做web开发时不需要部署WAR文件； 通过提供自己的启动器（Starter）依赖，简化项目构建配置； 尽量的自动配置Spring和第三方库； 提供了生产就绪特征，如：度量指标，运行状态检查和外部化配置； 绝对没有代码生成，也不需要配置XML配置文件。 版本介绍SNAPSHOT：快照版，即开发版；CURRENT：最新版，但是不一定是稳定版；GA：正式发布版。","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Vue学习笔记(四)-vue-resource以及品牌列表案例","date":"2020-03-03T10:59:19.039Z","path":"2020/03/03/Vue学习笔记(四)-vue-resource以及品牌列表案例/","text":"vue-resource是一个通过XMLHttpRequrest或JSONP技术实现异步加载服务端数据的Vue插件。提供了一般的 HTTP请求接口和RESTful架构请求接口，并且提供了全局方法和VUe组件实例方法。在Vue.js 2.0+ 版本推荐使用 axios 来完成 ajax 请求。参考文献 https://www.runoob.com/vue2/vuejs-ajax.html Get请求123456789101112131415161718window.onload = function()&#123; var vm = new Vue(&#123; el:'#box', data:&#123; msg:'Hello World!', &#125;, methods:&#123; get:function()&#123; //发送get请求 this.$http.get('http://www.liulongbin.top:3005/api/getprodlist').then(function(res)&#123; document.write(res.body); &#125;,function()&#123; console.log('请求失败处理'); &#125;); &#125; &#125; &#125;);&#125; 如果需要传递数据，可以使用 this.$http.get(‘get.php’,{params : jsonData}) 格式，第二个参数 jsonData 就是传到后端的数据。 12345this.$http.get('http://www.liulongbin.top:3005/api/getprodlist',&#123;params : &#123;a:1,b:2&#125;&#125;).then(function(res)&#123; document.write(res.body); &#125;,function(res)&#123; console.log(res.status);&#125;); post请求post 发送数据到后端，需要第三个参数 {emulateJSON:true}。emulateJSON 的作用： 如果Web服务器无法处理编码为 application/json 的请求，你可以启用 emulateJSON 选项。 12345678910111213141516171819window.onload = function()&#123; var vm = new Vue(&#123; el:'#box', data:&#123; msg:'Hello World!', &#125;, methods:&#123; post:function()&#123; //发送 post 请求 this.$http.post('http://www.liulongbin.top:3005/api/getprodlist',&#123;name:\"谢振瑜\",url:\"xiezhenyu98.github.io\"&#125;,&#123;emulateJSON:true&#125;).then(function(res)&#123; document.write(res.body); &#125;,function(res)&#123; console.log(res.status); &#125;); &#125; &#125; &#125;);&#125; 语法 &amp; API使用全局对象方式 Vue.http 或者在一个 Vue 实例的内部使用 this.$http来发起 HTTP 请求。 1234567// 基于全局Vue对象使用httpVue.http.get('/someUrl', [options]).then(successCallback, errorCallback);Vue.http.post('/someUrl', [body], [options]).then(successCallback, errorCallback);// 在一个Vue实例内使用$httpthis.$http.get('/someUrl', [options]).then(successCallback, errorCallback);this.$http.post('/someUrl', [body], [options]).then(successCallback, errorCallback); vue-resource 提供了 7 种请求 API(REST 风格)： 1234567get(url, [options])head(url, [options])delete(url, [options])jsonp(url, [options])post(url, [body], [options])put(url, [body], [options])patch(url, [body], [options]) 除了 jsonp 以外，另外 6 种的 API 名称是标准的 HTTP 方法。options 参数说明:通过如下属性和方法处理一个请求获取到的响应对象： 使用 vue-resource 的 jsonp 处理跨域请求1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"app\"&gt; 请输入关键字：&lt;input type=\"text\" v-model=\"keyword\" @keyup=\"sendJsonP(keyword)\"&gt; &lt;ul&gt; &lt;li v-for=\"r in result\"&gt;&#123;&#123;r&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;window.onload = function () &#123; new Vue(&#123; el: '#app', data: &#123; keyword: '', result: '' &#125;, methods: &#123; sendJsonP(keyword) &#123; let url = 'https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web'; this.$http.jsonp(url, &#123; params: &#123; wd: keyword &#125;, jsonp: 'cb'//jsonp默认是callback,百度缩写成了cb，所以需要指定下 &#125; &#125;).then(res =&gt; &#123; if (res.data.g) &#123; this.result = res.data.g.map(x =&gt; x['q']); &#125; else &#123; this.result = []; &#125; &#125;); &#125; &#125; &#125;);&#125;&lt;/script&gt; 品牌列表案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.staticfile.org/vue-resource/1.5.1/vue-resource.min.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"./lib/bootstrap.min.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body form-inline\"&gt; &lt;label&gt; Name: &lt;input type=\"text\" v-model=\"name\" class=\"form-control\"&gt; &lt;/label&gt; &lt;input type=\"button\" value=\"添加\" @click=\"add\" class=\"btn btn-primary\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=\"table table-bordered table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"item in list\" :key=\"item.id\"&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.ctime &#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; // 如果我们通过全局配置了，请求数据的接口 根域名，则，每次单独发起 http 请求的时候，请求的url路径，应该以相对路径开头，前面不能带 / ，否则不会启用根路径做拼接。 Vue.http.options.root = 'http://www.liulongbin.top:3005'; // 全局启用 emulateJSON 选项 Vue.http.options.emulateJSON = true; var vm = new Vue(&#123; el:'#app', data:&#123; name:'', list:[ //存放所有品牌列表的数组 &#123;id:1, name:'五菱宏', ctime:new Date()&#125;, &#123;id:2, name:'众泰', ctime:new Date()&#125; ] &#125;, created()&#123; //当 vm 实例的 data 和 method 初始化完毕后，vm实例会自动执行created this.getAllList(); &#125;, methods:&#123; add()&#123;//添加品牌列表到后台服务器 // 分析： // 1、经过查看 数据API接口，发现，要发送一个Post请求，this.$http.post // 2、this.$http.post() 中接收三个参数 // 2.1、第一个参数：要请求的url地址 // 2.2、第二个参数：要提交给服务器的数据，要以对象形式提交给服务器 &#123; name:this.name &#125; // 2.3、第三个参数：是一个配置对象，要以哪种表单数据类型提交过去 &#123;emulateJson:true&#125; 以普通表单格式，将数据提交给服务器 application/x-www-form-urlencoded // 3、在post方法中，使用 .then 来设置成功的回调函数，如果想要成功的结果，需要 result.body // this.$http.post('api/addproduct', &#123;name:this.name&#125;,&#123;emulateJSON:true&#125;).then(result =&gt; &#123; // if(result.body.status === 0)&#123; // //成功了 // alert(result.body.message); // //添加完成后，只需要手动再调用一下getAllList() 就能刷新品牌列表 // this.getAllList(); // &#125;else&#123; // alert(\"添加失败！\"); // &#125; // &#125;) this.$http.post('api/addproduct', &#123;name:this.name&#125;).then(result =&gt; &#123; if(result.body.status === 0)&#123; //成功了 alert(result.body.message); //添加完成后，只需要手动再调用一下getAllList() 就能刷新品牌列表 this.getAllList(); &#125;else&#123; alert(\"添加失败！\"); &#125; &#125;) &#125;, getAllList()&#123;//获取所有品牌列表 // 分析： // 1、由于已经导入了vue-resource这个包，所以，可以直接通过this.$http 来发起数据请求 // 2、根据接口文档，知道，获取列表的时候，应该发起一个get请求 // 3、this.$http.get('url').then(function(result)&#123;&#125;) // 4、当通过 then 指定回调函数之后，在回调函数中，可以拿到数据服务器返回的 result // 5、先判断 result.status 是否等于0，如果等于0，就成功了，可以把 result.message 赋值给this.list;如果不等于0，可以弹框提示，获取数据失败！ this.$http.get('api/getprodlist').then(result=&gt;&#123; //注意：通过 $http 获取到的数据，都在 result.body 中放着 var result = result.body; if(result.status === 0)&#123; // 成功了 this.list = result.message; &#125;else&#123; //失败了 alert('获取数据失败'); &#125; &#125;) // http://www.liulongbin.top:3005/ &#125;, del(id)&#123;//删除品牌列表 this.$http.get('api/delproduct/'+id).then(result =&gt; &#123; if(result.body.status === 0)&#123; //删除成功 this.getAllList(); alert(\"删除成功！\"); &#125;else&#123; alert(\"删除失败！\"); &#125; &#125;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://Xiezhenyu98.github.io/tags/Vue/"}]},{"title":"Vue学习笔记(三)-过滤器、按键修饰符、自定义指令、生命周期","date":"2020-03-02T14:43:13.589Z","path":"2020/03/02/Vue学习笔记(三)-过滤器、按键修饰符、自定义指令、生命周期/","text":"品牌列表案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"./lib/bootstrap.min.css\"&gt; &lt;!-- 需要用到Jquery吗？ --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body form-inline\"&gt; &lt;label&gt; Id: &lt;input type=\"text\" class=\"form-control\" v-model=\"id\"&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=\"text\" class=\"form-control\" v-model=\"name\"&gt; &lt;/label&gt; &lt;!-- 在Vue中，使用事件绑定机制，为元素指定处理函数的时候，如果加了小括号，就可以给函数传参了 --&gt; &lt;input type=\"button\" value=\"添加\" class=\"btn btn-primary\" @click=\"add()\"&gt; &lt;label&gt; 搜索名称关键字: &lt;input type=\"text\" class=\"form-control\" v-model=\"keywords\"&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=\"table table-bordered table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Opration&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 之前，v-for中的数据，都是从data上的list中直接渲染过来的 --&gt; &lt;!-- 现在，我们自定义了一个search方法，同时，把所有关键字，通过传参的形式，传递给了search方法 --&gt; &lt;!-- 先search方法内部通过执行for循环，把所有符合搜索关键字的数据，保存到一个新数组中，返回 --&gt; &lt;tr v-for=\"item in search(keywords)\" :key=\"item.id\"&gt; &lt;td&gt; &#123;&#123; item.id &#125;&#125; &lt;/td&gt; &lt;td v-text=\"item.name\"&gt;&lt;/td&gt; &lt;td&gt; &#123;&#123; item.ctime &#125;&#125; &lt;/td&gt; &lt;td&gt;&lt;a href=\"\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; id:'', name:'', keywords:'', list: [ &#123;id:1, name:'奔驰', ctime:new Date()&#125;, &#123;id:2, name:'宝马', ctime:new Date()&#125; ] &#125;, methods:&#123; add()&#123; //分析： //1、获取id和name,直接从 data 上面获取 //2、组织出一个对象 //3、把这个对象，调用数组的相关方法，添加到当前 data 上的 list 中 //4、注意：在Vue中，已经实现了数据的双向绑定，每当完美修改了 打他、 中的数据，Vue会默认监听到数据的改动，自动把最新的数据，应用到页面上； //5、当我们意识到上面的第四步的时候，就证明大家已经入门Vue了，我们更多的是在进行 VM 中Model数据的操作，同时，在操作Model数据的时候，指定的业务逻辑操作； var car = &#123;id:this.id, name:this.name, ctime:new Date()&#125;; this.list.push(car); this.id = this.name = ''; &#125;, del(id)&#123;//根据id删除数据 //分析： //1、如何根据ID，找到要删除这一项的索引 //2、如果找到索引了，直接调用数组的splice方法 this.list.some((item,i)=&gt;&#123; if(item.id == id)&#123; this.list.splice(i,1); //在数组的some方法中，如果return true ，就会立即终止这个数组的后续循环 return true; &#125; &#125;) &#125;, search(keywords)&#123;//根据关键字进行数据的搜索 /*var newList =[]; this.list.forEach(item=&gt;&#123; if(item.name.indexOf(keywords) != -1)&#123; newList.push(item); &#125; &#125;) return newList;*/ //注意：forEach some filter findIndex 这些都属于数组的新方法 都会对数组中的每一项进行遍历 然后执行相关的操作 return this.list.filter(item=&gt;&#123; // if(item.name.indexOf(keywords) != -1) //注意：在ES6中，为字符串提供了一个新方法，叫做String.prototype.include('要包含的字符串')，如果包含，则返回true，否则返回false if(item.name.includes(keywords))&#123; return item; &#125; &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 过滤器Vue.js运行自定义过滤器，可悲用作一些常见的文本格式化。过滤器可以在两个地方使用：mustache插值和 v-bind 表达式。过滤器应该被添加在JavaScript的尾部，由“管道”符指示： html元素 12&lt;!-- 过滤器调用时候的格式 &#123;&#123; name | 过滤器名称 &#125;&#125; --&gt;&lt;td&gt;&#123;&#123; item.ctime | dataFormat('yyyy-m-dd') &#125;&#125;&lt;/td&gt; 私有过滤器 12345678910111213141516171819&lt;div id=\"app2\"&gt; &lt;!-- 过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一致了，这时候优先调用私有过滤器 --&gt; &lt;p&gt;&#123;&#123; msg | msgFormat &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; //如何定义一个私有过滤器 var vm2 = new Vue(&#123; el:'#app2', data:&#123; msg:'谁是这个世界上最单纯的男人，单纯的我~~' &#125;, filters:&#123; // 定义私有过滤器 过滤器有两个条件 [ 过滤器名称 和 处理函数 ] msgFormat:function(msg,partten)&#123; return msg.replace(/单纯/g,'大方---'); &#125; &#125; &#125;)&lt;/script&gt; 全局过滤器 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; msg | msgFormat &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; msg | msgFormat2('疯狂+1') &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; //定义一个Vue 全局的过滤器，名字叫 msgFormat Vue.filter('msgFormat',function(msg)&#123; // 字符串的 replace 方法，第一个参数，除了可以写一个字符串之外，还可以定义一个正则 return msg.replace(/单纯/g,'邪恶'); &#125;) Vue.filter('msgFormat2',function(msg,arg)&#123; // 字符串的 replace 方法，第一个参数，除了可以写一个字符串之外，还可以定义一个正则 return msg.replace(/单纯/g,arg); &#125;) var vm = new Vue(&#123; el:'#app', data:&#123; msg:'谁是这个世界上最单纯的男人，单纯的我~~' &#125; &#125;);&lt;/script&gt; 注意：当有局部和全局两个名称相同的过滤器的时候，会采用就近原则调用，即：局部过滤器优先于全局过滤器被调用！ 按键修饰符以及自定义键盘修饰符在监听键盘事件时，我们如果需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： 12&lt;!-- 当按键enter弹起时才调用submit函数 --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt; 其中.enter是 Vue 提供的常见按键码别名，除此之外还有： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 除了 Vue 提供的常见按键别名，如果要使用其他的按键则可以 .按键码 （点击查看详细按键码）的方式： 12&lt;!-- 使用.按键码 --&gt;&lt;input v-on:keyup.113=\"submit\"&gt; 除了直接使用键盘码之外，还可以给键盘码起一个别名方便使用： 1234&lt;script&gt;//其中f2是别名，113是键盘码Vue.config.keyCode.f2 = 113&lt;/script&gt; 自定义指令 全局自定义指令使用 Vue.directive() 定义全局指令；其中：参数1：指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v- 前缀在调用的时候，必须在指令前 加上 v- 前缀；参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以特定的阶段，执行相关的操作； 12345678910111213141516&lt;script&gt;Vue.directive('focus',&#123; //bind inserted update 是钩子函数 bind: function(el)&#123;//每当指令绑定到元素上的时候，会执行这个bind函数，只执行一次 //注意：在每个元素中，第一个参数，永远是el，表示被绑定了指令的那个元素，这个el参数，是一个原生的js对象 //在元素刚绑定了指令的时候，还没有插入到DOM中去，这个时候，调用foucs方法没有用 //因为，一个元素，只有插入DOM之后，才能获取焦点 el.focus();//这个方法不会起作用 &#125;, inserted: function(el)&#123;//表示元素插入到DOM中的时候会执行inserted函数 el.focus(); &#125;, update: function()&#123;//当VNode更新的时候，会执行update，可能会触发多次 &#125;&#125;)&lt;/script&gt; 自定义私有指令 123456789101112&lt;script&gt; var vm = new Vue(&#123; el:'#app', dirctives:&#123;//自定义私有指令 'fontweight':&#123; bind: function(el,binding)&#123; el.style.fontWeight = binding.value; &#125; &#125; &#125; &#125;)&lt;/script&gt; 自定义指令函数的简写在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。 12345&lt;script&gt;Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;)&lt;/script&gt; 钩子函数和钩子函数的属性一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 Vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 主要生命周期函数分类 创建期间的生命周期函数： beforeCreate：实例刚再内存中被创建出来，此时，还没有初始化好 data 和 methods 属性； created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始编译模板； beforMount：此时已经完成了模板的编译，但是还没有挂载到网页中； mounted：此时，已经将编译好的模板，挂载到了网页的指定容器中显示； 运行期间的生命周期函数： beforUpdate：状态更新之前执行此函数，此时 data 中的状态值还是最新的，但是界面上显示的数据还是旧的，因此此时还没有开始渲染DOM节点； update：实例更新完毕之后调用此函数，此时 data 中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了； 销毁期间的生命周期： beforDestroy：实例销毁之前调用。在这一步，实例仍然完全可用； destroyed：Vue实例销毁后调用。调用后，Vue实例显示的所有东西都会解绑定，所有事件监听器会被移除，所有子实例也会被销毁。 过程图：","tags":[{"name":"Vue","slug":"Vue","permalink":"https://Xiezhenyu98.github.io/tags/Vue/"}]},{"title":"Vue学习笔记(二)-Vue指令的学习","date":"2020-03-01T15:45:25.470Z","path":"2020/03/01/Vue学习笔记(二)-Vue指令的学习/","text":"插值表达式正常情况我们在页面取值都是通过 来取值 123&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678&lt;script&gt; new Vue(&#123; el:'#app', data:&#123; msg:'123' &#125; &#125;)&lt;/script&gt; 页面显示效果 Vue指令之v-cloak在使用插值表达式的时候，如果将项目发布到服务器上，出现网速慢的情况，浏览器不能及时接收到vue.js，这个时候会出现闪烁现象，即这个符号会出现在网页上，等到浏览器接收完数据后，才会将替换成真正的数据。如下图：解决这个问题，可以使用v-cloak指令解决： 12345&lt;style&gt; [v-cloak]&#123; display: none; &#125;&lt;/style&gt; 123&lt;div id=\"app\"&gt; &lt;p v-cloak&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678&lt;script&gt; new Vue(&#123; el:'#app', data:&#123; msg:'123' &#125; &#125;)&lt;/script&gt; Vue指令之v-text和v-html v-text：默认v-text没有闪烁问题， 于插值表达式不同的是v-text会覆盖元素中原本的内容，而插值表达式只会替换自己的占位符，不会把整个元素的内容清空。 v-html：于v-text不同的是，v-html会识别输出html标签，而v-text会将内容完整的输出不识别标签。12345&lt;div id=\"app\"&gt; &lt;div v-cloak&gt;&#123;&#123; msg2 &#125;&#125;&lt;/div&gt; &lt;div v-text=\"msg2\"&gt;&lt;/div&gt; &lt;div v-html=\"msg2\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678&lt;script&gt; new Vue(&#123; el:'#app', data:&#123; msg2:'&lt;h1&gt;我是一个h1&lt;/h1&gt;' &#125; &#125;)&lt;/script&gt; 效果如下图： Vue指令之v-bind v-bind 是一个vue中提供的用于绑定属性的指令 v-bing: 指令可以被简写为 :要绑定的属性 v-bind 中，可以写合法的表达式1234&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"按钮1\" v-bind:title=\"mytitle + '123'\"&gt; &lt;input type=\"button\" value=\"按钮2\" :title=\"mytitle + '123'\"&gt;&lt;/div&gt; 12345678&lt;script&gt; new Vue(&#123; el:'#app', data:&#123; mytitle:'这是自己定义的一个title' &#125; &#125;)&lt;/script&gt; 效果图下图： Vue指令之v-on和事件修饰符Vue中提供了v-on:事件绑定机制，缩写为@ 1234&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"按钮\" v-on:click=\"show\"&gt; &lt;input type=\"button\" value=\"按钮\" @click=\"show\"&gt;&lt;/div&gt; 12345678910&lt;script&gt; new Vue(&#123; el:'#app', methods:&#123; //这个methods属性中定义了当前Vue实例中所有可用的方法 show: function()&#123; alert('Hello'); &#125; &#125; &#125;)&lt;/script&gt; 效果如下图：事件修饰符 .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件监听器的使用事件捕获模式 .self 只当前事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 .stop和.self的区别是：.self只会阻止自己身上的冒泡行为并不会真正的阻止冒泡行为的触发。示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue.js\"&gt;&lt;/script&gt; &lt;style&gt; .inner&#123; height: 150px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 使用.stop阻止冒泡 --&gt; &lt;!-- &lt;div class=\"inner\" @click=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click.stop=\"btnHandler\"&gt; &lt;/div&gt; --&gt; &lt;!-- 使用 .prevent 阻止默认行为 --&gt; &lt;!-- &lt;a href=\"http://www.baidu.com\" @click.prevent=\"linkClick\"&gt;有问题，先去百度&lt;/a&gt; --&gt; &lt;!-- 使用 .capture 实现捕获触发的机制 --&gt; &lt;!-- &lt;div class=\"inner\" @click.capture=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click=\"btnHandler\"&gt; &lt;/div&gt; --&gt; &lt;!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 --&gt; &lt;!-- &lt;div class=\"inner\" @click.self=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click=\"btnHandler\"&gt; &lt;/div&gt; --&gt; &lt;!-- 使用 .once 只触发一次事件处理函数 --&gt; &lt;a href=\"http://www.baidu.com\" @click.prevent.once=\"linkClick\"&gt;有问题，先去百度&lt;/a&gt; &lt;!-- .self 只会阻止自己身上冒泡行为的触发，并不会真正阻止冒泡行为 --&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; &#125;, methods:&#123; div1Handler()&#123; console.log('这是触发了 inner div 的点击事件') &#125;, btnHandler()&#123; console.log('这是出发了 button 的点击事件') &#125;, linkClick()&#123; console.log('这是触发了连接的点击事件') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 跑马灯效果实现分析： 给开启跑马灯效果的按钮绑定一个时间 v-on或@ 在按钮的时间处理函数中，写相关的业务逻辑代码：拿到msg字符串，然后调用字符串的substring来进行字符串的截取操作，把第一个字符串截取下来，放到最后一个位置即可； 为了实现点击一下按钮，自动截取的功能，需要把上一个步骤的代码，放到一个定时器中去；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1.导入Vue包 --&gt; &lt;script src=\"./lib/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 2.创建一个要控制的区域 --&gt; &lt;div id=\"app\"&gt; &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt; &lt;input type=\"button\" value=\"浪起来\" @click=\"lang\"&gt; &lt;input type=\"button\" value=\"低调\" @click=\"stop\"&gt; &lt;/div&gt; &lt;script&gt; //注意在vm实例中，如果想要获取data上的数据，或者想要调用methods中的方法，必须通过this.数据属性名或者this.方法名进行访问，这里的this就表示我们new出来的vm实例对象 var vm = new Vue(&#123; el:'#app', data:&#123; msg:'猥琐发育，别浪~~~~！', intervalId:null //在data上定义一个定时器id &#125;, methods:&#123; lang()&#123; if(this.intervalId!=null)return; this.intervalId = setInterval(()=&gt;&#123; //获取到头的第一个字符 var start = this.msg.substring(0,1); //获取到后面的所有字符 var end = this.msg.substring(1); //重新拼接得到新的字符串并赋值给this.msg this.msg = end + start; //注意：vm实例，会监听自己身上data中所有数据的改变，只要数据一发生变化，就会自动把最新的数据，从data上同步到页面 &#125;,400) &#125;, stop()&#123; clearInterval(this.intervalId); //每当清除了intervalId之后重新赋值null this.intervalId=null; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue指令之v-model和双向数据绑定 v-bind 只能实现数据的单向数据绑定，从 M 自动绑定到 V，无法实现数据的双向绑定 使用 v-model 指令，可以实现表单元素和Model中数据的双向数据绑定 注意：v-model 只能运用在表单元素中使用示例代码：1234567891011121314&lt;div id=\"app\"&gt; &lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt; &lt;input type=\"text\" v-model=\"msg\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg:'大家都是好孩子，爱敲代码，爱学习，爱思考，简直是完美，没瑕疵！' &#125;, methods:&#123; &#125; &#125;);&lt;/script&gt; 效果： 简易计算器案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"n1\"&gt; &lt;select v-model=\"opt\"&gt; &lt;option value=\"+\"&gt;+&lt;/option&gt; &lt;option value=\"-\"&gt;-&lt;/option&gt; &lt;option value=\"*\"&gt;*&lt;/option&gt; &lt;option value=\"/\"&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type=\"text\" v-model=\"n2\"&gt; &lt;input type=\"button\" value=\"=\" @click=\"calc\"&gt; &lt;input type=\"text\" v-model=\"result\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; n1: 0, n2: 0, result: 0, opt: '+' &#125;, methods:&#123; calc()&#123; //计算器算数的方法 //逻辑： switch(this.opt)&#123; case '+': this.result = parseInt(this.n1) + parseInt(this.n2); break; case '-': this.result = parseInt(this.n1) - parseInt(this.n2); break; case '*': this.result = parseInt(this.n1) * parseInt(this.n2); break; case '/': this.result = parseInt(this.n1) / parseInt(this.n2); break; &#125; // var cadeStr = 'parseInt(this.n1)' + this.opt + 'parseInt(this.n2)' // this.result = eval(cadeStr); &#125; &#125; &#125;);&lt;/script&gt; 在Vue中使用样式使用class样式 数组 1&lt;h1 :class=\"['red','thin']\"&gt;这是一个H1标签&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class=\"['red','thin'],isactive?'active':''\"&gt;这是一个H1标签&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class=\"['red','thin'],&#123;'active':isactive&#125;\"&gt;这是一个H1标签&lt;/h1&gt; 直接使用对象 1&lt;h1 :class=\"&#123;red:true,italic:true,active:true,thin:true&#125;\"&gt;这是一个H1标签&lt;/h1&gt; 样例代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;style&gt; .red&#123; color:red; &#125; .thin&#123; font-weight: 200; &#125; .italic&#123; font-style: italic; &#125; .active&#123; letter-spacing: 0.5em; &#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;!-- &lt;h1 class=\"red thin\"&gt;这是一个很大很大的一个H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 第一种使用方式，直接传递一个数组，注意：这里的class需要用 v-bind做数据绑定 --&gt; &lt;!-- &lt;h1 :class=\"['thin','italic']\"&gt;这是一个很大很大的一个H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 在数组中使用三元表达式 --&gt; &lt;!-- &lt;h1 :class=\"['thin','italic',flag?'active':'']\"&gt;这是一个很大很大的一个H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 在数组中使用对象来代替三元表达式，来提高代码的可读性 --&gt; &lt;!-- &lt;h1 :class=\"['thin','italic',&#123;'active':flag&#125;]\"&gt;这是一个很大很大的一个H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 在为 class 使用 v-bind 绑定对象的时候，对象的属性是类名，由于对象的属性可带引号,也可以不带引号；属性的值是一个标识符 --&gt; &lt;h1 :class=\"calssObj\"&gt;这是一个很大很大的一个H1，大到你无法想象！！！&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; flag:true, calssObj:&#123;'red':true,'thin':true,active:true,italic:true&#125; &#125;, methods:&#123; &#125; &#125;);&lt;/script&gt; 使用内联样式 直接在元素上通过 :style 的样式，书写样式对象 1&lt;h1 :style=\"&#123;color:'red','font-size':'40px'&#125;\"&gt;这是一个H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 123456//在data上的定义样式data:&#123; h1StyleObj:&#123;color:'red','font-size':'40px','font-weight':'200'&#125;&#125;//在元素中，通过属性绑定的样式，将样式对象应用到元素中&lt;h1 :style=\"h1StyleObj\"&gt;这是一个H1&lt;/h1&gt; 在 :style中通过数组，引用多个 data 上的样式对象 1234567//在data上定义样式data&#123; h1StyleObj:&#123;color:'red',''font-size':'40px','font-weight':'200'&#125;, h1StyleObj2:&#123;font-style:'italic'&#125;&#125;//在元素中，通过属性绑定的形式，将样式对象应用到元素中&lt;h1 :style=\"[h1StyleObj,h1StyleObj2]\"&gt;这是一个H1&lt;/h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for=\"(item,i) in list\"&gt;索引：&#123;&#123; i &#125;&#125; --- 姓名：&#123;&#123; item.name &#125;&#125; ---年龄：&#123;&#123; item.age &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 12&lt;!-- 遍历对象身上的属性 --&gt;&lt;div v-for=\"(val,key,i) in userInfo\"&gt;&#123;&#123; val &#125;&#125; --- &#123;&#123; key &#125;&#125; --- &#123;&#123; i &#125;&#125;&lt;/div&gt; 迭代数字 1&lt;p v-for=\"i in 10\"&gt;这是第&#123;&#123; i &#125;&#125;个p标签&lt;/p&gt; ** 2.2.0+的版本里，当在组件中使用v-for时，key现在是必须的。**当vue.js用v-for正在更新以渲染过的元素列表时，它默认用“就她复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染的每个元素。为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每一项提供一个唯一key属性。 Vue指令之v-if和v-show一般来说，v-if有更高的切换消耗而v-show有更高的渲染消耗，因此，如果需要频繁切换v-show较好，如果运行时条件不大可能改变v-if较好。 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"toggle\" @click=\"flag=!flag\"&gt; &lt;!-- v-if 的特点：每次都会重新删除或创建元素 --&gt; &lt;!-- v-show 的特点：每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 --&gt; &lt;!-- v-if 有较高的切换性能消耗 --&gt; &lt;!-- v-show 有较高的初始渲染消耗 --&gt; &lt;!-- 如果元素涉及到频繁的切换，最好不要使用 v-if ，推荐使用v-show --&gt; &lt;!-- 如果元素可能永远不会被显示出来被用户看到，则推荐使用v-if --&gt; &lt;h3 v-if=\"flag\"&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-show=\"flag\"&gt;这是用v-show控制的元素&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; flag:true &#125;, methods:&#123; &#125; &#125;);&lt;/script&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://Xiezhenyu98.github.io/tags/Vue/"}]},{"title":"Vue学习笔记-什么是Vue.js","date":"2020-03-01T06:47:21.390Z","path":"2020/03/01/Vue学习笔记-什么是Vue.js/","text":"什么是Vue.js? Vue(读音/vju:/,类似于view)，是一个轻量级的MVVM前端框架； 中文官网：https://cn.vuejs.org/ 作者：尤雨溪（Evan You） Vue.js是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机app，Vue语法也可以进行手机app开发的，需要借助于Weex） Vue.js是前端的主流框架之一，和Angular.js、React.js一起，并成前端三大主流框架！ Vue.js是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于于第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；Vue的优势 亲便、高效：20kB min+gzip 运行大小； 灵活：在一个库和完整框架之间自由选择； 易学：完善的中文社区、简单易懂的API，具备基本前端知识（HTML、CSS、JavaScript）即可开始学习； 数据双向绑定：简化DOM操作； 数据驱动：保证数据和视图的一致性； 组件化：将重复的结构、样式、逻辑封装成组件，方便复用，从而课组成大型应用； 第三方支持；支持很多优秀的三方库； 注意： Vue不支持IE8一下版本；*为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱，在企业中使用框架，能够提高开发效率； 提高开发效率的历程：原生JS-&gt;Jquery之类的类库-&gt;前端模板引擎-&gt;Angular.js/Vue.js（能够帮助我们减少不必要的DOM操作，提高渲染效率；双向数据绑定概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新构建整个项目。 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其他库实现需求。 使用Vue.js 获取Vue.js库· https://cn.vuejs.org/v2/guide/installation.html· 手动下载；23183829· 直接使用npm命令；· 直接引用；Vue的基本代码123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1.导入Vue的包 --&gt; &lt;script src=\"./lib/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 将来new的Vue实例，会控制这个元素中的所有内容 --&gt; &lt;!-- Vue实例控制的这个元素区域，就是我们的V --&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; //2.创建一个Vue的实例 //当我们导入包之后，在浏览器中，就多了一个Vue构造函数 //注意：我们new出来的这个VM对象，就是我们MVVM中的VM调度者 var vm = new Vue(&#123; el: '#app',//表示当前我们new的这个实例，要控制页面上的哪个区域 //这里的data就是MVVM里面的M，专门用来保存每个页面的数据的 data: &#123; //data属性中，存放的是el中要用到的数据 msg: '欢迎学习Vue'//通过Vue提供的指令，很方便的就能把数据渲染到页面上，程序员不再动手操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://Xiezhenyu98.github.io/tags/Vue/"}]},{"title":"数据结构和算法-时间复杂度","date":"2019-12-06T08:03:58.271Z","path":"2019/12/06/数据结构和算法-时间复杂度/","text":"&emsp;&emsp;在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。 算法的时间复杂度度量一个程序（算法）执行时间的两种方式[1]事后统计的方法&emsp;&emsp;这种方法可行，但是有两个问题：一是要想对设计的算法的运行性能进行测评，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件环境因素，这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。[2]事前估计的方法通过分析某个算法的时间复杂度来判断算法更优。 时间频度&emsp;&emsp;一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，他花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 时间频度的一些规则[1]可以忽略常数项，例如2n+10和2n随着n变大，执行曲线无限接近，可以忽略常数。[2]可以忽略低次项，例如2n^2^+3n+10和2n^2^随着n变大，执行曲线无限接近，可以忽略3n+10。[3]可以忽略系数，例如5n^2^+7n和3n^2^+2n，执行曲线随着n变大重合，说明这种情况下，5和3可以忽略。 时间复杂度计算[1]一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个赋值函数f(n)，是的当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。[2]T(n)不同，但时间复杂度可能相同。如：T(n)=n^2^+7n+6与T(n)=3n^2^+2n+2它们的T(n)不同，但时间复杂度相同，都为O(n^2^)。[3]计算时间复杂度的方法：用常数1代替运行时间中的所有加法常数。T(n)=3n^2^+7n+6 =&gt; T(n)=3n^2^+7n+1修改后的运行次数函数中，只保留最高阶项。T(n)=3n^2^+7n+1 =&gt; T(n)=3n^2^去除最高阶项的系数。T(n)=3n^2^ =&gt; T(n)=n^2^ =&gt; O(n^2^) 常见的时间复杂度[1]常数阶 O(1)[2]对数阶 O(log2n)[3]线性阶 O(n)[4]线性对数阶 O(nlog2n)[5]平方阶 O(n^2^)[6]立方阶 O(n^3^)[7]k次方阶 O(n^k^)[8]指数阶 O(2^n^)说明：&emsp;&emsp;常见的算法时间复杂度由小到大依次为:O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2^)&lt;O(n^3^)&lt;O(n^k^)&lt;O(2^n^)，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。&emsp;&emsp;从图中可见，我们应该尽可能避免指数阶的算法。 常见时间复杂度举例说明 常数阶O(1)无论执行了多少行代码，只要是没有循环等复杂结构，这个代码的时间复杂度都是O(1)。12345int i = 1;int j = 2;++i;j++;int m = i+j; 上述代码在执行的时候，她消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。 对数阶O(log2n)1234int i =1;while(i&lt;n)&#123; i = i * 2;&#125; 说明：在while循环里面，每次都将i乘以2，乘完之后，i距离n就越来越近了。假设循环x之后，i就大于n了，此时这个循环就退出了，也就是说2的x次方等于2，那么x = log2n也就是说当循环log2n次后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)。O(log2n)的这个2实际上是根据代码变化的，i = i * 3，则是O(log3n)。 线性阶O(n)1234for(int i=1;i&lt;=n;i++)&#123; j = i; j++;&#125; 说明：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。 线性对数阶O(nlog2n)123456for(int i=1;i&lt;n;i++)&#123; m = 1; while(m&lt;n)&#123; m = m*2; &#125;&#125; 说明：线性对数阶O(nlog2n)其实非常容易理解，将时间复杂度为O(log2n)的代码循环N遍的话，那么它的时间复杂度就是n*O(log2n)，也就是O(nlog2n)。 平方阶O(n^2^)123456for(int x = 1;x&lt;=n;x++)&#123; for(int i = 1;i&lt;=n;i++)&#123; j = 1; j++; &#125;&#125; 说明：平方阶O(n^2^)就更容易理解了，如果把O(n)的代码再嵌套循环一遍，它的时间复杂度就是O(n^2^)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是O(nn)，即O(n^2^)如果将其中一层循环的n改成m，那么它的时间复杂度就变成了O(mn)。 立方阶 O(n^3^)、k次方阶 O(n^k^)这个可以参考上面的平方阶O(n^2^)去理解，O(n^3^)相当于三层n循环，其它类似。 平均时间复杂度和最坏时间复杂度[1]平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。[2]最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法再任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。[3]平均时间复杂度和最坏时间复杂度是否一致，和算法有关（如下图）。 算法的空间时间复杂度[1]类似于时间复杂度的讨论，一个算法的空间复杂度（Space Complexity）定义为该算法所耗费的存储空间，它也是我问题规模n的函数。[2]空间复杂度（Space Complexity）是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数于解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。[3]在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的是程序执行的速度。一些缓存产品（redis，memcache）和算法（基数排序）本质就是用空间换时间。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-递归","date":"2019-11-29T07:49:27.294Z","path":"2019/11/29/数据结构和算法-递归/","text":"递归的概念：&emsp;&emsp;简单的说，递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。 递归的调用机制递归调用的规则[1]当程序执行到一个方法时，就会开辟一个独立的空间（栈）。[2]每个空间的数据(局部变量)，是独立的。用一个案例，理解递归机制。 1234567891011public class RecursionTest &#123; public static void main(String[] args) &#123; test(3); &#125; public static void test(int n)&#123; if(n&gt;2)&#123; test(n-1); &#125; System.out.println(\"n=\"+n); &#125;&#125; 上面这个程序的过程分析其在控制台的输出为则为n=2n=3 递归能解决什么样的问题[1]各种数学问题：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题。[2]各种算法中也会使用到递归，比如快速排序，归并排序，二分查找，分治算法等。[3]将用栈解决的问题–&gt;递归代码比较简洁。 递归需要遵守的重要规则[1]执行一个方法时，就创建一个新的受保护的独立空间（栈空间）。[2]方法的局部变量是独立的，不会相互影响。[3]但是如果方法中使用的是引用类型的变量(比如说是数组)，就会共享该引用类型的数据。[4]递归必须向退出的条件逼近，否则就是无限递归，会出现StackOverflowError(栈溢出)异常。[5]当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。 递归-迷宫问题说明：[1]小球得到的路径，和程序员设置的找路策略有关即：找路的上下左右顺序相关。[2]再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变[3]测试回溯现象。[4]思考：如何得到最短路径？(把所有的策略走的路径算出来，比较最短路径)代码实现上面的走迷宫问题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class MiGong &#123; public static void main(String[] args) &#123; //先创建一个二位数组，模拟迷宫 //地图 int[][] map = new int[8][7]; //使用1表示墙 //上下全部置为1 for(int i = 0;i&lt;7;i++)&#123; map[0][i]=1;map[7][i]=1; &#125; //左右全部置为1 for(int i = 0;i&lt;8;i++)&#123; map[i][0]=1;map[i][6]=1; &#125; //设置挡板 map[3][1]=1;map[3][2]=1; //输出地图 System.out.println(\"地图情况\"); for(int i = 0;i&lt;8;i++)&#123; for(int j=0;j&lt;7;j++)&#123; System.out.print(map[i][j]+\" \"); &#125; System.out.println(); &#125; //使用递归回溯给小球找路 setWay(map, 1, 1); //输出新的地图，小球走过，并标识过的地图 System.out.println(\"小球走过并标识的地图\"); for(int i = 0;i&lt;8;i++)&#123; for(int j=0;j&lt;7;j++)&#123; System.out.print(map[i][j]+\" \"); &#125; System.out.println(); &#125; &#125; //使用递归回溯来给小球找路 //说明 //1、map表示地图 //2、i，j表示从地图哪个为止开始出发（1，1） //3、如果小球能到达map[6][5]位置，则说明通路找到 //4、约定：当map[i][j]为0表示该点没有走过，当为1表示墙，2表示通路可以走，3表示该为止已经走过，但是走不通 //5、在走迷宫时，必须先确定一个策略（方法）：下-&gt;右-&gt;上-&gt;左，如果该点走不通，再回溯 /** * @param map 表示地图 * @param i 从那个位置开始找 * @param j 从那个位置开始找 * @return 如果找到通路，则返回true，否则返回false */ public static boolean setWay(int[][] map,int i,int j)&#123; if(map[6][5] == 2)&#123;//通路已经找到 return true; &#125;else&#123; if(map[i][j] == 0)&#123;//如果当前这个点没有走过 //按照策略 下-&gt;右-&gt;上-&gt;左 走 map[i][j] = 2;//假定该点是能走通的 if(setWay(map, i+1, j))&#123;//向下走 return true; &#125;else if(setWay(map, i, j+1))&#123;//向右走 return true; &#125;else if(setWay(map, i-1, j))&#123;//向上走 return true; &#125;else if(setWay(map, i, j-1))&#123;//向左走 return true; &#125;else&#123; map[i][j] = 3;//该点走过了，根本走不通 &#125; &#125;else &#123;//如果map[i][j]!=0，可能是1 ，2，3 return false; &#125; &#125; return false; &#125;&#125; 递归-八皇后问题（回溯算法）八皇后问题：&emsp;&emsp;八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8*8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行，同一列或同一斜线上，问有多少种摆法。八皇后问题算法思路分析：[1]第一个皇后先放在第一行第一列[2]第二个皇后放在第二行第一列、然后判断是否ok，如果不ok，继续放在第二列，第三列，依次把所有列都放完，找到一个合适的。[3]继续第三个皇后，还是第一列，第二列…直到第八个皇后也能放在一个不冲突的位置，算是找到了一个正确解释。[4]当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到。[5]然后回头继续第一个皇后放在第二列，后面继续循环执行1，2，3的步骤。说明：理论上应该创建一个二维数组来表示棋盘，但实际上可以通过算法，用一个一维数组即可解决问题。arr[8]={0,4,7,5,2,6,1,3}//对应arr下标表示第几行，即第几个皇后，arr[i]=val 表示第i+1个皇后，方法第i+1行的val+1列。八皇后的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Queue8 &#123; //定义一个max表示共有多少个皇后 int max = 8; //定义一个数组array，保存皇后放置位置的结果，比如array = &#123;0,4,7,5,2,6,1,3&#125; int[] array = new int[max]; static int count = 0; public static void main(String[] args) &#123; Queue8 queue8 = new Queue8(); queue8.check(0); System.out.println(\"一共有\"+count+\"种解法。\"); &#125; //编写一个方法，放置第n个皇后 private void check(int n)&#123; if(n == max)&#123;//n=8,其实八个皇后就已然放好了 print(); return; &#125; //依次放入皇后，并判断是否冲突 for(int i=0;i&lt;max;i++)&#123; //先把当前这个皇后n，放到该行的第1列 array[n] = i; //判断当放置第n个皇后的第i列时，是否冲突 if(judge(n))&#123;//不冲突 //接着放第n+1个皇后，即开始递归 check(n+1); &#125; //如果冲突，没有关系，就继续执行array[n] = i;即将第n个皇后放置在本行的后移的一个位置 &#125; &#125; //查看当我们放置第n个皇后时，就去检查该皇后是否和前面已经摆放的皇后冲突 private boolean judge(int n)&#123; for(int i=0;i&lt;n;i++)&#123; //说明： //1、array[i]==array[n] 表示判断第n个皇后是否和前面的n-1个皇后在同一列 //2、Math.abs(n-i)==Math.abs(array[n]-array[i]) 表示判断第n个皇后和第i个皇后是否在同一斜线 //3、判断是否在同一行，没有必要判断，因为n每次在递增 if(array[i]==array[n] || Math.abs(n-i)==Math.abs(array[n]-array[i]))&#123; return false; &#125; &#125; return true; &#125; //写一个方法，可以将皇后摆放的位置输出 private void print()&#123; count++; for(int i=00;i&lt;array.length;i++)&#123; System.out.print(array[i]+\" \"); &#125; System.out.println(); &#125;&#125; 输出的结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192930 4 7 5 2 6 1 3 0 5 7 2 6 3 1 4 0 6 3 5 7 1 4 2 0 6 4 7 1 3 5 2 1 3 5 7 2 0 6 4 1 4 6 0 2 7 5 3 1 4 6 3 0 7 5 2 1 5 0 6 3 7 2 4 1 5 7 2 0 3 6 4 1 6 2 5 7 4 0 3 1 6 4 7 0 3 5 2 1 7 5 0 2 4 6 3 2 0 6 4 7 1 3 5 2 4 1 7 0 6 3 5 2 4 1 7 5 3 6 0 2 4 6 0 3 1 7 5 2 4 7 3 0 6 1 5 2 5 1 4 7 0 6 3 2 5 1 6 0 3 7 4 2 5 1 6 4 0 7 3 2 5 3 0 7 4 6 1 2 5 3 1 7 4 6 0 2 5 7 0 3 6 4 1 2 5 7 0 4 6 1 3 2 5 7 1 3 0 6 4 2 6 1 7 4 0 3 5 2 6 1 7 5 3 0 4 2 7 3 6 0 5 1 4 3 0 4 7 1 6 2 5 3 0 4 7 5 2 6 1 3 1 4 7 5 0 2 6 3 1 6 2 5 7 0 4 3 1 6 2 5 7 4 0 3 1 6 4 0 7 5 2 3 1 7 4 6 0 2 5 3 1 7 5 0 2 4 6 3 5 0 4 1 7 2 6 3 5 7 1 6 0 2 4 3 5 7 2 0 6 4 1 3 6 0 7 4 1 5 2 3 6 2 7 1 4 0 5 3 6 4 1 5 0 2 7 3 6 4 2 0 5 7 1 3 7 0 2 5 1 6 4 3 7 0 4 6 1 5 2 3 7 4 2 0 6 1 5 4 0 3 5 7 1 6 2 4 0 7 3 1 6 2 5 4 0 7 5 2 6 1 3 4 1 3 5 7 2 0 6 4 1 3 6 2 7 5 0 4 1 5 0 6 3 7 2 4 1 7 0 3 6 2 5 4 2 0 5 7 1 3 6 4 2 0 6 1 7 5 3 4 2 7 3 6 0 5 1 4 6 0 2 7 5 3 1 4 6 0 3 1 7 5 2 4 6 1 3 7 0 2 5 4 6 1 5 2 0 3 7 4 6 1 5 2 0 7 3 4 6 3 0 2 7 5 1 4 7 3 0 2 5 1 6 4 7 3 0 6 1 5 2 5 0 4 1 7 2 6 3 5 1 6 0 2 4 7 3 5 1 6 0 3 7 4 2 5 2 0 6 4 7 1 3 5 2 0 7 3 1 6 4 5 2 0 7 4 1 3 6 5 2 4 6 0 3 1 7 5 2 4 7 0 3 1 6 5 2 6 1 3 7 0 4 5 2 6 1 7 4 0 3 5 2 6 3 0 7 1 4 5 3 0 4 7 1 6 2 5 3 1 7 4 6 0 2 5 3 6 0 2 4 1 7 5 3 6 0 7 1 4 2 5 7 1 3 0 6 4 2 6 0 2 7 5 3 1 4 6 1 3 0 7 4 2 5 6 1 5 2 0 3 7 4 6 2 0 5 7 4 1 3 6 2 7 1 4 0 5 3 6 3 1 4 7 0 2 5 6 3 1 7 5 0 2 4 6 4 2 0 5 7 1 3 7 1 3 0 6 4 2 5 7 1 4 2 0 6 3 5 7 2 0 5 1 4 6 3 7 3 0 2 5 1 6 4 一共有92种解法。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-栈（[逆]波兰表达式）","date":"2019-11-24T11:08:45.539Z","path":"2019/11/24/数据结构和算法-栈（[逆]波兰表达式）/","text":"什么是栈？[1]栈的英文名为Stack[2]栈是一个先入后出（FILO-Firest In Last Out）的有序列表[3]栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶，另一端为固定的一端，称为栈底。[4]根据栈的定义可知，最先放入栈的元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。 出栈和入栈入栈（push）：出栈（pop）： 栈的应用场景[1]子程序的调用：在跳往子程序前，会先将一下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。[2]处理递归调用：和子程序的调用类似，只是除了存储下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。[3]表达式的转换与求值（实际解决）。[4]二叉树的遍历。[5]图形的深度优先（depth-first）搜索算法。 栈的快速入门用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来存储栈的数据内容。思路分析：[1]使用数组模拟栈[2]定义一个top表示栈顶，初始值为-1[3]入栈的操作，当有数据加入到栈时，top++；stack[top]=data；[4]出栈的操作，int value=stack[top];top–,return value;代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//定义一个类表示栈结构class ArrayStack&#123; private int maxSize;//栈的大小 private int[] stack;//数组，模拟栈，数据就放在该数组中 private int top = -1;//栈顶，初始化为-1 //构造器 public ArrayStack(int maxSize)&#123; this.maxSize = maxSize; stack = new int[this.maxSize]; &#125; //栈满 public boolean isFull()&#123; return top == maxSize-1; &#125; //栈空 public boolean isEmpty()&#123; return top == -1; &#125; //入栈 public void push(int value)&#123; //先判断栈是否满 if(isFull())&#123; System.out.println(\"栈满\"); return; &#125; top++; stack[top] = value; &#125; //出栈,将栈顶的数组返回 public int pop()&#123; //先判断栈是否空 if(isEmpty())&#123; //抛出异常 throw new RuntimeException(\"栈空，没有数据~\"); &#125; int value = stack[top]; top--; return value; &#125; //显示栈的情况(遍历栈),遍历时，需要从栈顶开始显示数据 public void list()&#123; if(isEmpty())&#123; System.out.println(\"栈空~\"); return; &#125; for(int i = top;i &gt;= 0;i--)&#123; System.out.printf(\"stack[%d]=%d\\n\",i,stack[i]); &#125; &#125;&#125; 栈实现综合计算器（中缀表达式） 中缀表达式：[1]中缀表达式就是常见的运算表达式：如(3+4)X5-6[2]中缀表达式的求值是我们人最熟悉的，但是对于计算机来说却不好操作，因此在计算结果时，往往会将中缀表达式转换成其它表达式来操作 是用栈完成表达式的计算思路：[1]通过一个index值（索引），来遍历我们的表达式[2]创建两个栈，一个存放数值的栈，一个存放符号的栈[3]如果发现是一个数字，就直接放入数栈[4]如果发现的是一个符号，就分如下情况（1）如果发现当前的符号栈为空，就直接入栈（2）如果符号栈有操作符，就进行比较，如果当前的操作符的有限级小于或者等于栈中的操作符，就需要从数栈栈pop出两个数，在从符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的操作符入符号栈（3）如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈[5]当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号并运行。[6]最后在数栈中只有一个数字，就是表达式的结果。 代码：栈结构：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class ArrayStack2&#123; private int maxSize;//栈的大小 private int[] stack;//数组，模拟栈，数据就放在该数组中 private int top = -1;//栈顶，初始化为-1 public ArrayStack2(int maxSize)&#123;//构造器 this.maxSize = maxSize; stack = new int[this.maxSize]; &#125; //查看栈顶的值，不是真正的出栈 public int peek()&#123; return stack[top]; &#125; public boolean isFull()&#123;//栈满 return top == maxSize-1; &#125; public boolean isEmpty()&#123;//栈空 return top == -1; &#125; public void push(int value)&#123;//入栈 //先判断栈是否满 if(isFull())&#123; System.out.println(\"栈满\"); return; &#125; top++; stack[top] = value; &#125; public int pop()&#123;//出栈,将栈顶的数组返回 //先判断栈是否空 if(isEmpty())&#123; //抛出异常 throw new RuntimeException(\"栈空，没有数据~\"); &#125; int value = stack[top]; top--; return value; &#125; public void list()&#123; //显示栈的情况(遍历栈),遍历时，需要从栈顶开始显示数据 if(isEmpty())&#123; System.out.println(\"栈空~\"); return; &#125; for(int i = top;i &gt;= 0;i--)&#123; System.out.printf(\"stack[%d]=%d\\n\",i,stack[i]); &#125; &#125; //返回运算符的优先级，优先级使用数字表示，数字越大优先级越高 public int priority(int oper)&#123; if(oper == '*' || oper == '/')return 1; else if(oper == '+' || oper == '-') return 0; else return -1;//表达式只有+-*/ &#125; //判断是不是一个运算符 public boolean isOper(char val)&#123; return val == '+' || val == '-' || val == '*' || val == '/'; &#125; //计算方法 public int cal(int num1,int num2,int oper)&#123; int res = 0;//res用于存放计算结果 switch (oper) &#123; case '+': res = num1 + num2; break; case '-': res = num2 - num1;//注意顺序 break; case '*': res = num1 * num2; break; case '/': res = num2 / num1; break; default: break; &#125; return res; &#125;&#125; 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public static void main(String[] args) &#123; //表达式 String expression = \"3+2*6-2\"; //创建两个栈，一个是数栈，一个是符号栈 ArrayStack2 numStack = new ArrayStack2(10); ArrayStack2 operStack = new ArrayStack2(10); //定义相关变量 int index = 0;//用于扫描 int num1 = 0; int num2 = 0; int oper = 0; int res = 0; String keepNum=\"\"; char ch = ' ';//将每次扫描得到的结果保存到ch中 //开始while循环扫描 while(true)&#123; //依次得到expression的每一个字符 ch = expression.substring(index, index+1).charAt(0); //判断ch是什么，然后做相应的处理 if(operStack.isOper(ch))&#123;//如果是运算符 //判断当前的符号栈是否为空 if(!operStack.isEmpty())&#123; //如果符号栈有操作符，就进行比较，如果当前的操作符的有限级小于或者等于栈中的操作符 //就需要从数栈栈pop出两个数，在从符号栈中pop出一个符号，进行运算 //将得到的结果，入数栈，然后将当前的操作符入符号栈 if(operStack.priority(ch) &lt;= operStack.priority(operStack.peek()))&#123; num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); //把运算的结果入数栈 numStack.push(res); //然后把当前的操作符入符号栈 operStack.push(ch); &#125;else&#123; //如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈 operStack.push(ch); &#125; &#125;else&#123; //如果为空，直接入栈 operStack.push(ch); &#125; &#125;else&#123; //如果是数，则直接入数栈 //当处理多为数时，不能发现一个数就直接就入栈，因为可能是多位数】 //在处理数时，需要向expression的表达式的index后再看一位，如果是数就进行扫描，如果是符号就入栈 //因此需要定义一个变量 字符串，用于拼接 keepNum += ch; //如果ch已经是expression的最后一位，就直接入栈 if(index == expression.length() - 1)&#123; numStack.push(Integer.parseInt(keepNum)); &#125;else&#123; //判断字符串是不是数字，如果是数字就继续扫描，如果是运算符就入栈 if(operStack.isOper(expression.substring(index+1,index+2).charAt(0)))&#123; //如果后以为是运算符，则入栈 numStack.push(Integer.parseInt(keepNum)); //这里keepNum要置空 keepNum=\"\"; &#125; &#125; &#125; //让index + 1，并判断是否扫描到expression index++; if(index &gt;= expression.length())&#123; break; &#125; &#125; //当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号并运行。 while(true)&#123; //如果符号栈为空，则计算到最后的结果，数栈只有一个数字，这个就是结果 if(operStack.isEmpty())break; num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); numStack.push(res); &#125; //将数栈最后的结果pop出来 System.out.printf(\"表达式%s = %d\",expression,numStack.pop());&#125; 结果： 1表达式3+2*6-2 = 13 前缀表达式（波兰表达式） 前缀表达式的计算机求值：&emsp;&emsp;从右向左扫描表达式，遇到数字时，将数字压入栈中，遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算（栈顶元素和次顶元素），并将结果入栈；重复上述过程知道表达式最左端，最后运算得出的值即为表达式的结果。 例如：(3+4)X5-6对应的前缀表达式就是- X + 3 4 5 6 ,针对前缀表达式求值步骤如下：[1]从右至左扫描，将6、5、4压入堆栈。[2]遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算3+4的值，得7，再将7入栈。[3]接下来是X运算符，因此弹出7和5，计算出7X5=35，将35入栈。[4]最后是-运算符，计算出35-6的值，即29.由此得出最终结果。后缀表达式（逆波兰表达式） 后缀表达式[1]后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后[2]举例说明：(3+4)X5-6对应的后缀表达式就是3 4 + 5 X 6 -[3]再比如a+b 对应的后缀表达式为 a b +a+(b-c) 对应的后缀表达式为 a b c - +a+(b-c)d 对应的后缀表达式为 a b c - d * +a+d(b-c) 对应的后缀表达式为 a d b c - * +a=1+3 对应的后缀表达式为 a 1 3 + = 后缀表达式的计算机求值从左向右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素和栈顶元素），并将结果入栈；重复上述过程知道表达式最右端，最后运算符得出的值即为表达式的结果。 例如：(3+4)X5-6对应的后缀表达式就是3 4 + 5 X 6 -，针对后缀表达式求值步骤如下：[1]从左向右扫描，将3和4压入堆栈；[2]遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；[3]将5入栈；[4]接下来是X运算符，因此弹出5和7，计算7X5=35，将35入栈;[5]将6入栈；[6]最后是-运算符，计算出35-6的值，即29，由此得出最终结果。逆波兰计算器代码实现 逆波兰计算器，完成任务如下：[1]输入一个逆波兰表达式(后缀表达式)，使用栈（Stack），计算其结果[2]支持小括号和多位数整数 思路：(3+4)X5-6对应的后缀表达式就是3 4 + 5 X 6 -，针对后缀表达式求值步骤如下：[1]从左向右扫描，将3和4压入堆栈；[2]遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；[3]将5入栈；[4]接下来是X运算符，因此弹出5和7，计算7X5=35，将35入栈;[5]将6入栈；[6]最后是-运算符，计算出35-6的值，即29，由此得出最终结果。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.ArrayList;import java.util.List;import java.util.Stack;public class PolandNotation &#123; public static void main(String[] args) &#123; //定义一个逆波兰表达式 //(3+4)x5-6 =&gt; 3 4 + 5 x 6 - //为了方便，逆波兰表达式中的数字和符号使用空格隔开 String suffixExpression = \"3 4 + 5 * 6 -\"; //思路 //1、向将\"3 4 + 5 x 6 -\" =&gt; 放入ArrayList中 //2、将ArrayList传递给一个方法，遍历ArrayList 配合栈完成计算 List&lt;String&gt; list = getListString(suffixExpression); System.out.println(\"rpnList=\"+list); int res = calculate(list); System.out.println(\"计算的结果为=\"+res); &#125; //将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中 public static List&lt;String&gt; getListString(String suffixExpression)&#123; //将suffixExpression分割 String[] split = suffixExpression.split(\" \"); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(String ele : split)&#123; list.add(ele); &#125; return list; &#125; /* 完成对逆波兰表达式的运算 * (3+4)X5-6对应的后缀表达式就是3 4 + 5 X 6 -，针对后缀表达式求值步骤如下： * [1]从左向右扫描，将3和4压入堆栈； * [2]遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈； * [3]将5入栈； * [4]接下来是X运算符，因此弹出5和7，计算7X5=35，将35入栈; * [5]将6入栈； * [6]最后是-运算符，计算出35-6的值，即29，由此得出最终结果。 */ public static int calculate(List&lt;String&gt; ls)&#123; //创建一个栈,只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); //遍历 for(String item : ls)&#123; //这里使用一个正则表达式取出数 if(item.matches(\"\\\\d+\"))&#123;//匹配的是多位数 //入栈 stack.push(item); &#125;else&#123; //pop出两个数，并运算，再入栈 int num2 = Integer.parseInt(stack.pop()); int num1 = Integer.parseInt(stack.pop()); int res = 0; if(item.equals(\"+\"))&#123; res = num1 + num2; &#125;else if(item.equals(\"-\"))&#123; res = num1 - num2; &#125;else if(item.equals(\"*\"))&#123; res = num1 * num2; &#125;else if(item.equals(\"/\"))&#123; res = num1 / num2; &#125;else&#123; throw new RuntimeException(\"运算符有误\"); &#125; //把res入栈 stack.push(res+\"\"); &#125; &#125; //最后留在stack中的数据就是运算结果 return Integer.parseInt(stack.pop()); &#125;&#125; 结果： 12rpnList=[3, 4, +, 5, *, 6, -]计算的结果为=29 中缀表达式转换为后缀表达式&emsp;&emsp;从上面的案例可以看出，后缀表达式适合计算机进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将中缀表达式转成后缀表达式。 具体步骤如下：[1]初始化两个栈：运算符栈s1和储存中间结果的栈s2；[2]从左向右扫描中缀表达式；[3]遇到操作数时，将其压s2；[4]遇到运算符时，比较其与s1栈顶运算符的优先级：（1）如果s1为空，或栈顶运算符为左括号”（“，则直接将此运算符入栈；（2）否则，若优先级比栈顶运算符的高，也将元算符压入s1；（3）否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较。[5]遇到括号时：（1）如果是左括号“（”，则直接压入s1；（2）如果是右括号“）”，则异常弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃。[6]重复步骤2-5，直到表达式的最右边；[7]将s1中剩余的运算符依次弹出并压入s2；[8]依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。 例如：1+((2+3)X4)-5 其转换过程如下表：代码实现：编写一个类Operation 实现可以返回一个运算符对应的优先级数字123456789101112131415161718192021222324252627//编写一个类Operration 可以返回一个运算符对应的优先级class Operation&#123; private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; //写一个方法，返回一个优先级数字 public static int getValue(String operation)&#123; int result = 0; switch (operation) &#123; case \"+\": result = ADD; break; case \"-\": result = SUB; break; case \"*\": result = MUL; break; case \"/\": result = DIV; break; default: &#125; return result; &#125;&#125; 书写可以将一个中缀表达式字符串转换成字符然后返回List的方法 1234567891011121314151617181920212223//将中缀表达式转换成对应的Listpublic static List&lt;String&gt; toInfixExpressionList(String s)&#123; //定义一个list，存放中缀表达式对应的内容 List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); int i = 0;//相当于一个指针，用于遍历中缀表达式字符串 String str;//做多为数的拼接 char c;//每对应一个字符，就放入c中 do&#123; //如果c是一个非数字，就需要加入到ls if((c=s.charAt(i))&lt;48||(c=s.charAt(i))&gt;57)&#123; ls.add(\"\"+c); i++;//i需要后移 &#125;else&#123;//如果c是一个数字，需要考虑多为数的问题 str = \"\";//先将str置成空 while(i &lt; s.length() &amp;&amp; (c=s.charAt(i))&gt;=48 &amp;&amp; (c=s.charAt(i))&lt;=57)&#123; str +=c;//拼接 i++; &#125; ls.add(str); &#125; &#125;while(i&lt;s.length()); return ls;&#125; 书写一个可以将中缀表达式对应的List转换成后缀表达式对应的List的方法 1234567891011121314151617181920212223242526272829303132333435//将中缀表达式转换成对应的后缀表达式//即ArrayList[1,+,(,(,2,+,3,),*,4,),-,5] =&gt; ArrayList[1,2,3,+,4,*,+,5,-]public static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls)&#123; //定义两个栈 Stack&lt;String&gt; s1 = new Stack&lt;String&gt;();// 符号栈 //因为s2这个栈，在转换过程中，没有pop操错，后面还要逆序输出，因此可以直接使用List替代 List&lt;String&gt; s2 = new ArrayList&lt;String&gt;();//存储中间结果的List s2 //遍历ls for(String item : ls)&#123; //如果是一个数，加入s2 if(item.matches(\"\\\\d+\"))&#123; s2.add(item); &#125;else if(item.equals(\"(\"))&#123; s1.push(item); &#125;else if(item.equals(\")\"))&#123; //如果是右括号“）”，则异常弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃。 while(!s1.peek().equals(\"(\"))&#123; s2.add(s1.pop()); &#125; s1.pop();//将这个小括号(弹出s1栈，消除小括号 &#125;else &#123; //当item的优先级小于等于s1栈顶运算符的优先级，将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较 while(s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item))&#123; s2.add(s1.pop()); &#125; //还需要将item压入栈中 s1.push(item); &#125; &#125; //将s1中剩余的运算符依次弹出并加入s2 while(s1.size()!=0)&#123; s2.add(s1.pop()); &#125; return s2; //注意因为是存放到List，因此按顺序输出就是对应的逆波兰表达式&#125; 测试： 123456789101112131415public static void main(String[] args) &#123; //完成将一个中缀表达式转换成后缀表达式的功能 //说明 //1、1+((3+3)*4)-5 转成 1 2 3 + 4 * + 5 - //2、因为直接对一个字符串进行操作，不方便，因此先将“1+((3+3)*4)-5”转成中缀表达式对应的List // 即“1+((3+3)*4)-5” =&gt; ArrayList[1,+,(,(,2,+,3,),*,4,),-,5] //3、得到的中缀表达式对应的List转成一个后缀表达式的List // 即ArrayList[1,+,(,(,2,+,3,),*,4,),-,5] =&gt; ArrayList[1,2,3,+,4,*,+,5,-] String expreession = \"1+((2+3)*4)-5\"; List&lt;String&gt; infixExpressionList = toInfixExpressionList(expreession); System.out.println(\"中缀表达式对应的List：\"+infixExpressionList); List&lt;String&gt; parseSuffixExpressionList = parseSuffixExpressionList(infixExpressionList); System.out.println(\"后缀表达式对应的List：\"+parseSuffixExpressionList);&#125; 结果： 12中缀表达式对应的List：[1, +, (, (, 2, +, 3, ), *, 4, ), -, 5]后缀表达式对应的List：[1, 2, 3, +, 4, *, +, 5, -]","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-单向环形链表(约瑟夫环问题)","date":"2019-11-23T12:56:37.078Z","path":"2019/11/23/数据结构和算法-单向环形链表(约瑟夫环问题)/","text":"Josephu（约瑟夫、约瑟夫环）问题：设编号为1，2，…，n的n个人围坐一圈，约定的编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到的那个人又出列，依此类推，知道所有人出列为止，由此产生一个出队编号的序列。用一个不带头节点的循环链表来处理Josepho问题：先构成一个有n个节点的单循环链表，然后由k节点起从1开始计数，计到m时，对应节点从链表中删除，直到最后一个节点从链表中删除算法结束。 单向环形链表的介绍链表形成一个环状 约瑟夫问题的图释Josephu（约瑟夫、约瑟夫环）问题：设编号为1，2，…，n的n个人围坐一圈，约定的编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到的那个人又出列，依此类推，知道所有人出列为止，由此产生一个出队编号的序列。以上图的出队顺序为：2-&gt;4-&gt;1-&gt;5-&gt;3 约瑟夫问题的代码实现思路：构建一个环形链表[1]创建第一个节点，让一个指针(变量)first指向该节点，并形成一个环形[2]后面当我们每创建一个节点，就把该节点，加入到已有的环形链表中即可遍历环形链表[1]先让一个辅助指针(变量)curBoy，指向first节点[2]然后通过一个while循环遍历该环形链表即可[3]当curBoy.next == first 遍历结束代码：书写节点类Boy 1234567891011121314151617181920//创建一个Boy类，表示一个节点class Boy &#123; private int no;//编号 private Boy next;//指向下一个节点，默认为空 public Boy(int no)&#123; this.no=no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125;&#125; 创建一个环形单向链表 12345678910111213141516171819202122232425262728293031323334353637383940414243//创建一个环形的单向链表class CircleSingkeLinkedList &#123; //创建一个first节点，当前没有编号 private Boy first = null; //添加小孩节点，构成一个环形的链表 public void addBoy(int nums)&#123; //nums 做一个数据校验 if(nums&lt;1)&#123; System.out.println(\"nums的值不正确\"); return; &#125; Boy curBoy = null;//辅助指针，帮助构建环形链表 //使用for循环创建环形链表 for(int i = 1;i &lt;= nums; i++) &#123; //根据编号创建小孩节点 Boy boy = new Boy(i); //如果是第一个小孩 if(i==1) &#123; first = boy; first.setNext(first);//构成环 curBoy = first;//让curBoy指向第一个小孩 &#125; else &#123; curBoy.setNext(boy); boy.setNext(first); curBoy = boy; &#125; &#125; &#125; //遍历当前环形链表 public void showBoy() &#123; //判断链表是否为空 if(first==null) &#123; System.out.println(\"链表为空！\");return; &#125; //因为first不能动，因此仍然使用辅助指针完成遍历 Boy curBoy = first; while(true) &#123; System.out.printf(\"小孩的编号%d\\n\",curBoy.getNo()); if(curBoy.getNext()==first)break;//说明已经遍历完毕 curBoy = curBoy.getNext();//curBoy后移 &#125; &#125;&#125; 根据用户的输入，生成一个小孩出圈的顺序[1]需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这个节点。[2]小孩报数前，先让first和helper移动k-1次[2]当小孩报数时，让first和helper同时移动m-1次[3]这时就可以将first指向的小孩节点出圈first=first.nexthelper.next=first[4]原来first指向的这个节点就没有任何引用了向环形单向链表类CircleSingkeLinkedList中添加出圈这个方法 123456789101112131415161718192021222324252627282930313233343536373839404142//根据用户的输入，计算小孩出圈的顺序/** * @param startNo 表示从第几个小孩开始数数 * @param countNum 表示数几下 * @param nums 表示最初有多少小孩在圈中 */public void countBoy(int startNo,int countNum,int nums) &#123; //先对数据进行校验 if(first==null||startNo&lt;1||startNo&gt;nums)&#123; System.out.println(\"参数输入有误！\");return; &#125; //创建一个辅助指针，帮助完成小孩出圈 Boy helper = first; //需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这个节点。 while(true) &#123; if(helper.getNext() == first) &#123; //说明helper指向最后小孩节点 break; &#125; helper = helper.getNext(); &#125; //小孩报数前，先让first和helper移动k-1次 for(int j = 0;j&lt;startNo - 1;j++)&#123; first = first.getNext(); helper = helper.getNext(); &#125; //当小孩报数时，让first和helper同时移动m-1次,然后出圈 //循环操作，知道圈中只有一个节点 while(true) &#123; if(helper == first)break;//说明圈中只有一个节点 //让first和helper同时移动countNum-1次,然后出圈 for(int j = 0;j&lt;countNum-1;j++) &#123; first = first.getNext(); helper = helper.getNext(); &#125; //这是first指向的这个小孩就是要出圈的小孩节点 System.out.printf(\"小孩%d出圈\\n\",first.getNo()); //这时将first指向的小孩节点出圈 first = first.getNext(); helper.setNext(first); &#125; System.out.printf(\"最后留在圈中的小孩编号%d\\n\",first.getNo());&#125; 测试： 123456public static void main(String[] args) &#123; //测试 CircleSingkeLinkedList c = new CircleSingkeLinkedList(); c.addBoy(5); c.countBoy(1, 2, 5);&#125; 结果： 12345小孩2出圈小孩4出圈小孩1出圈小孩5出圈最后留在圈中的小孩编号3","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-双向链表","date":"2019-11-23T09:51:56.565Z","path":"2019/11/23/数据结构和算法-双向链表/","text":"在学习单向链表的时候，使用带head头的双向链表实现-水浒英雄排行榜管理单项向链表的缺点分析：[1]单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。[2]单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面单链表删除节点时，总是找到temp，temp是代删除节点的前一个节点。分析 双向链表的遍历，添加，修改，删除的操作思路==》代码实现[1]遍历方式和单链表一样，只是可以向前，也可以向后[2]添加（默认添加到双向链表的最后这个节点）（1）先找到双向链表的最后这个节点（2）temp.next=newHeroNode（使最后这个节点直接指向新的节点）（3）newHeroNode.pre=temp（使新添加进来的节点的pre指向上一个节点）[3]修改思路和原理和单向链表一样[4]删除（1）因为是双向链表，因此，可以自我删除某个节点，而不需要想单链表一样找到前一个节点才能删除（2）直接找到要删除的节点，比如temp（3）temp.pre.next=temp.next（要删除节点的上一个节点指向的下一个节点为要删除节点的下一个节点）（4）temp.next.pre=temp.pre（要删除节点的下一个节点指向的上一个节点为要删除节点的上一个节点） 双向链表的代码实现创建节点类HeroNode 12345678910111213141516171819// 创建一个节点类HeroNode，每个HeroNode对象就是一个节点class HeroNode &#123; public int no; public String nickname; public String name; public HeroNode next;// 指向下一个节点 public HeroNode pre;// 指向上一个节点 // 构造器 public HeroNode(int no, String name, String nickname) &#123; this.no = no; this.name = name; this.nickname = nickname; &#125; @Override public String toString() &#123; return \"HeroNode [no=\" + no + \", nickname=\" + nickname + \", name=\" + name + \", next=\" + next + \", pre=\" + pre + \"]\"; &#125;&#125; 创建一个双向链表的类DoubleLinkedList 123456789// 创建一个双向链表的类class DoubleLinkedList &#123; //先初始化一个头节点，头节点不要动，不存放具体的数据 private HeroNode head = new HeroNode(0,\"\",\"\"); //放回头节点 public HeroNode getHead()&#123; return head; &#125;&#125; 双向链表的遍历双向链表的遍历，和单向链表一样。(在双向链表的类DoubleLinkedList中添加方法list()来显示双向链表) 123456789101112131415161718//显示链表public void list()&#123; //判断链表是否为空 if(head.next==null)&#123; System.out.println(\"链表为空\"); return; &#125; //因为头节点不能动，因此我们需要一个辅助变量来遍历 HeroNode temp = head.next; while(true)&#123; //判断是否到最后 if(temp == null)break; //输出节点信息 System.out.println(temp); //将next后移,不后移将会是一个死循环 temp = temp.next; &#125;&#125; 双向链表添加节点思路：（1）先找到双向链表的最后这个节点（2）temp.next=newHeroNode（使最后这个节点直接指向新的节点）（3）newHeroNode.pre=temp（使新添加进来的节点的pre指向上一个节点）代码实现（在双向链表的类DoubleLinkedList中添加方法add()来向双向链表添加节点）： 123456789101112131415public void add(HeroNode heroNode)&#123; //应为head节点不能动，因此需要一个辅助变量 temp HeroNode temp = head; //遍历链表，找到最后 while(true)&#123; //找到最后一个 if(temp.next==null) break; //没有找到最后 temp = temp.next; &#125; //当退出while循环时，temp就指向了链表的最后 //形成一个双向链表 temp.next = heroNode; heroNode.pre = temp;&#125; 双向链表的修改双向链表的节点内容修改，可单向链表的节点内容修改一样，在双向链表的类DoubleLinkedList中添加方法update()来修改双向链表节点内容 1234567891011121314151617181920212223242526//修改双向链表一个节点的内容public void update(HeroNode newHeroNode)&#123; if(head.next==null)&#123; System.out.println(\"链表为空\");return; &#125; //找到需要修改的节点，根据no编号 //定义一个辅助变量 HeroNode temp = head.next; boolean flag = false;//表示是否找到该节点 while(true)&#123; if(temp == null)break;//已经遍历完这个链表了 if(temp.no == newHeroNode.no)&#123;//找到了 flag = true; break; &#125; //后移，相当于遍历 temp = temp.next; &#125; //根据flag判断是否找到要修改的节点 if(flag)&#123; temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; &#125;else&#123; System.out.printf(\"没有找到编号%d的节点，不能修改\",newHeroNode.no); &#125;&#125; 双向链表的节点删除思路：（1）因为是双向链表，因此，可以自我删除某个节点，而不需要想单链表一样找到前一个节点才能删除（2）直接找到要删除的节点，比如temp（3）temp.pre.next=temp.next（要删除节点的上一个节点指向的下一个节点为要删除节点的下一个节点）（4）temp.next.pre=temp.pre（要删除节点的下一个节点指向的上一个节点为要删除节点的上一个节点）代码实现（在双向链表的类DoubleLinkedList中添加方法del()来表示删除双向链表中的某个节点）： 12345678910111213141516171819202122232425262728//删除节点//对于双向链表，可以直接找到要删除这个节点public void del(int no)&#123; //判断当前链表是否为空 if(head.next==null) &#123; System.out.println(\"链表为空~！无法删除\");return; &#125; HeroNode temp = head.next; boolean flag = false; //标志是否找到待删除节点 while(true)&#123; if(temp == null)break;//已经到链表最后 if(temp.no == no)&#123;//找到了待删除节点的前一个节点 flag = true; break; &#125; //后移，遍历 temp = temp.next; &#125; if(flag)&#123;//可以删除 temp.pre.next = temp.next; if(temp.next!=null) temp.next.pre = temp.pre;//如果是最后一个节点就不需要执行下面这句话，否则会出现空指针异常 &#125;else&#123; System.out.printf(\"要删除的节点%d,不存在\",no); &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-单链表","date":"2019-11-10T12:13:34.814Z","path":"2019/11/10/数据结构和算法-单链表/","text":"&emsp;&emsp;单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。 单链表介绍单链表是有序的列表，但它在内存中的存储如下：)(1)连接是以节点的方式来存储。(2)每个节点包含data域，next域：指向写一个节点。(3)如上图：链表的各个节点不一定是连续存储。(4)链表分带头节点的链表和没有头节点的链表，根据实际需求来确定。 单链表节点的添加使用带head头的单向链表实现-水浒英雄排行榜管理(1)完成对英雄任务的增删改查操作(2)第一种方法在添加英雄时，直接添加到链表的尾部（不考虑排序等问题）(3)第二种方法在添加英雄时，根据排名将名将英雄插入到指定位置（如果有这个排名，则添加失败，并给出提示） 第一种方法的实现 { 直接添加到链表的尾部（不考虑排序等问题）}定义HeroNode，每个HeroNode对象就是一个节点12345678910111213141516class HeroNode&#123; public int no; public String name; public String nickname; public HeroNode next;//指向下一个节点 //构造器 public HeroNode(int no,String name, String nickname)&#123; this.no = no; this.name = name; this.nickname = nickname; &#125; @Override public String toString() &#123; return \"HeroNode [no=\" + no + \", name=\" + name + \", nickname=\" + nickname + \"]\"; &#125;&#125; 定义一个SingleLinkedList 管理节点 12345678910111213141516171819202122232425262728293031323334353637383940414243class SingleLinkedList&#123; //先初始化一个头节点，头节点不要动,不存放具体的数据 private HeroNode head = new HeroNode(0,\"\",\"\"); /** * 添加节点到单向链表 * 当不考虑编号顺序时 * 1、找到当前链表的最后节点 * 2、将最后这个节点的next 指向新的节点 */ public void add(HeroNode heroNode)&#123; //应为head节点不能动，因此需要一个辅助变量 temp HeroNode temp = head; //遍历链表，找到最后 while(true)&#123; //找到最后一个 if(temp.next==null) break; //没有找到最后 temp = temp.next; &#125; //当退出while循环时，temp就指向了链表的最后 temp.next = heroNode; &#125; /** * 显示链表（遍历） */ public void list()&#123; //判断链表是否为空 if(head.next==null)&#123; System.out.println(\"链表为空\"); return; &#125; //因为头节点不能动，因此我们需要一个辅助变量来遍历 HeroNode temp = head.next; while(true)&#123; //判断是否到最后 if(temp == null)break; //输出节点信息 System.out.println(temp); //将next后移,不后移将会是一个死循环 temp = temp.next; &#125; &#125;&#125; 测试 12345678910111213141516public static void main(String[] args) &#123; //创建节点 HeroNode hero1 = new HeroNode(1,\"宋江\",\"及时雨\"); HeroNode hero2 = new HeroNode(2,\"卢俊义\",\"及时雨\"); HeroNode hero3 = new HeroNode(3,\"无用\",\"智多星\"); HeroNode hero4 = new HeroNode(4,\"林冲\",\"豹子头\"); //创建一个链表 SingleLinkedList singleLinkedList = new SingleLinkedList(); //加入 singleLinkedList.add(hero1); singleLinkedList.add(hero2); singleLinkedList.add(hero3); singleLinkedList.add(hero4); //显示 singleLinkedList.list();&#125; 结果 1234HeroNode [no=1, name=宋江, nickname=及时雨]HeroNode [no=2, name=卢俊义, nickname=及时雨]HeroNode [no=3, name=无用, nickname=智多星]HeroNode [no=4, name=林冲, nickname=豹子头] 第二种方法的实现 { 根据排名将名将英雄插入到指定位置（如果有这个排名，则添加失败，并给出提示）}在上面已经定义的SingleLinkedList管理HeroNode的类中添加方法addByOrder1234567891011121314151617181920212223public void addByOrder(HeroNode heroNode)&#123; //因为头节点不能动，因此我们仍然通过一个辅助指针（变量）来帮助找到添加位置 //因为单链表，因此找的temp是位于 添加位置的前一个节点，否则插入不了 HeroNode temp = head; boolean flag = false;//标识添加的编号是否存在，默认为false while(true)&#123; if(temp.next == null)break;//说明temp已经在链表最后 if(temp.next.no &gt; heroNode.no)break;//位置找到了，就在temp后面插入 else if(temp.next.no == heroNode.no)&#123;//说明希望添加的heroNode编号已经存在 flag = true;//说明编号存在 break; &#125; temp = temp.next;//后移，遍历当前链表 &#125; //判断flag的值 if(flag)&#123;//不能添加，说明编号存在 System.out.printf(\"准备插入的英雄的编号%d已经存在,不能加入。\\n\",heroNode.no); &#125;else&#123; //插入到链表中 heroNode.next = temp.next; temp.next = heroNode; &#125;&#125; 单链表节点的修改修改原来节点的name和nickname，只需要在上面定义的SingleLinkedList管理HeroNode的类中添加方法update 123456789101112131415161718192021222324252627//修改节点的信息，根据no编号修改，即no不能改//1、根据newHeroNode的no来修改public void update(HeroNode newHeroNode)&#123; if(head.next==null)&#123; System.out.println(\"链表为空\");return; &#125; //找到需要修改的节点，根据no编号 //定义一个辅助变量 HeroNode temp = head.next; boolean flag = false;//表示是否找到该节点 while(true)&#123; if(temp == null)break;//已经变量完这个链表了 if(temp.no == newHeroNode.no)&#123;//找到了 flag = true; break; &#125; //后移，相当于遍历 temp = temp.next; &#125; //根据flag判断是否找到要修改的节点 if(flag)&#123; temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; &#125;else&#123; System.out.printf(\"没有找到编号%d的节点，不能修改\",newHeroNode.no); &#125;&#125; 单链表的节点删除从单链表中删除一个节点的思路1、找到需要删除的节点的前一个节点temp2、temp.next = temp.next.next3、被删除的节点，将不会有其它应用指向，会被垃圾回收机制回收代码实现 123456789101112131415161718192021//删除节点//1、head不能动，因此我们需要一个temp辅助节点找到待删除的节点的前一个节点//2、说明我们在比较时，是temp.next.no 和需要删除的节点的no比较public void del(int no)&#123; HeroNode temp = head; boolean flag = false; //标志是否找到待删除节点 while(true)&#123; if(temp.next == null)break;//已经到链表最后 if(temp.next.no == no)&#123;//找到了待删除节点的前一个节点 flag = true; break; &#125; //后移，遍历 temp = temp.next; &#125; if(flag)&#123;//可以删除 temp.next = temp.next.next; &#125;else&#123; System.out.printf(\"要删除的节点%d,不存在\",no); &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-队列","date":"2019-11-09T07:24:13.170Z","path":"2019/11/09/数据结构和算法-队列/","text":"&emsp;&emsp;队列是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作(先入先出原则)，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列的使用场景银行排队案例：&emsp;&emsp;在银行排队办理业务的时候，如果窗口有人正在办理业务，后面等待的人会按照先后顺序排成一个队列，这个队列的人，先到的先从等待队列中出去办理业务，而后到的人要从这个队列的末尾排队，等待先到的人从这个等待队列出去办理业务之后，后到的人才能从等待队列出去。 用数组模拟队列思路分析&emsp;&emsp;队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图所示，其中maxSize是该队列的最大容量。&emsp;&emsp;因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据输入而改变，如图所示：当我们将数据存入队列时称为“addQueue”，addQueue的处理需要有两个步骤：(1)将尾指针往后移：rear+1，当front==rear 时，为空队列。(2)若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear==maxSize-1 时，为队列满。 数组模拟队列的代码实现模拟一个队列实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//使用数组模拟队列（编写一个ArrayQueue类）class ArrayQueue&#123; private int maxSize;//表示数组的最大容量 private int front;//队列头 private int rear;//队列尾 private int[] arr;//该数组用于存放队列，模拟的队列 //创建队列构造器 public ArrayQueue(int arrMaxSize)&#123; maxSize = arrMaxSize; arr = new int[maxSize]; front = -1;//指向队列头部，分析出front是指向队列头的前一个位置 rear = -1;//指向队列尾部，指向队列尾的数据(就是队列最后一个数据) &#125; //判断队列是否满 public boolean isFull()&#123; return rear == maxSize - 1; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return rear == front; &#125; //添加数据到队列 public void addQueue(int n)&#123; //判断队列是否满 if(isFull())&#123; throw new RuntimeException(\"队列满，不能加入数据！\"); &#125; rear++;//让rear后移 arr[rear] = n; &#125; //数据出队列 public int getQueue()&#123; //判断队列是否空 if(isEmpty())&#123; //通过抛出异常处理 throw new RuntimeException(\"队列空，不能取数据\"); &#125; front++; return arr[front]; &#125; //显示队列的所有数据 public void showQueue()&#123; //遍历 if(isEmpty())&#123; System.out.println(\"队列为空，没有数据！\"); return; &#125; for(int i = 0; i&lt;arr.length;i++)&#123; System.out.printf(\"arr[%d]=%d\\n\",i,arr[i]); &#125; &#125; //显示队列的头数据，注意部署去除数据 public int headQueue()&#123; //判断队列是否为空 if(isEmpty())&#123; throw new RuntimeException(\"队列空，没有头！\"); &#125; return arr[front+1]; &#125;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ArrayQueueDemo &#123; public static void main(String[] args) &#123; //创建一个队列 ArrayQueue arrayQueue = new ArrayQueue(3); char key = ' ';//接收用户的输入 Scanner scanner = new Scanner(System.in); boolean loop = true; //输出一个菜单 while(loop)&#123; System.out.print(\"s(show):显示队列;\"); System.out.print(\"e(exit):退出程序;\"); System.out.print(\"a(add):添加队列;\"); System.out.print(\"g(get):从队列取出数据;\"); System.out.println(\"h(head):查看队列头的数据。\"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': arrayQueue.showQueue(); break; case 'e': scanner.close(); loop = false; break; case 'a': try &#123; System.out.println(\"请输入一个数字：\"); int value = scanner.nextInt(); arrayQueue.addQueue(value); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'g': try &#123; int res = arrayQueue.getQueue(); System.out.printf(\"取出的数据是%d\\n\",res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h': try &#123; int head = arrayQueue.headQueue(); System.out.printf(\"队列头为%d\\n\",head); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; default: break; &#125; &#125; System.out.println(\"程序退出\"); &#125;&#125; 结果：目前代码存在的一些问题(1)目前数字使用一次就不能使用，没有达到复用的效果(2)将这个数字使用算法，改成一个环形的数组 数组模拟环形队列 思路：1、front变量的含义做一个调整：front指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，front的初始值 = 02、rear变量的含义也做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为一个约定。rear的初始值 = 03、当队列满时，条件是：( rear + 1 ) % maxSize = front4、当队列为空，条件是：rear == front5、当这样之后，队列中有效的数据的个数为( rear + maxSize - front ) % maxSize 代码实现模拟一个环形队列实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//使用数组模拟环形队列（编写一个CircleQueue类）class CircleArray&#123; private int maxSize;//表示数组的最大容量 private int front;//front变量的含义做一个调整：front指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，front的初始值 = 0 private int rear;//rear变量的含义也做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为一个约定。rear的初始值 = 0 private int[] arr;//该数组用于存放队列，模拟的队列 //创建队列构造器 public CircleArray(int arrMaxSize)&#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; //判断队列是否满 public boolean isFull()&#123; return (rear+1)%maxSize==front; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return rear == front; &#125; //添加数据到环形队列 public void addQueue(int n)&#123; //判断队列是否满 if(isFull())&#123; throw new RuntimeException(\"队列满，不能加入数据！\"); &#125; arr[rear] = n; rear = (rear+1)%maxSize;//将rear后移，这里必须考虑取模 &#125; //数据出队列 public int getQueue()&#123; //判断队列是否空 if(isEmpty())&#123; //通过抛出异常处理 throw new RuntimeException(\"队列空，不能取数据\"); &#125; //front是指向队列的第一个元素 //1、先把front对应的值保存到一个临时的变量 //2、将front后移 //3、将临时保存的变量返回 int value = arr[front]; front = (front+1)%maxSize; return value; &#125; //显示队列的所有数据 public void showQueue()&#123; //遍历 if(isEmpty())&#123; System.out.println(\"队列为空，没有数据！\"); return; &#125; //从fron开始遍历，遍历多少个元素 for(int i = front; i&lt;front+size();i++)&#123; System.out.printf(\"arr[%d]=%d\\n\",i%maxSize,arr[i%maxSize]); &#125; &#125; //求出当前队列的有效数据 public int size()&#123; return (rear+maxSize-front)%maxSize; &#125; //显示队列的头数据，注意不是去除数据 public int headQueue()&#123; //判断队列是否为空 if(isEmpty())&#123; throw new RuntimeException(\"队列空，没有头！\"); &#125; return arr[front]; &#125;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void main(String[] args) &#123; //测试 System.out.println(\"测试环形队列\"); //创建一个队列 CircleArray circleQueue = new CircleArray(4);//起队列的有效数据最大为3 char key = ' ';//接收用户的输入 Scanner scanner = new Scanner(System.in); boolean loop = true; //输出一个菜单 while(loop)&#123; System.out.print(\"s(show):显示队列;\"); System.out.print(\"e(exit):退出程序;\"); System.out.print(\"a(add):添加队列;\"); System.out.print(\"g(get):从队列取出数据;\"); System.out.println(\"h(head):查看队列头的数据。\"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': circleQueue.showQueue(); break; case 'e': scanner.close(); loop = false; break; case 'a': try &#123; System.out.println(\"请输入一个数字：\"); int value = scanner.nextInt(); circleQueue.addQueue(value); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'g': try &#123; int res = circleQueue.getQueue(); System.out.printf(\"取出的数据是%d\\n\",res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h': try &#123; int head = circleQueue.headQueue(); System.out.printf(\"队列头为%d\\n\",head); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; default: break; &#125; &#125; System.out.println(\"程序退出\");&#125; 结果：","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-稀疏数组","date":"2019-11-05T13:54:41.952Z","path":"2019/11/05/数据结构和算法-稀疏数组/","text":"实际需求 编写的五子棋程序中，有存盘退出和继续上盘的功能使用二维数组记录棋盘(用1记录玩家1，用2记录玩家2)0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;1&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;2&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0 分析存在的问题&emsp;&emsp;因为二维数组的很多值都是默认的值0，因此记录了很多没有意义的数据，这个时候就可以使用稀疏数组解决这个问题。稀疏数组 基本介绍当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存改数组。稀疏数组的处理方法是：（1）记录数组一共有几行几列，有多少个不同的值（2）把具有不同值的元素行列及值记录在一个小规模得数组中，从而缩小程序得规模 举例说明实际二维数组转换为稀疏二维数组&emsp;&emsp;从上面两个数组可以看出，原始的二维数组一共记录了42个数据，而转换为稀疏二维数组之后只需要记录27个数据。 应用实例（1）使用稀疏数组，来保存类似前面的二维数组（棋盘、地图等等）（2）把稀疏数组存盘，并且可以从新恢复原来的二维数组（3）思路分析将原始二维数组转换为稀疏数组的思路①遍历原始的二维数组，得到有效数据的个数sum②根据sum就可以创建稀疏二维数组sparseArr int[sum+1][3]③将原始二维数组的有效数据存入到稀疏数组将稀疏数组转换为原始二维数组的思路①先读取稀疏数组的第一行，根据第一行的数据创建原始的二维数组②在读取稀疏数组后几行的数据，并赋值给原始二维数组即可 稀疏数组的代码实现 此部分是将上面的思路分析转换成代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class SparseArray &#123; public static void main(String[] args) &#123; /** * 将原始二维数组转换为稀疏数组 */ //创建一个原始的二维数组10 * 10 //0：表示每一棋子，1表示黑棋，2表示白棋 int chessArr1[][] = new int[10][10]; chessArr1[3][3]=1; chessArr1[4][4]=2; //输出原始的二维数组 System.out.println(\"原始二维数组：\"); for(int[] row: chessArr1)&#123; for(int data : row)&#123; System.out.printf(\"%d\\t\",data); &#125; System.out.println(); &#125; //将二维数组转换为稀疏数组 //1.先遍历二维数组，得到非0数据的个数 int sum=0; for(int i = 0; i&lt;10;i++)&#123; for(int j = 0; j&lt;10;j++)&#123; if(chessArr1[i][j]!=0)&#123; sum++; &#125; &#125; &#125; //2.创建对应的稀疏数组 int sparseArr[][] = new int[sum+1][3]; //给稀疏数组赋值 sparseArr[0][0] = 10; sparseArr[0][1] = 10; sparseArr[0][2] = 2; //遍历原始二维数组，将非0的值存放到sparseArr中 int count = 0;//count用于记录是第几个非0数据 for(int i = 0; i&lt;10;i++)&#123; for(int j = 0; j&lt;10;j++)&#123; if(chessArr1[i][j]!=0)&#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; //输出稀疏数组的形式 System.out.println(); System.out.println(\"得到的稀疏数组为：\"); for(int i = 0;i&lt;sparseArr.length;i++)&#123; System.out.printf(\"%d\\t%d\\t%d\\t\",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]); System.out.println(); &#125; /** * 将稀疏数组转换为原始二维数组 */ //1.读取稀疏数组第一行，根据第一行数据创建原始二维数组 int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]]; //2.根据稀疏数组第二行以及之后行的数据赋值给原始二维数组 for(int i = 1;i&lt;sparseArr.length;i++)&#123; chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; //输出还原的二维数组 System.out.println(\"恢复之后的二维数组：\"); for(int[] row: chessArr2)&#123; for(int data : row)&#123; System.out.printf(\"%d\\t\",data); &#125; System.out.println(); &#125; &#125;&#125; 运行结果：","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"Maven的核心概念","date":"2019-10-27T13:06:14.588Z","path":"2019/10/27/Maven的核心概念/","text":"Maven的目录结构，POM，坐标，仓库，依赖，生命周期，继承，聚合分别是什么呢？ Maven的目录结构这一部分的内容在我的上一篇《快速上手Maven》已经讲过，在这就不在过多赘述。HelloMaven：根目录（工程名）src：源码pom.xml：Maven工程的核心配置文件main：存放主程序test：存放测试程序java：存放java源文件resources：存放框架或者其它工具的配置文件 POM[1]含义：Project Object Model 项目对象模型，类似与DOM Document Object Model 文档对象模型[2]pom.xml对于Maven工程是核心的配置文件，与构建过程相关的一切设置都在这个文件中进行配置。重要程度相当于web.xml对于动态Web工程。 坐标 在Maven中坐标是使用三个向量在仓库中唯一定位一个Maven工程[1]groupId：公司或者组织的唯一标志，一般用公司或组织域名倒序+项目名 1&lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt; [2]artifactId：模块名，项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 1&lt;artifactId&gt;HelloMaven&lt;/artifactId&gt; [3]version：版本号 1&lt;version&gt;1.0&lt;/version&gt; Maven坐标与仓库中路径的对应关系如com.xiezhenyu.maven，maven会将该项目打成的jar包放本地仓库路径：/com/xiezhenyu/maven-1.0.jar。我们自己的 Maven 工程必须执行安装操作才会进入仓库，安装的命令是：mvn install。 仓库 仓库的分类[1]本地仓库：为当前本机电脑上所有的Maven工程服务[2]远程仓库：远程仓库分为私服、中央仓库、中央镜像仓库。私服：架设在当前局域网环境下，为当前局域网范围内的所有Maven工程服务；中央仓库：架设在Internet上，为全世界所有的Maven工程服务；中央仓库镜像：架设在各个大洲上，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。其中仓库的关系可以参照下图： 仓库中的文件(仓库中保存的内容)[1]Maven自身所需要的插件[2]第三方框架或工具的jar包[3]我们自己开发的Maven工程 依赖 概念&emsp;&emsp;当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖，这是概念上的描述。Maven解析依赖信息时会到仓库中查找被依赖的jar包。 如果要使用我们自己开发的jar包，要使用mvn install命令安装后就可以进入仓库。 依赖的范围 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在上面test就是描述依赖的范围，其值可以有 其文字描述为： compile范围依赖※对主程序是否有效：有效※对测试程序是否有效：有效※是否参与打包：参与※是否参与部署：参与※典型例子：spring-core test范围依赖 ※对主程序是否有效：无效 ※对测试程序是否有效：有效 ※是否参与打包：不参与 ※是否参与部署：不参与 ※典型例子：Junit 从开发和运行这两个阶段理解compile 和 provided 的区别 compile围依赖 provided 范围依赖 依赖的传递性&emsp;&emsp;比如A.jar依赖B.jar，B.jar依赖C.jar，A.jar能否使用C.jar呢？这时就需要看B.jar依赖C.jar的范围是不是compile范围的依赖。这就说明，C.jar只是给B.jar单独使用的。 依赖的排除&emsp;&emsp;如果我们当前工程中引入了一个依赖是A.jar，而A.jar又依赖了B.jar，那么Maven会自动将A依赖的B引入当前工程，但是个别情况下B.jar有可能是一个不稳定版本，或对当前工程有不良影响。这时我们可以在引入A.jar的时候将B.jar排除。①情景②配置方式 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt; &lt;artifactId&gt;HelloMaven&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;!-- 配置需要排除的依赖信息 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ③排除后的结果 依赖的原则，解决jar包冲突①路径最短者优先会根据jar包的路径最短的原则依赖jar包②路径相同时先声明者优先，先生命指的是dependency标签声明的顺序。 统一管理所依赖的版本&emsp;&emsp;对同一个框架的一组jar包最好使用相同的版本。为了方便升级架构，可以将jar包的版本信息统一提取出来。①统一声明版本号(其中 jackson.version 部分是自定义标签。) 123&lt;properties&gt; &lt;jackson.version&gt;2.9.6&lt;/jackson.version&gt;&lt;/properties&gt; ②引用前面声明的版本号 (在这里就会统一引用声明好的版本号) 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;&lt;/dependency&gt; ③其实properties标签配合自定义标签声明数据的配置并不是只能用于声明依赖的版本号。凡是需要统一声明后再引用的场合都可以使用。 生命周期 各个构建环节执行的顺序：不能打乱顺序，必须按照既定的正确顺序来执行。 Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。 Maven核心程序为了更好的实现自动化构建，按照这一特点执行生命周期中各个阶段：不论现在要执行生命周期中的哪一阶段，都是从这个生命周期最初的位置开始执行。 Maven有三套相互独立的生命周期，分别是：①Clean Lifecycle 在进行真正的构建之前进行一些清理工作。②Default Lifecycle 构建的核心部分，编译、测试、打包、安装、部署等等。③Site Lifecycle 生成项目报告，站点，发布站点。&emsp;&emsp;他们相互独立。也可以直接运行 mvn clean install site 运行所有这三套生命周期。每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。 Clean声明周期①pre-clean 执行一些需要在clean之前完成的工作②clean 移除所有上一次构建生成的文件③post-clean 执行一些需要在clean 之后立刻完成的工作 Default声明周期Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里标红一些比较重要和常用的阶段：validate（校验） 校验项目是否正确并且所有必要的信息可以完成项目的构建过程。initialize（初始化） 初始化构建状态，比如设置属性值。generate-sources（生成源代码） 生成包含在编译阶段中的任何源代码。process-sources（处理源代码） 处理源代码，比如说，过滤任意值。generate-resources（生成资源文件） 生成将会包含在项目包中的资源文件。process-resources （处理资源文件） 复制和处理资源到目标目录，为打包阶段最好准备。compile（编译） 编译项目的源代码。process-classes（处理类文件） 处理编译生成的文件，比如说对Java class文件做字节码改善优化。generate-test-sources（生成测试源代码） 生成包含在编译阶段中的任何测试源代码。process-test-sources（处理测试源代码） 处理测试源代码，比如说，过滤任意值。generate-test-resources（生成测试资源文件） 为测试创建资源文件。process-test-resources（处理测试资源文件） 复制和处理测试资源到目标目录。test-compile（编译测试源码） 编译测试源代码到测试目标目录.process-test-classes（处理测试类文件） 处理测试源码编译生成的文件。test（测试） 使用合适的单元测试框架运行测试（Juint是其中之一）。prepare-package（准备打包） 在实际打包之前，执行任何的必要的操作为打包做准备。package（打包） 将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件。pre-integration-test（集成测试前） 在执行集成测试前进行必要的动作。比如说，搭建需要的环境。integration-test（集成测试） 处理和部署项目到可以运行集成测试环境中。post-integration-test（集成测试后） 在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境。verify （验证） 运行任意的检查来验证项目包有效且达到质量标准。install（安装） 安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。deploy（部署） 将最终的项目包复制到远程仓库中与其他开发者和项目共享。 Site生命周期①pre-site 执行一些需要在生成站点文档之前完成的工作②site 生成项目的站点文档③post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备④site-deploy 将生成的站点文档部署到特定的服务器上 插件和目标①生命周期的各个阶段仅仅定义了要执行的任务是生命②各个阶段和插件的目标是对应的③相似的目标由特定的插件来完成例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。 继承 现状Hello依赖的Junit：4.0HelloFriend依赖的Junit：4.0MakeFriends依赖的Junit：4.9由于test范围的依赖不能传递，所以必然会分散在各个模块工程中，很容易造成版本不一致。 需求：统一管理各个模块工程中对Junit依赖的版本。 解决思路：将Junit依赖统一提取到“父”工程中，在子工程中声明Junit依赖是不指定版本，以父工程中统一设定的为准。同时也便于修改。 操作步骤：①创建一个Maven工程作为父工程。注意：打包方式为pom 1234&lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt;&lt;artifactId&gt;Parent&lt;/artifactId&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt; ②在子工程中声明对父工程的引用 12345678&lt;!-- 在子过程中声明父工程 --&gt;&lt;parent&gt; &lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!-- 以当前工程的pom.xml文件为基准的父工程pom.xml文件的相对路径 --&gt; &lt;relativePath&gt;&lt;/relativePath&gt;&lt;/parent&gt; ③将子工程的坐标中与父工程坐标中重复的内容删除 ④在父工程中统一管理Junit的依赖 1234567891011&lt;!-- 配置依赖的管理 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; ⑤在子工程中删除Junit依赖的版本号部分 注意：配置集成后，执行安装命令时要先安装父工程。 聚合&emsp;&emsp;如果我们写了很多模块，在我们安装的时候就需要我们一个个安装，这样就整加了工作量，而聚合可以解决这个问题。 聚合作用：一键安装各个模块工程。 配置方式：在一个“总的聚合工程”中配置各个参与聚合的模块（比如说在父工程配置） 1234567&lt;!-- 配置聚合 --&gt;&lt;modules&gt; &lt;!-- 配置一起安装的各个工程 --&gt; &lt;module&gt;../Hello&lt;/module&gt; &lt;module&gt;../HelloFriend&lt;/module&gt; &lt;module&gt;../MakeFriends&lt;/module&gt;&lt;/modules&gt; 使用方式：在聚合工程的pom.xml 上点右键-&gt;run as-&gt;maven install","tags":[{"name":"Maven","slug":"Maven","permalink":"https://Xiezhenyu98.github.io/tags/Maven/"}]},{"title":"【快速上手】Maven的使用","date":"2019-10-27T05:02:36.618Z","path":"2019/10/27/[快速上手]Maven的使用/","text":"首先需要了解一下为什么要使用Maven 一个项目就是一个工程&emsp;&emsp;如果一个项目非常庞大，就不适合继续使用Package来划分模块。最好是每一个模块对应一个工程，利于分工协作。而利用Maven就可以将一个项目拆分为多个工程。 项目中需要jar包必须手动“复制”、“粘贴”到WEB-INF/lib目录下&emsp;&emsp;带来的问题：同样的jar包文件重复出现在不同的项目工程中，一方面浪费存储空间，另外也让工程比较臃肿。借助Maven，可以将jar包仅仅保存在“仓库”中，有需要使用的工程“引用”这个文件接口，并不需要真的把jar包复制过来。 jar包需要别人替我们准备好，或者到官网下载&emsp;&emsp;不同技术的官网提供的jar包下载方式是不同的，有些jar包我们进不去别人的官网，只能从第三方网站下载，而第三方的网站的jar包可能是不规范的。而借助于Maven我们可以以一种规范的方式下载jar包。因为所有知名的jar包都会以规范的方式下载jar包，内容可靠。 一个jar包依赖的其它jar包需要自己手动加入工程中&emsp;&emsp;有些jar包会依赖很多个jar包，而被依赖的jar包也可能依赖其它jar包，这些依赖关系我们必须记下来，这样就会使程序员整加学习成本。不然我们把不完整的jar包导入到工程中，将会出现报错。而使用Maven将会自动把依赖的jar包导入进来。我们来了解一下什么是Maven&emsp;&emsp;Maven是一款服务于java平台的自动化构建工具。构建就是以java源文件、框架配置文件、JSP、HTML、图片等资源为原材料，去生产一个可运行的项目的过程。这个过程主要分为编译、部署、搭建。构建的各个环节：[1]清理：将以前编译得到的旧的class字节码文件删除，为下一次编译做准备[2]编译：将Java源程序编译为字节码文件。[3]测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。[4]报告：将每一次测试后以标准的格式记录和展示测试结果。[5]打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java工程对应jar包，Web工程对象war包。[6]安装：在Maven环境下特指将打包的结果——Jar包或War包安装到本地仓库中。[7]部署：将打包的结果部署到远程仓库或将war包部署到服务器上运行。如何使用和创建一个Maven工程 安装jdk、配置java环境变量 下载并解压Maven核心程序压缩包 【点击下载http://maven.apache.org/download.cgi】 配置Maven环境变量MAVEN_HOME：解压Maven核心程序的路径\\apache-maven-3.6.1-binpath：%MAVEN_HOME%\\bin 验证Maven是否配置成功（在控制台输入mvn -v） 创建Maven工程&emsp;&emsp;在创建之前必须要知道Maven所约定的Maven目录结构，我们创建这个工程必须按照这个约定的结构去创建，因为我们写的代码最终是要交给Maven去处理的，比如说java源代码编译，只有按照这个Maven约定好的目录去创建，Maven才知道去哪找java源代码编译。Maven的目录结构：HelloMaven：根目录（工程名）src：源码pom.xml：Maven工程的核心配置文件main：存放主程序test：存放测试程序java：存放java源文件resources：存放框架或者其它工具的配置文件 编写Maven项目[1]编写pom.xml文件1234567891011121314151617181920212223&lt;?xml version=\"1.0\" ?&gt;&lt;project xmlns = \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;!-- 模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt; &lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt; &lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt; &lt;artifactId&gt;HelloMaven&lt;/artifactId&gt; &lt;!-- 版本号 --&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!-- 依赖的jar包 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; [2]编写主程序代码&emsp;&emsp;在src/main/java/com/xiezhenyu/maven（一般以公司域名倒写的方式命名）目录下新建文件HelloMaven.java，其内容如下 1234567package com.xiezhenyu.maven;public class HelloMaven&#123; public String sayHelloMaven(String name)&#123; System.out.println(\"HelloMaven!\"); return \"Hello \"+name+\"!\"; &#125;&#125; [3]编写测试代码&emsp;&emsp;在src/test/java/com/xiezhenyu/maven（一般以公司域名倒写的方式命名）目录下新建文件HelloMavenTest.java，其内容如下 1234567891011package com.xiezhenyu.maven;import org.junit.Test;import static junit.framework.Assert.*;public class HelloMavenTest&#123; @Test public void testHelloMaven()&#123; HelloMaven helloMaven = new HelloMaven(); String results = helloMaven.sayHelloMaven(\"xiezhenyu\"); assertEquals(\"Hello xiezhenyu!\",results); &#125;&#125; 以上一个简单的Maven项目就搭建起来了。 如何测试运行一个Maven项目在测试之前先要了解一下Maven的常用命令 注意：执行与构建过程有关的Maven命令的时候，必须进入pom.xml所在的目录 常用命令[1]mvn clean : 清理[2]mvn compile : 编译主程序[3]mvn test-compile : 编译测试程序[4]mvn test : 执行测试[5]mvn package : 打包[6]mvn install ： 安装[7]mvn site ：生成站点 在编译之前，我们如果是第一次使用maven我们本地仓库中没有项目所需的jar包，我们需要联网[1]Maven 的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须有特定的插件来完成。而插件本身不包含在Maven核心程序中。[2]当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。[3]本地仓库的默认位置：[系统登陆用户的家目录] \\ .m2\\repository[4]Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载。[5]如果此时无法连接外网，则构建失败。[6]修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找插件&emsp;①找到Maven解压目录\\conf\\settings.xml&emsp;②在setting.xml 文件中找到 localRepository 标签&emsp;③将 &lt; localRepository&gt;/path/to/local/repo&lt; /localRepository&gt;从注释中取出&emsp;④将标签体内容修改为自定义的Maven仓库目录 执行mvn compile命令（cmd必须进入pom.xml所在的目录）&emsp;&emsp;可以发现我们在目录中生成了target目录，里面有classes，里面生成的是主程序编译后的结果（其中生成的maven-status目录是maven的状态，保存一些创建和输出的信息等） 执行mvn test-compile命令可以发现target目录新加了test-class目录，里面，里面生成的是测试程序编译后的结果 执行mvn test命令可以发现target目录新加了surefire-reports目录，里面生成的是测试报告相关的文件，控制台输出如下可以发现，我们的测试运行已经成功了。 执行mvn package命令&emsp;&emsp;可以发现，在target目录新生成了一个目录和一个jar包，maven-archiver目录存放的是这个jar包的基本信息，jar包是主程序编译结果打成的一个jar包，将jar包解压，我们可以看一下jar包的内容&emsp;&emsp;我们可以发现打包出来的并没有测试程序的内容，只有主程序的内容，里面也并没有这个工程所依赖的jar包，这样我们的工程就不会显得臃肿，如果我们将我们开发的这个模块导入到其它工程中就会方便很多。我们再看一下执行mvn package命令控制台的输出可以发现我们在执行打包命令时它也执行了测试，这就涉及到Maven的生命周期了。（与本篇无关，详情查看下一篇Maven） 以上就是如何快速使用Maven的方法","tags":[{"name":"Maven","slug":"Maven","permalink":"https://Xiezhenyu98.github.io/tags/Maven/"}]},{"title":"学习Python的第一步-卸载Python","date":"2019-10-27T02:55:14.363Z","path":"2019/10/27/学习Python的第一步-卸载Python/","text":"&emsp;&emsp;相信很多人都已经听说过或者学过Python了，但是有的人没有坚持下去，过了几个月一年或者更久之后Python的版本发生了很大的变化，我们学习当然要学习最新的内容。而要学习最新的内容就必须把电脑里已经安装过的Python旧版本卸载掉（没有安装过的当我没说） 检查是否安装PythonWin+R→输入cmd→打开→在cmd输入python→回车如果出现这个界面就证明你已经安装了Python，如果没有安装，是windows10系统的话会自动弹出python获取界面或者会出现 12'python' 不是内部或外部命令，也不是可运行的程序或批处理文件。 卸载Python进入电脑的控制面版。找到Python 3.7.3(或者不是Python的其它不是最新的版本)和Python Launcher，并把这两个卸载掉。 Python卸载成功","tags":[{"name":"Python","slug":"Python","permalink":"https://Xiezhenyu98.github.io/tags/Python/"}]},{"title":"Spring的模块","date":"2019-10-20T09:48:48.999Z","path":"2019/10/20/Spring的模块/","text":"Spring下载：http://repo.spring.io/release/org/springframework/spring/ Test：Spring的单元测试模块spring-test-5.0.8.RELEASE.jar Core Container：核心容器（IOC）；黑色代表这部分的功能由哪些jar包组成，要使用这个部分的完整功能们这些jar都需要导入：spring-beans-5.0.8.RELEASE.jarspring-core-5.0.8.RELEASE.jarspring-context-5.0.8.RELEASE.jarspring-expression-5.0.8.RELEASE.jar AOP+Aspects：面向切面编程模块spring-aop-5.0.8.RELEASE.jarspring-aspects-5.0.8.RELEASE.jar Data Access/Integration：数据访问（Spring访问数据库的模块）spring-jdbc-5.0.8.RELEASE.jarspring-orm-5.0.8.RELEASE.jar（Object Relation Mapping 对象关系映射）spring-oxm-5.0.8.RELEASE.jar（x表示xml）spring-jms-5.0.8.RELEASE.jarspring-tx-5.0.8.RELEASE.jar Web：Spring开发web应用的模块spring-websocket-5.0.8.RELEASE.jarspring-web-5.0.8.RELEASE.jar（和原生的web相关的(servlet)）spring-webmvc-5.0.8.RELEASE.jar（开发web应用的组件集成） Instrumentation：该模块提供了为JVM添加代理的功能，该模块包含spring-instrument，spring-instrument-tomcat组件，使用较少，不必过分关注。 用哪个模块导哪个包","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Mybatis和Spring整合","date":"2019-10-20T06:20:57.133Z","path":"2019/10/20/Mybatis和Spring整合/","text":"1、Mybatis和Spring框架整合1.1、导入所需的包我所需要的包是 1.2、创建Mybatis主配置文件sqlMapConfig.xml1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 类型别名,推荐使用package包的形式 --&gt; &lt;typeAliases&gt; &lt;!-- 扫描该包主包及子包下的所有类都起别名,别名为类名,而且大小写不敏感,推荐使用小写 --&gt; &lt;package name=\"com.xiezhenyu.bean\"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 1.3、创建Spring主配置文件applicationContext.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd \"&gt; &lt;!-- 读取db.properties --&gt; &lt;context:property-placeholder location=\"db.properties\"/&gt; &lt;!-- 配置c3p0连接池 --&gt; &lt;bean name=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.jdbcUrl&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.user&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 配置MyBatis sqlSessionFactory --&gt; &lt;bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 配置数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!-- 告诉spring mybatis的核心配置文件 --&gt; &lt;property name=\"configLocation\" value=\"classpath:sqlMapConfig.xml\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.4、创建log4j.properties和db.properties123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 1234jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql://localhost:3306/ssm_mybatis?serverTimezone=Asia/Shanghaijdbc.user=rootjdbc.password=p123456 1.5、测试12345public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); SqlSessionFactoryBean bean = ac.getBean(SqlSessionFactoryBean.class); System.out.println(bean);&#125; 1.6、结果1org.mybatis.spring.SqlSessionFactoryBean@708f5957 输出以上结果代表已经成功！ 2、Dao式开发在传统dao层上使用MyBatis和spring整合开发 2.1、创建实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.xiezhenyu.bean;import java.util.Date;public class User &#123; private Integer u_id; private String u_username; private String u_password; private String u_sex; private Date u_createTime; private Integer u_cid; public Integer getU_id() &#123; return u_id; &#125; public void setU_id(Integer u_id) &#123; this.u_id = u_id; &#125; public String getU_username() &#123; return u_username; &#125; public void setU_username(String u_username) &#123; this.u_username = u_username; &#125; public String getU_password() &#123; return u_password; &#125; public void setU_password(String u_password) &#123; this.u_password = u_password; &#125; public String getU_sex() &#123; return u_sex; &#125; public void setU_sex(String u_sex) &#123; this.u_sex = u_sex; &#125; public Date getU_createTime() &#123; return u_createTime; &#125; public void setU_createTime(Date u_createTime) &#123; this.u_createTime = u_createTime; &#125; public Integer getU_cid() &#123; return u_cid; &#125; public void setU_cid(Integer u_cid) &#123; this.u_cid = u_cid; &#125; @Override public String toString() &#123; return \"User [u_id=\" + u_id + \", u_username=\" + u_username + \", u_password=\" + u_password + \", u_sex=\" + u_sex + \", u_createTime=\" + u_createTime + \", u_cid=\" + u_cid + \"]\"; &#125;&#125; 2.2、书写Dao和DaoImpldao 123456package com.xiezhenyu.dao;import com.xiezhenyu.bean.User;public interface UserDao &#123; //根据id查询用户 public User getUserById(Integer id);&#125; &emsp;&emsp;daoImpl继承SqlSessionDaoSupport，可以通过父类的getSqlSession()方法直接获得session，而父类中的sqlSessionFactory可以通过spring注入。 123456789101112package com.xiezhenyu.dao;import org.apache.ibatis.session.SqlSession;import org.mybatis.spring.support.SqlSessionDaoSupport;import com.xiezhenyu.bean.User;public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123; @Override public User getUserById(Integer id) &#123; //通过父类的方法直接获得session SqlSession session = getSqlSession(); return session.selectOne(\"UserMapper.selectUserById\",id); &#125;&#125; 2.3、配置spring配置文件applicationContext.xml将工厂注入dao的父类 sqlSessionFactory属性中 1234&lt;!-- 将工厂注入dao的父类 sqlSessionFactory属性中 --&gt;&lt;bean id=\"userDaoImpl\" class=\"com.xiezhenyu.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactoryBean\"/&gt;&lt;/bean&gt; 2.4、配置mybatis配置文件123&lt;mappers&gt; &lt;mapper resource=\"com/xiezhenyu/mapper/UserMapper.xml\"/&gt;&lt;/mappers&gt; 2.5、测试1234567@Testpublic void DaoTest() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDaoImpl userDao = ac.getBean(UserDaoImpl.class); User user = userDao.getUserById(1); System.out.println(user);&#125; 2.6、结果1User [u_id=1, u_username=老王, u_password=123, u_sex=1, u_createTime=null, u_cid=1] 3、Mapper动态代理开发3.1、创建实体类该过程和上面dao层开发的实体类一致，就不给出代码。 3.2、创建UserMapper接口，修改UserMapper.xml将UserMapper.xml的namespace修改为UserMapper接口的路径 123public interface UserMapper &#123; public User selectUserById(Integer id);&#125; 123456&lt;mapper namespace=\"com.xiezhenyu.mapper.UserMapper\"&gt; &lt;!-- 查找用户 --&gt; &lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"user\"&gt; select * from user where u_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 3.3、让sqlMapConfig.xml以包的形式扫描mapper.xml123&lt;mappers&gt; &lt;package name=\"com.xiezhenyu.mapper\"/&gt;&lt;/mappers&gt; 3.4、配置spring配置文件applicationContext.xml&emsp;&emsp;将MapperFactoryBean交给Spring管理。MapperFactoryBean中拥有属性mapperInterface可以配置mapper的接口，而MapperFactoryBean是继承SqlSessionDaoSupport，使用可以注入sqlSessionFactory。 1234567&lt;!-- Mapper动态代理开发 --&gt;&lt;bean id=\"UserMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactoryBean\"/&gt; &lt;!-- 配置接口 --&gt; &lt;property name=\"mapperInterface\" value=\"com.xiezhenyu.mapper.UserMapper\"/&gt;&lt;/bean&gt; 3.5、编写测试方法获取mapper的方法可以用传递applicationContext.xml中id的方法，也可以直接传递接口。 123456789@Testpublic void Test1() &#123; //获取主配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //UserMapper mapper = (UserMapper)ac.getBean(\"UserMapper\"); UserMapper mapper = ac.getBean(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user);&#125; 3.6、结果1User [u_id=1, u_username=老王, u_password=123, u_sex=1, u_createTime=null, u_cid=1] 4、Mapper动态扫描开发(推荐使用)&emsp;&emsp;在mapper动态扫描开发中只需要配置以下即可，他会自动扫描某个包下的全部mapper，它不用手动注入sqlSessionFactory。 1234&lt;!-- mapper动态扫描开发 --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.xiezhenyu.mapper\"/&gt;&lt;/bean&gt;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"MyBatis动态sql：更方便的拼接sql语句","date":"2019-10-19T08:06:18.167Z","path":"2019/10/19/MyBatis动态sql：更方便的拼接sql语句/","text":"if标签&emsp;&emsp;if标签是最常用的判断语句，相当于java中的if语句。在MyBatis中使用if标签，我们先看一下不使用if标签的时候会有什么情况。 12345678910&lt;!-- 多条件查询 用过用户对象中的条件查询用户列表 --&gt;&lt;select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\"&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍id --&gt; select * from user where u_sex = #&#123;u_sex&#125; and u_username like \"%\"#&#123;u_username&#125;\"%\" and u_cid = #&#123;u_cid&#125;&lt;/select&gt; &emsp;&emsp;在上面的案例中，多条件查询用户性别u_sex，模糊查询用户名u_username，查询用户国籍c_id，返回一个集合。我们在使用条sql语句的时候，我们必须把所有的参数传过来，如果出现我只有查询用户性别u_sex，模糊查询用户名u_username的情况，我们又必须再写一条sql语句。而使用了if标签之后可以解决这个问题。 12345678910111213141516&lt;!-- 多条件查询 用过用户对象中的条件查询用户列表 --&gt;&lt;select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\"&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍id --&gt; select * from user where &lt;if test=\"u_sex!=null\"&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt;';l., &lt;if test=\"u_username!=null\"&gt; and u_username like \"%\"#&#123;u_username&#125;\"%\" &lt;/if&gt; &lt;if test=\"u_cid!=null\"&gt; and u_cid = #&#123;u_cid&#125; &lt;/if&gt;&lt;/select&gt; &emsp;&emsp;在上面的案例中，当参数u_username传递进映射器时，如果参数不为空则再sql语句上拼接上对用户名的模糊查询，如果为空，则不拼接。这样我们就可以不用写多条sql语句了。但是，如果我们u_sex为空u_username不为空，在sql语句拼接时就会出现select * from user where and u_username like &quot;%&quot;#{u_username}&quot;%&quot;的错误语法格式。接下来的where标签可以解决这个问题。 where标签&emsp;&emsp;where标签，当标签内的条件成立时，才会加入where这个SQL关键字到组装的SQL里面，否则就不加入，where还可以去掉一些特殊的SQL语法，比如说and、or，它去掉的时前缀的and和or。 12345678910111213141516&lt;select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\"&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍id --&gt; select * from user &lt;where&gt; &lt;if test=\"u_sex!=null\"&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt; &lt;if test=\"u_username!=null\"&gt; and u_username like \"%\"#&#123;u_username&#125;\"%\" &lt;/if&gt; &lt;if test=\"u_cid!=null\"&gt; and u_cid = #&#123;u_cid&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; &emsp;&emsp;在上面的案例中，如果and全写在sql拼接语句的后面，当c_cid==null的话，使用where语句就去不掉结尾的and。接下来的trim标签可以解决这个问题。 trim标签&emsp;&emsp;trim标签是要去掉一些特殊的字符串，它又四个属性，prefix、suffix、prefixOverrides、suffixOverrides。下面通过一个例子说一下这四个属性分别代表的意义。 12345678910111213141516&lt;select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\"&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍id --&gt; select * from user &lt;trim prefix=\"where\" suffixOverrides=\"and\"&gt; &lt;if test=\"u_sex!=null\"&gt; u_sex = #&#123;u_sex&#125; and &lt;/if&gt; &lt;if test=\"u_username!=null\"&gt; u_username like \"%\"#&#123;u_username&#125;\"%\" and &lt;/if&gt; &lt;if test=\"u_cid!=null\"&gt; u_cid = #&#123;u_cid&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; &emsp;&emsp;prefix=”where”，的意思是在trim头标签加上where之后再拼接上trim内的SQL语句，如果将其换成suffix=”where”的话，就会在trim内的的SQL语句后面接上where，显然在上面的案例中是不对的。&emsp;&emsp;suffixOverrides=”and”，的意思是去掉拼接语句尾部一些不合法的一些特殊字符，比如说and、or，如果将其换成prefixOverrides=”and”的话，就是去掉拼接语句开头一些不合法的的特殊字符。 set标签set标签在跟新表属性的时候，如果遇上不合法的逗号，会将其去掉。例如： 123456789101112131415&lt;update id=\"updateSetUser\" parameterType=\"User\"&gt; &lt;!-- 修改用户名和用户密码以及性别以id为限制 --&gt; update user set &lt;if test=\"u_username!=null and u_username!=''\"&gt; u_username = #&#123;u_username&#125;, &lt;/if&gt; &lt;if test=\"u_password!=null and u_password!=''\"&gt; u_password = #&#123;u_password&#125;, &lt;/if&gt; &lt;if test=\"u_sex!=null and u_sex!=''\"&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt; where u_id = #&#123;u_id&#125;&lt;/update&gt; &emsp;&emsp;在上面这个案例中，如果if语句最后一个不成立而它上一个if语句成立的时候，在拼接SQL语句的时候，就会出现SQL语法的错误，而使用set标签可以很好的解决这个错误。下面是使用set标签的案例。 12345678910111213141516&lt;update id=\"updateSetUser\" parameterType=\"User\"&gt; &lt;!-- 修改用户名和用户密码以及性别以id为限制 --&gt; update user &lt;set&gt; &lt;if test=\"u_username!=null and u_username!=''\"&gt; u_username = #&#123;u_username&#125;, &lt;/if&gt; &lt;if test=\"u_password!=null and u_password!=''\"&gt; u_password = #&#123;u_password&#125;, &lt;/if&gt; &lt;if test=\"u_sex!=null and u_sex!=''\"&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt; &lt;/set&gt; where u_id = #&#123;u_id&#125;&lt;/update&gt; &emsp;&emsp;如果最后一个条件12345678910111213### foreach标签&amp;emsp;&amp;emsp;foreach标签是一个循环语句，它的作用是遍历集合，它能够很好地支持数组和List、Set接口的集合，对此提供遍历的功能。&amp;emsp;&amp;emsp;比如说，我要查找数据库中id为1、3、5的用户，SQL语句应该这样写```select * from user where u_id in(1,3,5)```只能固定查3个id的用户，如果要查4个，必须再写一条sql语句，而foreach可以很好的解决这个问题。```xml&lt;select id=&quot;selectUserListByIds&quot; resultType=&quot;User&quot;&gt; select * from user where u_id in &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; collection表示传入的是数组还是集合是数组用array，是集合用list、set等，但如果是包装类的话，则需要使用包装类里面数组或集合的字段名。 item表示用什么表示数据或者集合里面的数，即循环中当前的元素。 open、close表示用什么元素把集合两端包起来。 separate表示用什么分隔。 index表示当前元素在集合中的位置。choose、when、otherwise标签&emsp;&emsp;choose、when、otherwise标签类似于java里面的wsitch…case…default…功能语句。下面是一个简单的案例。1234567891011121314151617&lt;select id=\"selectUserByUser\" parameterType=\"com.xiezhenyu.bean.User\" resultType=\"com.xiezhenyu.bean.User\"&gt; select * from user &lt;where&gt; &lt;choose&gt; &lt;when test=\"u_id!=null\"&gt; and u_id=#&#123;u_id&#125; &lt;/when&gt; &lt;when test=\"u_username!=null\"&gt; and u_username=#&#123;u_username&#125; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; &emsp;&emsp;当传过来的user的id不为空时，按照id为条件去查找，当传过来的id为空而username不为空时按照username去查找，当两个都为空时，查找不到。 sql标签&emsp;&emsp;在写sql语句的时候，有很多重复的语句片段，比如说，* from user```这句话就被重复了很多次，而使用sql标签可以将这些重复的字段提出来，什么时候用就引入一下就可以了。12345678910111213```xml&lt;sql id=&quot;selectUser&quot;&gt; select * from user&lt;/sql&gt;&lt;select id=&quot;selectUserListByIds&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; where u_id in &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; index=&quot;2&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; bind标签&emsp;&emsp;bind标签的作用是用过ONGL表达式去定义一个上下文变量，这样更方便使用，例如在进行模糊查询时，MySQL需要用到%和参数连接。定义接口方法 1public List&lt;User&gt; selectUserLikeUsername(@Param(\"str\")String str); 定义映射文件和一个新的变量，然后执行模糊查询 1234567&lt;select id=\"selectUserLikeUsername\" parameterType=\"string\" resultType=\"com.xiezhenyu.bean.User\"&gt; &lt;bind name=\"pattern\" value=\"'%'+str+'%'\"/&gt; select * from user where u_username like #&#123;pattern&#125;&lt;/select&gt; 测试方法 1234567891011121314151617@Testpublic void Test11() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; list = mapper.selectUserLikeUsername(\"王\"); for(User u : list) &#123; System.out.println(u); &#125;&#125;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"MyBatis的输入和输出映射","date":"2019-10-17T11:11:41.165Z","path":"2019/10/17/MyBatis的输入和输出映射/","text":"&emsp;&emsp;MyBatis的输入和输出映射，通过parameterType完成输入映射，通过resultType和resultMap完成输出映射。 1、输入映射parameterType&emsp;&emsp;输入映射中，可以给出类的全名，也可以给出类的别名，但是别名必须是MyBatis内部定义或者自定义的，可以选择JavaBean、Map等简单的参数类型传递给SQL。 1.1基本类型&emsp;&emsp;基本类型可以使用别名的方式，如果想要查看常见的 Java 类型内建的相应的类型别名，点击这里，它们都是不区分大小写的。(具体的测试方法可以看我上一篇写的博客) 123&lt;delete id=\"deleteUserById\" parameterType=\"Integer\"&gt; delete from user where u_id = #&#123;id&#125;&lt;/delete&gt; 1.2自定义对象&emsp;&emsp;输入类型还可以为自定义的对象，在书写Sql语句获取数值的时候，可以使用”#{对象字段名}”的方式取得数值。以下就是通过输入一个自定义对象的方式将参数传递给SQL，实现修改指定用户名的功能。(具体的测试方法可以看我上一篇写的博客) 123&lt;update id=\"updateUser\" parameterType=\"io.xiezhenyu98.bean.User\"&gt; update user set u_username = #&#123;u_username&#125; where u_id=#&#123;u_id&#125;&lt;/update&gt; 1.3自定义包装类&emsp;&emsp;输入类型还可以为自定义的包装类，在书写SQL语句获取数值的时候，可以使用”#{包装类字段.被包装类字段}”的方法获得数值。UserVo.java包装类 123456789101112public class UserVo &#123; //包装类 //需要全部的user对象信息 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; //需要表B的id name属性&#125; UserMapper.java接口 12//通过UserVo id查询一个用户public User selectUserByUserVoId(UserVo vo); UserMapper.xml映射文件 1234&lt;!-- 查找用户UserVo --&gt;&lt;select id=\"selectUserByUserVoId\" parameterType=\"UserVo\" resultType=\"user\"&gt; select * from user where u_id = #&#123;user.u_id&#125;&lt;/select&gt; 测试方法 12345678910111213141516171819@Testpublic void Test3() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserVo vo = new UserVo(); User user = new User(); user.setU_id(1); vo.setUser(user); User resultUser = mapper.selectUserByUserVoId(vo); System.out.println(resultUser);&#125; 结果 1User [u_id=1, u_username=老王, u_password=123, u_sex=1, u_createTime=null, u_cid=1] 2、输出映射resultType、resultMap2.1resultType&emsp;&emsp;resultType，定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射，数据库中表的字段名和JavaBean中的字段名对应，或定义为int、double、float、map等参数，也可以使用别名，但是要符合别名的规范，且不能和resultMap同时使用。resultType是常用的参数之一，比如统计总条数时可以把它设置为int。 2.1.1基本类型&emsp;&emsp;输出映射的基本类型和输入映射的基本类型一样，可以使用别名的方式，如果想要查看常见的 Java 类型内建的相应的类型别名，点击这里，它们都是不区分大小写的。以下是查询用户总数返回Integer的返回值。 1234&lt;!-- 查询用户总条数 --&gt;&lt;select id=\"selectUserCount\" resultType=\"Integer\"&gt; select count(*) from user&lt;/select&gt; 2.1.2自定义类型输出映射的自定义类型(具体的测试方法可以看我上一篇写的博客) 1234&lt;!-- 查找用户 --&gt;&lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"user\"&gt; select * from user where u_id = #&#123;id&#125;&lt;/select&gt; 2.2resultMap&emsp;&emsp;resultMap，它是映射集的引用，将执行强大的映射功能。可以使用resultType、resultMap的其中一个，resultMap能提供自定义映射规则的机会，数据库中表的字段名和JavaBean中的字段名不对应，则需要添加自定义映射。resultMap是MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler等等。 2.2.1Bean对象字段与数据库中字段不匹配创建Country实例，实例中Country的id与数据库中的不匹配(数据库中的为c_id) 123456789101112131415161718192021222324252627public class Country &#123; private Integer id; private String c_countryname; private String c_capital; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getC_countryname() &#123; return c_countryname; &#125; public void setC_countryname(String c_countryname) &#123; this.c_countryname = c_countryname; &#125; public String getC_capital() &#123; return c_capital; &#125; public void setC_capital(String c_capital) &#123; this.c_capital = c_capital; &#125; @Override public String toString() &#123; return \"Country [id=\" + id + \", c_countryname=\" + c_countryname + \", c_capital=\" + c_capital + \"]\"; &#125;&#125; 创建CountryMapper接口 123456import java.util.List;import com.siliedu.bean.Country;public interface CountryMapper &#123; //查询所有 public List&lt;Country&gt; selectAll();&#125; 创建CountryMapper映射文件 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.siliedu.mapper.CountryMapper\"&gt; &lt;!-- 查询所有 --&gt; &lt;!-- country为resultMap起一个名字 --&gt; &lt;resultMap type=\"Country\" id=\"country\"&gt; &lt;!-- id为javaBean中的字段，c_id为数据库中的字段，两个字段不匹配 --&gt; &lt;result property=\"id\" column=\"c_id\"/&gt; &lt;/resultMap&gt; &lt;!-- country为使用名为country的resultMap --&gt; &lt;select id=\"selectAll\" resultMap=\"country\"&gt; select * from country &lt;/select&gt;&lt;/mapper&gt; 测试方法 1234567891011121314151617@Testpublic void Test5() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); CountryMapper mapper = session.getMapper(CountryMapper.class); List&lt;Country&gt; list = mapper.selectAll(); for(Country c : list) &#123; System.out.println(c); &#125;&#125; 结果 1234Country [id=1, c_countryname=中国, c_capital=北京]Country [id=3, c_countryname=美国, c_capital=华盛顿]Country [id=4, c_countryname=英国, c_capital=伦敦]Country [id=5, c_countryname=日本, c_capital=东京] 在这里如果我们将resultMap改成resultType的话，id将查询不到。 123&lt;select id=\"selectAll\" resultType=\"country\"&gt; select * from country&lt;/select&gt; 结果 1234Country [id=null, c_countryname=中国, c_capital=北京]Country [id=null, c_countryname=美国, c_capital=华盛顿]Country [id=null, c_countryname=英国, c_capital=伦敦]Country [id=null, c_countryname=日本, c_capital=东京] 2.2.2关联查询2.2.2.1一对一&emsp;&emsp;一个用户只对应一个国家。(在单表查询的时候，javaBean对象的字段和数据库字段一致的时候可以省略但在多表查询的时候，我们要查询什么字段，就必须把什么字段列在映射文件上)UserVo包装类 1234567891011121314public class UserVo extends User&#123; private Country country; public Country getCountry() &#123; return country; &#125; public void setCountry(Country country) &#123; this.country = country; &#125; @Override public String toString() &#123; return \"UserVo [country=\" + country + \", getU_id()=\" + getU_id() + \", getU_username()=\" + getU_username() + \", getU_sex()=\" + getU_sex() + \"]\"; &#125;&#125; UserMapper接口 12//查询所有用户的包装类public List&lt;UserVo&gt; selectAllUserVo(); UserMapper.xml映射文件 123456789101112131415&lt;!-- 查询所有用户的包装类 --&gt;&lt;resultMap type=\"UserVo\" id=\"uservolist\"&gt; &lt;!-- 在单表查询的时候，javaBean对象的字段和数据库字段一致的时候可以省略 但在多表查询的时候，我们要查询什么字段，就必须把什么字段列上去 --&gt; &lt;id property=\"u_id\" column=\"u_id\"/&gt; &lt;id property=\"u_username\" column=\"u_username\"/&gt; &lt;id property=\"u_sex\" column=\"u_sex\"/&gt; &lt;association property=\"country\" javaType=\"Country\"&gt; &lt;result property=\"id\" column=\"c_id\"/&gt; &lt;result property=\"c_countryname\" column=\"c_countryname\"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"selectAllUserVo\" resultMap=\"uservolist\"&gt; select u.u_id,u.u_username,u.u_sex,c.c_id,c.c_countryname from user u left join country c on u.u_cid=c.c_id&lt;/select&gt; 测试方法 1234567891011121314151617@Testpublic void Test6() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;UserVo&gt; list = mapper.selectAllUserVo(); for(UserVo userVo : list) &#123; System.out.println(userVo); &#125;&#125; 结果：查询到了所有的用户，以及用户的国家，没有国家的用户也查询到了 123456789101112UserVo [country=Country [id=1, c_countryname=中国, c_capital=null], getU_id()=1, getU_username()=老王, getU_sex()=1]UserVo [country=Country [id=3, c_countryname=美国, c_capital=null], getU_id()=2, getU_username()=jack, getU_sex()=1]UserVo [country=Country [id=3, c_countryname=美国, c_capital=null], getU_id()=3, getU_username()=alice, getU_sex()=0]UserVo [country=Country [id=1, c_countryname=中国, c_capital=null], getU_id()=4, getU_username()=王司机, getU_sex()=1]UserVo [country=Country [id=4, c_countryname=英国, c_capital=null], getU_id()=5, getU_username()=anna, getU_sex()=0]UserVo [country=Country [id=1, c_countryname=中国, c_capital=null], getU_id()=6, getU_username()=李师傅, getU_sex()=1]UserVo [country=Country [id=5, c_countryname=日本, c_capital=null], getU_id()=7, getU_username()=漩涡鸣人, getU_sex()=1]UserVo [country=Country [id=5, c_countryname=日本, c_capital=null], getU_id()=8, getU_username()=娜美, getU_sex()=0]UserVo [country=Country [id=1, c_countryname=中国, c_capital=null], getU_id()=9, getU_username()=王五, getU_sex()=1]UserVo [country=null, getU_id()=10, getU_username()=老赵, getU_sex()=null]UserVo [country=null, getU_id()=11, getU_username()=老孙, getU_sex()=null]UserVo [country=null, getU_id()=12, getU_username()=98k, getU_sex()=null] 2.2.2.1一对多一个国家有多个用户。CountryVo包装类 123456789101112131415import java.util.List;public class CountryVo extends Country&#123; //需要维护一个User集合 private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() &#123; return userList; &#125; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; @Override public String toString() &#123; return \"CountryVo [userList=\" + userList + \", toString()=\" + super.toString() + \"]\"; &#125;&#125; CountryMapper接口 12//查询所有的CountryVopublic List&lt;CountryVo&gt; selectAllCountryVo(); CountryMapper映射文件 1234567891011121314151617181920212223&lt;!-- 查询所有的CountryVo --&gt;&lt;resultMap type=\"CountryVo\" id=\"countryvo\"&gt; &lt;id property=\"id\" column=\"c_id\"/&gt; &lt;result property=\"c_countryname\" column=\"c_countryname\"/&gt; &lt;result property=\"c_capital\" column=\"c_capital\"/&gt; &lt;!-- 一对多关系 --&gt; &lt;collection property=\"userList\" ofType=\"User\"&gt; &lt;id property=\"u_id\" column=\"u_id\"/&gt; &lt;result property=\"u_username\" column=\"u_username\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"selectAllCountryVo\" resultMap=\"countryvo\"&gt; select c.c_id, c.c_countryname, c.c_capital, u.u_id, u.u_username from country c left join user u on u.u_cid=c.c_id&lt;/select&gt; 测试方法 1234567891011121314151617@Testpublic void Test7() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); CountryMapper mapper = session.getMapper(CountryMapper.class); List&lt;CountryVo&gt; list = mapper.selectAllCountryVo(); for(CountryVo countryVo : list) &#123; System.out.println(countryVo); &#125;&#125; 结果：查询出了，一个国家有几个用户 1234CountryVo [userList=[User [u_id=1, u_username=老王, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=4, u_username=王司机, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=6, u_username=李师傅, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=9, u_username=王五, u_password=null, u_sex=null, u_createTime=null, u_cid=null]], toString()=Country [id=1, c_countryname=中国, c_capital=北京]]CountryVo [userList=[User [u_id=2, u_username=jack, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=3, u_username=alice, u_password=null, u_sex=null, u_createTime=null, u_cid=null]], toString()=Country [id=3, c_countryname=美国, c_capital=华盛顿]]CountryVo [userList=[User [u_id=5, u_username=anna, u_password=null, u_sex=null, u_createTime=null, u_cid=null]], toString()=Country [id=4, c_countryname=英国, c_capital=伦敦]]CountryVo [userList=[User [u_id=7, u_username=漩涡鸣人, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=8, u_username=娜美, u_password=null, u_sex=null, u_createTime=null, u_cid=null]], toString()=Country [id=5, c_countryname=日本, c_capital=东京]]","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"MaBatis的Mapper动态代理开发","date":"2019-10-17T03:53:03.885Z","path":"2019/10/17/MaBatis的Mapper动态代理开发/","text":"1 SqlSession的介绍&emsp;&emsp;SqlSession中封装了对数据库的操作，比如：更新、删除、查询等。通过SqlSessionFactory创建SqlSession，而SqlSessionFactory是由SqlSessionFactoryBuilder来创建的。 1.1 SqlSessionFactoryBuilderSqlSessionFactoryBuilder的作用是创建SqlSessionFacoty，SqlSessionFacoty创建了之后就不需要SqlSessionFactoryBuilder了，由于SqlSession是通过SqlSessionFactory生产，所以一般是将SqlSessionFactoryBuilder当成一个工具类使用，需要创建sqlSessionFactory时就new一个 SqlSessionFactoryBuilder，和Spring整合后由Spring以单例方式管理sqlSessionFactory。 1.2 SqlSessionFactorySqlSession是一个面向用户的接口， sqlSession中定义了数据库操作，默认使用DefaultSqlSession实现类。 2 MaBatis对Dao层的开发方式2.1 不使用Mapper动态代理开发编写dao层接口 1234public interface UserDao &#123; //根据id查询用户 public User getUserById(Integer id);&#125; 编写dao层接口实现类 1234567891011121314151617public class UserDaoImpl implements UserDao &#123; //sqlSession 工厂 private SqlSessionFactory ssf; //通过构造器给ssf赋值 public UserDaoImpl(SqlSessionFactory ssf) &#123; super(); this.ssf = ssf; &#125; @Override public User getUserById(Integer id) &#123; //生产一个sqlSession SqlSession session = ssf.openSession(); User user session.selectOne(\"UserMapper.selectUserById\",id); session.close(); return user; &#125;&#125; 编写测试方法 12345678910111213141516171819202122public class UserDaoTest &#123; //sqlSession 工厂 private static SqlSessionFactory ssf; static &#123; String resource = \"sqlMapConfig.xml\"; InputStream in; try &#123; in = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); ssf = ssfb.build(in); in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void DaoTest() &#123; UserDao dao = new UserDaoImpl(ssf); User user = dao.getUserById(1); System.out.println(user); &#125;&#125; &emsp;&emsp;不使用Mapper动态代理开发可以从代码中看到一些问题，每次我们调用SqlSession都要完成打开session、调用session完成与数据库的交互、关闭session，这三步，这些都是重复的代码。 2.2 使用Mapper动态代理开发首先想使用Mapper动态代理开发必须遵循四大原则加一个注意： 接口方法名需要与mapper.xml的要调用的sql语句的id一致 接口的形参类型需要与mapper.xml中的parameterType一致 接口的返回值需要与mapper.xml中的resultType一致 mapper.xml中的namespace要与接口的全包名一致注意：mapper动态代理开发中，根据返回值类型自动选择方法 UserMapper接口(mybatis提出mapper接口,相当于dao接口,mapper接口的命名方式建议为表名加Mapper) 1234public interface UserMapper &#123; //通过id查询一个用户 public User selectUserById(Integer id);&#125; UserMapper映射文件(mapper映射文件的命名方式建议表名加Mapper.xml,namespace指定为mapper接口的全限定名) 1234567&lt;!-- mapper.xml中的namespace要与接口的全包名一致 --&gt;&lt;mapper namespace=\"com.xiezhenyu.mapper.UserMapper\"&gt; &lt;!-- 查找用户 --&gt; &lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"user\"&gt; select * from user where u_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 将mapper.xml在SqlMapConfing.xml中进行注册 123&lt;mappers&gt; &lt;package name=\"com.xiezhenyu.mapper\"/&gt;&lt;/mappers&gt; 编写测试方法 123456789101112131415@Testpublic void Test1() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user);&#125; 结果： 1User [u_id=1, u_username=老王, u_password=123, u_sex=1, u_createTime=null, u_cid=1] 总结：使用Mapper代理进行开发&emsp;&emsp;优点：可以使我们只需要关注UserMapper.java接口中的方法，它的实现类由Mapper自动为我们生成，带来了很大的方便。&emsp;&emsp;缺点：如果UserMapper.java接口中的方法调用的statement中返回是多条记录，而mapper.java方法的返回值为JavaBean对象，此时代理对象通过selectOne调用，但由于返回的是多条记录所以会报错。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"傻瓜式使用MyBatis","date":"2019-10-13T09:59:27.728Z","path":"2019/10/13/傻瓜式使用MyBatis/","text":"MyBatis如何快速使用？ MyBatis框架图 1、下载MyBatis、创建项目、导包&emsp;&emsp;下载MyBatis：https://github.com/mybatis/mybatis-3/releases&emsp;&emsp;创建项目之后导入MyBatis的核心包和依赖包以及MySQL的连接包 2、创建测试用例，测试数据库、测试Bean对象&emsp;&emsp;创建测试数据库，直接运行以下SQL语句即可 123456789101112131415161718192021222324252627282930313233343536373839404142/*SQLyog Professional v12.08 (64 bit)MySQL - 5.5.49 : Database - ssm_mybatis**********************************************************************//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`ssm_mybatis` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `ssm_mybatis`;/*Table structure for table `country` */DROP TABLE IF EXISTS `country`;CREATE TABLE `country` ( `c_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '国家id', `c_countryname` varchar(128) NOT NULL COMMENT '国家名称', `c_capital` varchar(128) DEFAULT NULL COMMENT '国家首都名称', PRIMARY KEY (`c_id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;/*Data for the table `country` */insert into `country`(`c_id`,`c_countryname`,`c_capital`) values (1,'中国','北京'),(3,'美国','华盛顿'),(4,'英国','伦敦'),(5,'日本','东京');/*Table structure for table `user` */DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `u_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id', `u_username` varchar(64) NOT NULL COMMENT '用户名', `u_password` varchar(64) DEFAULT NULL COMMENT '用户密码', `u_sex` varchar(16) DEFAULT NULL COMMENT '用户性别', `u_createTime` datetime DEFAULT NULL COMMENT '用户创建时间', `u_cid` int(11) DEFAULT NULL COMMENT '用户国家id', PRIMARY KEY (`u_id`), KEY `FK_user_cid` (`u_cid`), CONSTRAINT `FK_user_cid` FOREIGN KEY (`u_cid`) REFERENCES `country` (`c_Id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;/*Data for the table `user` */insert into `user`(`u_id`,`u_username`,`u_password`,`u_sex`,`u_createTime`,`u_cid`) values (1,'老王','123','1',NULL,1),(2,'jack','123321','1',NULL,3),(3,'alice','ali111','0',NULL,3),(4,'王司机','666','1',NULL,1),(5,'anna','ali111','0',NULL,4),(6,'李师傅','222','1',NULL,1),(7,'漩涡鸣人','233','1',NULL,5),(8,'娜美','233','0',NULL,5),(9,'王五','abc','1',NULL,1),(10,'老赵',NULL,NULL,NULL,NULL),(11,'老孙',NULL,NULL,NULL,NULL),(12,'98k',NULL,NULL,NULL,NULL);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; &emsp;&emsp;创建测试Bean对象，与数据库创建的字段一致，并生成GET和SET方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class User &#123; private Integer u_id; private String u_username; private String u_password; private String u_sex; private Date u_createTime; private Integer u_cid; public Integer getU_id() &#123; return u_id; &#125; public void setU_id(Integer u_id) &#123; this.u_id = u_id; &#125; public String getU_username() &#123; return u_username; &#125; public void setU_username(String u_username) &#123; this.u_username = u_username; &#125; public String getU_password() &#123; return u_password; &#125; public void setU_password(String u_password) &#123; this.u_password = u_password; &#125; public String getU_sex() &#123; return u_sex; &#125; public void setU_sex(String u_sex) &#123; this.u_sex = u_sex; &#125; public Date getU_createTime() &#123; return u_createTime; &#125; public void setU_createTime(Date u_createTime) &#123; this.u_createTime = u_createTime; &#125; public Integer getU_cid() &#123; return u_cid; &#125; public void setU_cid(Integer u_cid) &#123; this.u_cid = u_cid; &#125; @Override public String toString() &#123; return \"User [u_id=\" + u_id + \", u_username=\" + u_username + \", u_password=\" + u_password + \", u_sex=\" + u_sex + \", u_createTime=\" + u_createTime + \", u_cid=\" + u_cid + \"]\"; &#125;&#125; 3、创建sqlMapConfig.xml主配置文件&emsp;&emsp;以下只是sqlMapConfig.xml主配置文件的一部分(会在快速使用MyBatis中使用到的一部分)，如果想要查看完整的配置文件请查看官方文档：https://mybatis.org/mybatis-3/zh/configuration.html 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 在集成spring时不用 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 使用jdbc的事务 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 使用连接池 链接数据库 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm_mybatis?serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf-8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"p123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4、创建Mapper.xml映射文件&emsp;&emsp;Mapper.xml映射文件中可以书写了查找用户、模糊查找用户、添加用户、修改用户、删除用户的sql语句，其中模糊查找中如果用字符串拼接的形式是不安全的，推荐使用占位符模糊查找。&emsp;&emsp;由于使用占位符查找，如果这样使用#{id}，如果传过来的id为1，他会在#{id}这个位置上显示’1’，加上了单引号，我们都知道模糊查找是 1select * from user where u_username like %你% &emsp;&emsp;如果我们使用占位符的话%’你’%这样是不行的，所以我们书写SQL语句的时候可以这样用 1select * from user where u_username like \"%\"'你'\"%\" &emsp;&emsp;以下是Mapper.xml映射文件 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"UserMapper\"&gt; &lt;!-- 查找用户 --&gt; &lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"com.siliedu.bean.User\"&gt; select * from user where u_id = #&#123;id&#125; &lt;/select&gt; &lt;!-- #&#123;&#125;占位符 尽量选用占位符解决问题 --&gt; &lt;!-- $&#123;&#125;字符串拼接 --&gt; &lt;!-- 模糊查找用户 --&gt; &lt;select id=\"selectUserByName\" parameterType=\"String\" resultType=\"com.siliedu.bean.User\"&gt; &lt;!-- select * from user where u_username like '%$&#123;value&#125;%' --&gt; select * from user where u_username like \"%\"#&#123;name&#125;\"%\" &lt;/select&gt; &lt;!-- 添加用户 --&gt; &lt;insert id=\"insertUser\" parameterType=\"com.siliedu.bean.User\"&gt; insert into user values(null,#&#123;u_username&#125;,#&#123;u_password&#125;,#&#123;u_sex&#125;,#&#123;u_createTime&#125;,#&#123;u_cid&#125;) &lt;/insert&gt; &lt;!-- 修改用户 --&gt; &lt;update id=\"updateUser\" parameterType=\"com.siliedu.bean.User\"&gt; update user set u_username = #&#123;u_username&#125; where u_id=#&#123;u_id&#125; &lt;/update&gt; &lt;!-- 删除用户 --&gt; &lt;delete id=\"deleteUserById\" parameterType=\"Integer\"&gt; delete from user where u_id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 5、书写测试方法测试通过id查找用户1234567891011121314151617@Test//通过ID查询用户public void Test1() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 User user = session.selectOne(\"UserMapper.selectUserById\", 1); System.out.println(user);&#125; 测试通过名字模糊查询用户12345678910111213141516171819@Test//通过name模糊查询用户public void Test2() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 List&lt;User&gt; list = session.selectList(\"UserMapper.selectUserByName\", \"王\"); for(User u : list) &#123; System.out.println(u); &#125;&#125; 测试新增用户由于对数据库进行了更新，session必须commit才能使事务提交，数据库才会更新 1234567891011121314151617181920212223@Test//通过新增用户public void Test3() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 User user = new User(); user.setU_username(\"小明\"); user.setU_password(\"123456789\"); user.setU_sex(\"1\"); user.setU_createTime(new Date()); user.setU_cid(1); session.insert(\"UserMapper.insertUser\", user); session.commit();&#125; 测试修改用户1234567891011121314151617181920@Test//修改用户public void Test4() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 User user = new User(); user.setU_id(13); user.setU_username(\"小刚\"); session.update(\"UserMapper.updateUser\", user); session.commit();&#125; 测试删除用户1234567891011121314151617@Test//删除用户public void Test5() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 session.delete(\"UserMapper.deleteUserById\", 13); session.commit();&#125; 以上就是MyBatis的简单使用。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"聊聊struts.xml配置文件-Struts(二)","date":"2019-10-08T11:47:44.023Z","path":"2019/10/08/聊聊struts.xml配置文件-Struts(二)/","text":"&emsp;&emsp;上一篇写了一下struts怎么快速上手使用，下面是struts的配置文件struts.xml中一些配置的解释(●’◡’●)。 &emsp;&emsp;struts.xml是整个程序的工作流程的依据，该文件的根元素是&lt;struts&gt;，其中可以包含4个子元素，分别是：&lt;include&gt;、&lt;constant&gt;、&lt;bean&gt;、&lt;package&gt; &lt;include&gt;元素&emsp;&emsp;由于用struts开发一个大型的项目时，struts中的配置信息会越来越多，这样就会使配置文件的可读性和维护性变差，但使用了&lt;include&gt;就会解决这个问题，我们可以按照不同的功能或者模块将配置文件分割成多个配置文件。 1234&lt;struts&gt; &lt;include file=\"login.xml\"&gt;&lt;/include&gt; &lt;include file=\"register.xml\"&gt;&lt;/include&gt;&lt;/struts&gt; &lt;constant&gt;元素&emsp;&emsp;&lt;constant&gt;元素用于配置一些常量信息，这些常量用于控制struts2的某些特性，相当于当他运行时，给你准备哪些功能。由于&lt;constant&gt;元素的常量值过多，我只列一些常用的，以下例子是&lt;constant&gt;元素使用的常用设置 12345678910111213141516171819202122232425&lt;struts&gt; &lt;!-- 匹配所有以\".action\"为后缀的请求都由struts处理，其中action可变 如果需要匹配多个后缀都由struts处理，则使用英文\",\"号分隔，例如value=\"do,action\" 如果不写这一句，则会默认映射Action名字 --&gt; &lt;constant name=\"struts.action.extension\" value=\"action\" /&gt; &lt;!-- 是否启用开发者模式，在开发者模式下可打印出更加详细的报错信息 --&gt; &lt;constant name=\"struts.devMode\" value=\"true\" /&gt; &lt;!-- 当struts配置文件改动后，是否重新加载，默认不写是false --&gt; &lt;constant name=\"struts.configuration.xml.reload\" value=\"true\" /&gt; &lt;!-- 设置浏览器是否缓存静态内容，默认不写为true缓存，在开发环境下最好关闭，可以提高开发效率 --&gt; &lt;constant name=\"struts.serve.static.browserCache\" value=\"true\" /&gt; &lt;!-- 设置请求参数的编码方式，实际上相当于相当调用HttpServletRequest中的setCharacterEncoding方法 --&gt; &lt;constant name=\"struts.i18n.encoding\" value=\"utf-8\" /&gt; &lt;!-- 每次HTTP请求系统都重新加载资源文件 --&gt; &lt;constant name=\"struts.i18n.reload\" value=\"false\" /&gt; &lt;!-- 文件上传的最大值，单位为字节 --&gt; &lt;constant name=\"struts.multipart.maxSize\" value=\"1024\" /&gt; &lt;!-- 让Struts支持动态方法调用 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" /&gt; &lt;!-- 在URL中的Action段中是否支持斜线 --&gt; &lt;constant name=\"struts.enable.SlashesInActionNames\" value=\"false\" /&gt; &lt;!-- 标签中是否支持ognl表达式 --&gt; &lt;constant name=\"struts.tag.altSyntax\" value=\"true\" /&gt;&lt;/struts&gt; &lt;bean&gt;元素&emsp;&emsp;struts2是一个可扩展的框架，核心组件都是可以配置的，当我们需要扩展或替换struts2的核心组件时，只需要提供自己的组件实现类，并部署到struts2的容器中即可。&emsp;&emsp;例子：使用一个自定义的ObjectFactory替换struts2内置的ObjectFactory： 1&lt;bean name=\"myFactory\" type=\"com.opensymphony.xwork2.ObjectFactory\" class=\"xiezhenyu.ObjectFactory\" /&gt; &lt;package&gt;元素&emsp;&emsp;&lt;package&gt;元素提供了将多个Action组织为一个模块的方式，package的name在整个struts配置文件中必须是唯一的，并且一个package可以扩展自另一个package。此时改package会在本身配置的基础上加入扩展package的配置，但要注意父package必须在子package前配置。 123456789&lt;!-- package的属性name:package名称，作为其他包引用本包的标识，必填属性extends:继承的父package名称，可选属性。通常设置为struts-default，继承struts-default.xml，它里面定义了许多跳转类型、拦截器等一些常用的东西abstract:设置package的属性为抽象的，抽象的package不能定义Action，可选属性。namespace:可选属性。浏览器地址是根据namespace/action名称去访问的action其中namespace可以是虚路径--&gt;&lt;package name=\"MyStruts\" extends=\"struts-default\" namespace=\"/\"&gt;&lt;/package&gt; &lt;package&gt;子元素列表 子元素 功能 default-action-ref 配置默认的Action default-class-ref 配置默认class default-interceptor-ref 配置默认拦截器，对package范围内的所有Action有效 global-results 配置全局结果集，对package范围内的所有Action有效 global-exception-mapping 配置全局异常映射，对package范围内的所有Action有效 result-types 配置定义返回结果类型 interceptors 配置拦截器信息 action 配置Action信息 &lt;default-action-ref&gt;&emsp;&emsp;&lt;default-action-ref&gt;元素用于配置默认的Action，当一个Action请求在配置文件中找不到时，就会执行这个默认的Action，该元素只有一个name属性。 1&lt;default-action-ref name=\"Error\"&gt;&lt;/default-action-ref&gt; &lt;default-class-ref&gt;&emsp;&emsp;&lt;default-class-ref&gt;元素用户配置默认的类，在配置Action时，如果没有指定具体的class属性，系统就会使用&lt;default-class-ref&gt;元素中的配置。&lt;default-class-ref&gt;只有一个class属性。当使用&lt;default-class-ref&gt;元素指定了默认类后，Struts原来默认的类会被覆盖，而且默认的Action类必须包含execute()方法。 &lt;default-interceptor-ref&gt;&emsp;&emsp;&lt;default-interceptor-ref&gt;元素用于配置默认类拦截器，如果package继承了“struts-default”，那么也会继承父类package的默认拦截器。 &lt;global-result&gt;&emsp;&emsp;&lt;global-result&gt;元素用于配置package范围内的全局结果集。他的子元素是&lt;result&gt;。当一个package中多个Action都使用了一个或多个结果的时候，则将其配置在全局结果集中，增强代码的可读性和维护性。例如下面这个案列：当每个Action都返回了error的时候，全都使用这个全局结果去执行。 123&lt;global-result&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt;&lt;/global-result&gt; &lt;global-exception-mapping&gt;&emsp;&emsp;&lt;global-exception-mapping&gt;元素用于配置全局异常映射，如果&lt;action&gt;元素内配置了自己的异常映射，则Action内的优先级高于此配置。他的子元素是&lt;exception-mapping&gt;。 123&lt;global-exception-mapping&gt; &lt;exception-mapping result=\"error\" exception=\"异常类型\"&gt;&lt;/exception-mapping&gt;&lt;/global-exception-mapping&gt; &lt;result-type&gt;&emsp;&emsp;&lt;result-type&gt;元素用于配置自定义返回结果类型，该元素基本不用。 &lt;interceptors&gt;&emsp;&emsp;&lt;interceptors&gt;元素用于配置拦截器的拦截器栈，他有两个子元素：&lt;interceptor&gt;和&lt;interceptor-stack&gt;，分别用来定义拦截器和拦截器栈。 &lt;action&gt;&lt;action&gt;元素是比较重要的一个元素，也是我们开发中使用最多的一个元素。它有4个属性： name：必选属性，Action的名字。 class：可选属性，Action处理类的名字。 method：可选属性，指定Action中的方法。如果没有配置该属性，所有请求都会被转发到execute()方法去处理。如果有多个请求需要分别交给不同的方法去处理，就可以使用该属性来指明。 converter：可选属性，指定Action使用的类型转换器。 &emsp;&emsp;method属性除了可以填固定的函数名外，还可以使用通配符的方法实现动态方法调用，使用它的前提是必须要配置&lt;constant&gt;元素和&lt;global-allowed-methods&gt;，使其能实现动态方法调用和适配所有的方法。 123456789101112 &lt;struts&gt; &lt;!-- 让Struts支持动态方法调用 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" /&gt; &lt;package name=\"Struts\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 适配所有的通配符方法 --&gt; &lt;global-allowed-methods&gt;regex:.*&lt;/global-allowed-methods&gt; &lt;action name=\"*User\" class=\"xiezhenyu.UserAction\" method=\"&#123;1&#125;User\"&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt; &lt;result name=\"success\"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; &emsp;&emsp;如上代码所示，name属性值中的”*“就是通配符，表示所有以User结尾的亲求都会有这个Action处理；method属性值中的“{1}”是表达式，表示name属性中”*“的值，比如请求为loginUser，那么将传递给method属性，这是会调用Action中loginUser()方法。 &lt;action&gt;中还有以下几个子元素 &lt;interceptor-ref&gt;：用于配置拦截器 &lt;exception-mapping&gt;：用于配置异常映射 &lt;result&gt;：用于配置Action的结果映射，除了常规的结果映射外，也可以像method属性值一样使用表达式，实行动态结果。&lt;result&gt;有两个属性，name、type。name为Action类在处理完成返回的都是字符串类型的结果，这个结果作为逻辑视图存在，对应&lt;result&gt;元素的name属性值，然后找到与之对应的视图资源。type为指定结果的类型，其取值如下表所示。（我们只需要记住dispatcher、redirect和chain三个常用的即可，其它的略作了解） type可取值 解释 dispatcher 转发，默认结果类型，对应视图为JSP界面 chain 将Action和另一个Action链接起来 freemarker 返回结果的对应视图为FreeMarker模板 HttpHeaderResult 返回一个已配置好的HTTP头信息响应 redirect 将用户重定向到一个配置好的URL redirectAction 将用户重定向到一个已定义好的Action stream 将原数据作为流传递会浏览器，一般用于下载 velocity 返回结果的对应视图为Velocity模板 xslt 呈现XML到浏览器，该XML可以通过XSL模板进行转换 plaintext 返回普通文本内容 以上就是struts2配置文件的大部分内容。","tags":[{"name":"struts","slug":"struts","permalink":"https://Xiezhenyu98.github.io/tags/struts/"}]},{"title":"傻瓜式使用Struts-Struts(一)","date":"2019-10-07T06:53:12.957Z","path":"2019/10/07/傻瓜式使用Struts-Struts(一)/","text":"我现在大三了，很多同学都想转行JAVA(还好我大一就确定目标学java了(●’◡’●))，今天有人问我struts怎么用，为了同学的方便，我写了这篇傻瓜式使用struts框架的博客，希望能让同学们快速使用struts框架。(本篇本着可复现的态度写的，测试可用) 1、导入strurs需要用到的jar包经过本人整理出以下需要用到的一些包commons-fileupload-1.3.3.jarcommons-io-2.5.jarcommons-lang3-3.6.jarcommons-logging-1.1.3.jarfreemarker-2.3.26-incubating.jarjavassist-3.20.0-GA.jarlog4j-api-2.10.0.jarlog4j-core-2.11.0.jarognl-3.1.15.jarstruts2-core-2.5.16.jar你可以通过 点击这里下载 2、配置web.xml在web.xml中配置struts(添加filter) 12345678&lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3、创建Action创建一个Action并继承ActionSupport，从写里面的execute方法或者写一个带有String返回值并抛出一个异常的函数（异常可以抛出也可以不抛出） 123456public class SturtsAction extends ActionSupport&#123; public String test() throws Exception &#123; System.out.println(\"sss\"); return \"index\"; &#125;&#125; 4、配置struts.xmlstruts.xml必须创建在src根目录下 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- name:可以随便写 namespace:浏览器地址是根据namespace/action名称去访问的action其中namespace可以是虚路径 extends:struts-default 为继承struts的默认结果集，就是继承struts-default.xml，它里面定义了许多跳转类型、拦截器等一些常用的东西 --&gt; &lt;package name=\"Struts\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- name:浏览器访问的路径 class:这个类的路径 method:方法名 这三个连起来可以理解为：浏览器访问的路径是访问的哪个类中的哪个方法 --&gt; &lt;action name=\"StrutsAction\" class=\"com.xiezhenyu.web.SturtsAction\" method=\"test\"&gt; &lt;!-- name:与test方法中返回的字符串对应，后面的是跳转到哪一个页面 --&gt; &lt;result name=\"index\"&gt;/index.html&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 5、测试struts在eclipse跑起来之后输入地址，使用struts成功！！ 注意：其中struts.xml的配置文件只是其中一部分配置，目前并不能当成万金油使用，本篇只是介绍struts如何快速使用，就不一一介绍struts的详细配置文件，后续我会一一写出。","tags":[{"name":"struts","slug":"struts","permalink":"https://Xiezhenyu98.github.io/tags/struts/"}]}]