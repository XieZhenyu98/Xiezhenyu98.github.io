[{"title":"傻瓜式使用MyBatis","date":"2019-10-13T09:59:27.728Z","path":"2019/10/13/傻瓜式使用MyBatis/","text":"MyBatis如何快速使用？ MyBatis框架图 1、下载MyBatis、创建项目、导包&emsp;&emsp;下载MyBatis：https://github.com/mybatis/mybatis-3/releases&emsp;&emsp;创建项目之后导入MyBatis的核心包和依赖包以及MySQL的连接包 2、创建测试用例，测试数据库、测试Bean对象&emsp;&emsp;创建测试数据库，直接运行以下SQL语句即可 123456789101112131415161718192021222324252627282930313233343536373839404142/*SQLyog Professional v12.08 (64 bit)MySQL - 5.5.49 : Database - ssm_mybatis**********************************************************************//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`ssm_mybatis` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `ssm_mybatis`;/*Table structure for table `country` */DROP TABLE IF EXISTS `country`;CREATE TABLE `country` ( `c_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '国家id', `c_countryname` varchar(128) NOT NULL COMMENT '国家名称', `c_capital` varchar(128) DEFAULT NULL COMMENT '国家首都名称', PRIMARY KEY (`c_id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;/*Data for the table `country` */insert into `country`(`c_id`,`c_countryname`,`c_capital`) values (1,'中国','北京'),(3,'美国','华盛顿'),(4,'英国','伦敦'),(5,'日本','东京');/*Table structure for table `user` */DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `u_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id', `u_username` varchar(64) NOT NULL COMMENT '用户名', `u_password` varchar(64) DEFAULT NULL COMMENT '用户密码', `u_sex` varchar(16) DEFAULT NULL COMMENT '用户性别', `u_createTime` datetime DEFAULT NULL COMMENT '用户创建时间', `u_cid` int(11) DEFAULT NULL COMMENT '用户国家id', PRIMARY KEY (`u_id`), KEY `FK_user_cid` (`u_cid`), CONSTRAINT `FK_user_cid` FOREIGN KEY (`u_cid`) REFERENCES `country` (`c_Id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;/*Data for the table `user` */insert into `user`(`u_id`,`u_username`,`u_password`,`u_sex`,`u_createTime`,`u_cid`) values (1,'老王','123','1',NULL,1),(2,'jack','123321','1',NULL,3),(3,'alice','ali111','0',NULL,3),(4,'王司机','666','1',NULL,1),(5,'anna','ali111','0',NULL,4),(6,'李师傅','222','1',NULL,1),(7,'漩涡鸣人','233','1',NULL,5),(8,'娜美','233','0',NULL,5),(9,'王五','abc','1',NULL,1),(10,'老赵',NULL,NULL,NULL,NULL),(11,'老孙',NULL,NULL,NULL,NULL),(12,'98k',NULL,NULL,NULL,NULL);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; &emsp;&emsp;创建测试Bean对象，与数据库创建的字段一致，并生成GET和SET方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class User &#123; private Integer u_id; private String u_username; private String u_password; private String u_sex; private Date u_createTime; private Integer u_cid; public Integer getU_id() &#123; return u_id; &#125; public void setU_id(Integer u_id) &#123; this.u_id = u_id; &#125; public String getU_username() &#123; return u_username; &#125; public void setU_username(String u_username) &#123; this.u_username = u_username; &#125; public String getU_password() &#123; return u_password; &#125; public void setU_password(String u_password) &#123; this.u_password = u_password; &#125; public String getU_sex() &#123; return u_sex; &#125; public void setU_sex(String u_sex) &#123; this.u_sex = u_sex; &#125; public Date getU_createTime() &#123; return u_createTime; &#125; public void setU_createTime(Date u_createTime) &#123; this.u_createTime = u_createTime; &#125; public Integer getU_cid() &#123; return u_cid; &#125; public void setU_cid(Integer u_cid) &#123; this.u_cid = u_cid; &#125; @Override public String toString() &#123; return \"User [u_id=\" + u_id + \", u_username=\" + u_username + \", u_password=\" + u_password + \", u_sex=\" + u_sex + \", u_createTime=\" + u_createTime + \", u_cid=\" + u_cid + \"]\"; &#125;&#125; 3、创建sqlMapConfig.xml主配置文件&emsp;&emsp;以下只是sqlMapConfig.xml主配置文件的一部分(会在快速使用MyBatis中使用到的一部分)，如果想要查看完整的配置文件请查看官方文档：https://mybatis.org/mybatis-3/zh/configuration.html 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 在集成spring时不用 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 使用jdbc的事务 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 使用连接池 链接数据库 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm_mybatis?serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf-8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"p123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4、创建Mapper.xml映射文件&emsp;&emsp;Mapper.xml映射文件中可以书写了查找用户、模糊查找用户、添加用户、修改用户、删除用户的sql语句，其中模糊查找中如果用字符串拼接的形式是不安全的，推荐使用占位符模糊查找。&emsp;&emsp;由于使用占位符查找，如果这样使用#{id}，如果传过来的id为1，他会在#{id}这个位置上显示’1’，加上了单引号，我们都知道模糊查找是 1select * from user where u_username like %你% &emsp;&emsp;如果我们使用占位符的话%’你’%这样是不行的，所以我们书写SQL语句的时候可以这样用 1select * from user where u_username like \"%\"'你'\"%\" &emsp;&emsp;以下是Mapper.xml映射文件 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"UserMapper\"&gt; &lt;!-- 查找用户 --&gt; &lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"com.siliedu.bean.User\"&gt; select * from user where u_id = #&#123;id&#125; &lt;/select&gt; &lt;!-- #&#123;&#125;占位符 尽量选用占位符解决问题 --&gt; &lt;!-- $&#123;&#125;字符串拼接 --&gt; &lt;!-- 模糊查找用户 --&gt; &lt;select id=\"selectUserByName\" parameterType=\"String\" resultType=\"com.siliedu.bean.User\"&gt; &lt;!-- select * from user where u_username like '%$&#123;value&#125;%' --&gt; select * from user where u_username like \"%\"#&#123;name&#125;\"%\" &lt;/select&gt; &lt;!-- 添加用户 --&gt; &lt;insert id=\"insertUser\" parameterType=\"com.siliedu.bean.User\"&gt; insert into user values(null,#&#123;u_username&#125;,#&#123;u_password&#125;,#&#123;u_sex&#125;,#&#123;u_createTime&#125;,#&#123;u_cid&#125;) &lt;/insert&gt; &lt;!-- 修改用户 --&gt; &lt;update id=\"updateUser\" parameterType=\"com.siliedu.bean.User\"&gt; update user set u_username = #&#123;u_username&#125; where u_id=#&#123;u_id&#125; &lt;/update&gt; &lt;!-- 删除用户 --&gt; &lt;delete id=\"deleteUserById\" parameterType=\"Integer\"&gt; delete from user where u_id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 5、书写测试方法测试通过id查找用户1234567891011121314151617@Test//通过ID查询用户public void Test1() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 User user = session.selectOne(\"UserMapper.selectUserById\", 1); System.out.println(user);&#125; 测试通过名字模糊查询用户12345678910111213141516171819@Test//通过name模糊查询用户public void Test2() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 List&lt;User&gt; list = session.selectList(\"UserMapper.selectUserByName\", \"王\"); for(User u : list) &#123; System.out.println(u); &#125;&#125; 测试新增用户由于对数据库进行了更新，session必须commit才能使事务提交，数据库才会更新 1234567891011121314151617181920212223@Test//通过新增用户public void Test3() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 User user = new User(); user.setU_username(\"小明\"); user.setU_password(\"123456789\"); user.setU_sex(\"1\"); user.setU_createTime(new Date()); user.setU_cid(1); session.insert(\"UserMapper.insertUser\", user); session.commit();&#125; 测试修改用户1234567891011121314151617181920@Test//修改用户public void Test4() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 User user = new User(); user.setU_id(13); user.setU_username(\"小刚\"); session.update(\"UserMapper.updateUser\", user); session.commit();&#125; 测试删除用户1234567891011121314151617@Test//删除用户public void Test5() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 session.delete(\"UserMapper.deleteUserById\", 13); session.commit();&#125; 以上就是MyBatis的简单使用。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"聊聊struts.xml配置文件-Struts(二)","date":"2019-10-08T11:47:44.023Z","path":"2019/10/08/聊聊struts.xml配置文件-Struts(二)/","text":"&emsp;&emsp;上一篇写了一下struts怎么快速上手使用，下面是struts的配置文件struts.xml中一些配置的解释(●’◡’●)。 &emsp;&emsp;struts.xml是整个程序的工作流程的依据，该文件的根元素是&lt;struts&gt;，其中可以包含4个子元素，分别是：&lt;include&gt;、&lt;constant&gt;、&lt;bean&gt;、&lt;package&gt; &lt;include&gt;元素&emsp;&emsp;由于用struts开发一个大型的项目时，struts中的配置信息会越来越多，这样就会使配置文件的可读性和维护性变差，但使用了&lt;include&gt;就会解决这个问题，我们可以按照不同的功能或者模块将配置文件分割成多个配置文件。 1234&lt;struts&gt; &lt;include file=\"login.xml\"&gt;&lt;/include&gt; &lt;include file=\"register.xml\"&gt;&lt;/include&gt;&lt;/struts&gt; &lt;constant&gt;元素&emsp;&emsp;&lt;constant&gt;元素用于配置一些常量信息，这些常量用于控制struts2的某些特性，相当于当他运行时，给你准备哪些功能。由于&lt;constant&gt;元素的常量值过多，我只列一些常用的，以下例子是&lt;constant&gt;元素使用的常用设置 12345678910111213141516171819202122232425&lt;struts&gt; &lt;!-- 匹配所有以\".action\"为后缀的请求都由struts处理，其中action可变 如果需要匹配多个后缀都由struts处理，则使用英文\",\"号分隔，例如value=\"do,action\" 如果不写这一句，则会默认映射Action名字 --&gt; &lt;constant name=\"struts.action.extension\" value=\"action\" /&gt; &lt;!-- 是否启用开发者模式，在开发者模式下可打印出更加详细的报错信息 --&gt; &lt;constant name=\"struts.devMode\" value=\"true\" /&gt; &lt;!-- 当struts配置文件改动后，是否重新加载，默认不写是false --&gt; &lt;constant name=\"struts.configuration.xml.reload\" value=\"true\" /&gt; &lt;!-- 设置浏览器是否缓存静态内容，默认不写为true缓存，在开发环境下最好关闭，可以提高开发效率 --&gt; &lt;constant name=\"struts.serve.static.browserCache\" value=\"true\" /&gt; &lt;!-- 设置请求参数的编码方式，实际上相当于相当调用HttpServletRequest中的setCharacterEncoding方法 --&gt; &lt;constant name=\"struts.i18n.encoding\" value=\"utf-8\" /&gt; &lt;!-- 每次HTTP请求系统都重新加载资源文件 --&gt; &lt;constant name=\"struts.i18n.reload\" value=\"false\" /&gt; &lt;!-- 文件上传的最大值，单位为字节 --&gt; &lt;constant name=\"struts.multipart.maxSize\" value=\"1024\" /&gt; &lt;!-- 让Struts支持动态方法调用 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" /&gt; &lt;!-- 在URL中的Action段中是否支持斜线 --&gt; &lt;constant name=\"struts.enable.SlashesInActionNames\" value=\"false\" /&gt; &lt;!-- 标签中是否支持ognl表达式 --&gt; &lt;constant name=\"struts.tag.altSyntax\" value=\"true\" /&gt;&lt;/struts&gt; &lt;bean&gt;元素&emsp;&emsp;struts2是一个可扩展的框架，核心组件都是可以配置的，当我们需要扩展或替换struts2的核心组件时，只需要提供自己的组件实现类，并部署到struts2的容器中即可。&emsp;&emsp;例子：使用一个自定义的ObjectFactory替换struts2内置的ObjectFactory： 1&lt;bean name=\"myFactory\" type=\"com.opensymphony.xwork2.ObjectFactory\" class=\"xiezhenyu.ObjectFactory\" /&gt; &lt;package&gt;元素&emsp;&emsp;&lt;package&gt;元素提供了将多个Action组织为一个模块的方式，package的name在整个struts配置文件中必须是唯一的，并且一个package可以扩展自另一个package。此时改package会在本身配置的基础上加入扩展package的配置，但要注意父package必须在子package前配置。 123456789&lt;!-- package的属性name:package名称，作为其他包引用本包的标识，必填属性extends:继承的父package名称，可选属性。通常设置为struts-default，继承struts-default.xml，它里面定义了许多跳转类型、拦截器等一些常用的东西abstract:设置package的属性为抽象的，抽象的package不能定义Action，可选属性。namespace:可选属性。浏览器地址是根据namespace/action名称去访问的action其中namespace可以是虚路径--&gt;&lt;package name=\"MyStruts\" extends=\"struts-default\" namespace=\"/\"&gt;&lt;/package&gt; &lt;package&gt;子元素列表 子元素 功能 default-action-ref 配置默认的Action default-class-ref 配置默认class default-interceptor-ref 配置默认拦截器，对package范围内的所有Action有效 global-results 配置全局结果集，对package范围内的所有Action有效 global-exception-mapping 配置全局异常映射，对package范围内的所有Action有效 result-types 配置定义返回结果类型 interceptors 配置拦截器信息 action 配置Action信息 &lt;default-action-ref&gt;&emsp;&emsp;&lt;default-action-ref&gt;元素用于配置默认的Action，当一个Action请求在配置文件中找不到时，就会执行这个默认的Action，该元素只有一个name属性。 1&lt;default-action-ref name=\"Error\"&gt;&lt;/default-action-ref&gt; &lt;default-class-ref&gt;&emsp;&emsp;&lt;default-class-ref&gt;元素用户配置默认的类，在配置Action时，如果没有指定具体的class属性，系统就会使用&lt;default-class-ref&gt;元素中的配置。&lt;default-class-ref&gt;只有一个class属性。当使用&lt;default-class-ref&gt;元素指定了默认类后，Struts原来默认的类会被覆盖，而且默认的Action类必须包含execute()方法。 &lt;default-interceptor-ref&gt;&emsp;&emsp;&lt;default-interceptor-ref&gt;元素用于配置默认类拦截器，如果package继承了“struts-default”，那么也会继承父类package的默认拦截器。 &lt;global-result&gt;&emsp;&emsp;&lt;global-result&gt;元素用于配置package范围内的全局结果集。他的子元素是&lt;result&gt;。当一个package中多个Action都使用了一个或多个结果的时候，则将其配置在全局结果集中，增强代码的可读性和维护性。例如下面这个案列：当每个Action都返回了error的时候，全都使用这个全局结果去执行。 123&lt;global-result&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt;&lt;/global-result&gt; &lt;global-exception-mapping&gt;&emsp;&emsp;&lt;global-exception-mapping&gt;元素用于配置全局异常映射，如果&lt;action&gt;元素内配置了自己的异常映射，则Action内的优先级高于此配置。他的子元素是&lt;exception-mapping&gt;。 123&lt;global-exception-mapping&gt; &lt;exception-mapping result=\"error\" exception=\"异常类型\"&gt;&lt;/exception-mapping&gt;&lt;/global-exception-mapping&gt; &lt;result-type&gt;&emsp;&emsp;&lt;result-type&gt;元素用于配置自定义返回结果类型，该元素基本不用。 &lt;interceptors&gt;&emsp;&emsp;&lt;interceptors&gt;元素用于配置拦截器的拦截器栈，他有两个子元素：&lt;interceptor&gt;和&lt;interceptor-stack&gt;，分别用来定义拦截器和拦截器栈。 &lt;action&gt;&lt;action&gt;元素是比较重要的一个元素，也是我们开发中使用最多的一个元素。它有4个属性： name：必选属性，Action的名字。 class：可选属性，Action处理类的名字。 method：可选属性，指定Action中的方法。如果没有配置该属性，所有请求都会被转发到execute()方法去处理。如果有多个请求需要分别交给不同的方法去处理，就可以使用该属性来指明。 converter：可选属性，指定Action使用的类型转换器。 &emsp;&emsp;method属性除了可以填固定的函数名外，还可以使用通配符的方法实现动态方法调用，使用它的前提是必须要配置&lt;constant&gt;元素和&lt;global-allowed-methods&gt;，使其能实现动态方法调用和适配所有的方法。 123456789101112 &lt;struts&gt; &lt;!-- 让Struts支持动态方法调用 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" /&gt; &lt;package name=\"Struts\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 适配所有的通配符方法 --&gt; &lt;global-allowed-methods&gt;regex:.*&lt;/global-allowed-methods&gt; &lt;action name=\"*User\" class=\"xiezhenyu.UserAction\" method=\"&#123;1&#125;User\"&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt; &lt;result name=\"success\"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; &emsp;&emsp;如上代码所示，name属性值中的”*“就是通配符，表示所有以User结尾的亲求都会有这个Action处理；method属性值中的“{1}”是表达式，表示name属性中”*“的值，比如请求为loginUser，那么将传递给method属性，这是会调用Action中loginUser()方法。 &lt;action&gt;中还有以下几个子元素 &lt;interceptor-ref&gt;：用于配置拦截器 &lt;exception-mapping&gt;：用于配置异常映射 &lt;result&gt;：用于配置Action的结果映射，除了常规的结果映射外，也可以像method属性值一样使用表达式，实行动态结果。&lt;result&gt;有两个属性，name、type。name为Action类在处理完成返回的都是字符串类型的结果，这个结果作为逻辑视图存在，对应&lt;result&gt;元素的name属性值，然后找到与之对应的视图资源。type为指定结果的类型，其取值如下表所示。（我们只需要记住dispatcher、redirect和chain三个常用的即可，其它的略作了解） type可取值 解释 dispatcher 转发，默认结果类型，对应视图为JSP界面 chain 将Action和另一个Action链接起来 freemarker 返回结果的对应视图为FreeMarker模板 HttpHeaderResult 返回一个已配置好的HTTP头信息响应 redirect 将用户重定向到一个配置好的URL redirectAction 将用户重定向到一个已定义好的Action stream 将原数据作为流传递会浏览器，一般用于下载 velocity 返回结果的对应视图为Velocity模板 xslt 呈现XML到浏览器，该XML可以通过XSL模板进行转换 plaintext 返回普通文本内容 以上就是struts2配置文件的大部分内容。","tags":[{"name":"struts","slug":"struts","permalink":"https://Xiezhenyu98.github.io/tags/struts/"}]},{"title":"傻瓜式使用Struts-Struts(一)","date":"2019-10-07T06:53:12.957Z","path":"2019/10/07/傻瓜式使用Struts-Struts(一)/","text":"我现在大三了，很多同学都想转行JAVA(还好我大一就确定目标学java了(●’◡’●))，今天有人问我struts怎么用，为了同学的方便，我写了这篇傻瓜式使用struts框架的博客，希望能让同学们快速使用struts框架。(本篇本着可复现的态度写的，测试可用) 1、导入strurs需要用到的jar包经过本人整理出以下需要用到的一些包commons-fileupload-1.3.3.jarcommons-io-2.5.jarcommons-lang3-3.6.jarcommons-logging-1.1.3.jarfreemarker-2.3.26-incubating.jarjavassist-3.20.0-GA.jarlog4j-api-2.10.0.jarlog4j-core-2.11.0.jarognl-3.1.15.jarstruts2-core-2.5.16.jar你可以通过 点击这里下载 2、配置web.xml在web.xml中配置struts(添加filter) 12345678&lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3、创建Action创建一个Action并继承ActionSupport，从写里面的execute方法或者写一个带有String返回值并抛出一个异常的函数（异常可以抛出也可以不抛出） 123456public class SturtsAction extends ActionSupport&#123; public String test() throws Exception &#123; System.out.println(\"sss\"); return \"index\"; &#125;&#125; 4、配置struts.xmlstruts.xml必须创建在src根目录下 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- name:可以随便写 namespace:浏览器地址是根据namespace/action名称去访问的action其中namespace可以是虚路径 extends:struts-default 为继承struts的默认结果集，就是继承struts-default.xml，它里面定义了许多跳转类型、拦截器等一些常用的东西 --&gt; &lt;package name=\"Struts\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- name:浏览器访问的路径 class:这个类的路径 method:方法名 这三个连起来可以理解为：浏览器访问的路径是访问的哪个类中的哪个方法 --&gt; &lt;action name=\"StrutsAction\" class=\"com.xiezhenyu.web.SturtsAction\" method=\"test\"&gt; &lt;!-- name:与test方法中返回的字符串对应，后面的是跳转到哪一个页面 --&gt; &lt;result name=\"index\"&gt;/index.html&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 5、测试struts在eclipse跑起来之后输入地址，使用struts成功！！ 注意：其中struts.xml的配置文件只是其中一部分配置，目前并不能当成万金油使用，本篇只是介绍struts如何快速使用，就不一一介绍struts的详细配置文件，后续我会一一写出。","tags":[{"name":"struts","slug":"struts","permalink":"https://Xiezhenyu98.github.io/tags/struts/"}]}]