[{"title":"数据结构和算法-时间复杂度","date":"2019-12-06T08:03:58.271Z","path":"2019/12/06/数据结构和算法-时间复杂度/","text":"&emsp;&emsp;在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。 算法的时间复杂度度量一个程序（算法）执行时间的两种方式[1]事后统计的方法&emsp;&emsp;这种方法可行，但是有两个问题：一是要想对设计的算法的运行性能进行测评，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件环境因素，这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。[2]事前估计的方法通过分析某个算法的时间复杂度来判断算法更优。 时间频度&emsp;&emsp;一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，他花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 时间频度的一些规则[1]可以忽略常数项，例如2n+10和2n随着n变大，执行曲线无限接近，可以忽略常数。[2]可以忽略低次项，例如2n^2^+3n+10和2n^2^随着n变大，执行曲线无限接近，可以忽略3n+10。[3]可以忽略系数，例如5n^2^+7n和3n^2^+2n，执行曲线随着n变大重合，说明这种情况下，5和3可以忽略。 时间复杂度计算[1]一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个赋值函数f(n)，是的当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。[2]T(n)不同，但时间复杂度可能相同。如：T(n)=n^2^+7n+6与T(n)=3n^2^+2n+2它们的T(n)不同，但时间复杂度相同，都为O(n^2^)。[3]计算时间复杂度的方法：用常数1代替运行时间中的所有加法常数。T(n)=3n^2^+7n+6 =&gt; T(n)=3n^2^+7n+1修改后的运行次数函数中，只保留最高阶项。T(n)=3n^2^+7n+1 =&gt; T(n)=3n^2^去除最高阶项的系数。T(n)=3n^2^ =&gt; T(n)=n^2^ =&gt; O(n^2^) 常见的时间复杂度[1]常数阶 O(1)[2]对数阶 O(log2n)[3]线性阶 O(n)[4]线性对数阶 O(nlog2n)[5]平方阶 O(n^2^)[6]立方阶 O(n^3^)[7]k次方阶 O(n^k^)[8]指数阶 O(2^n^)说明：&emsp;&emsp;常见的算法时间复杂度由小到大依次为:O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2^)&lt;O(n^3^)&lt;O(n^k^)&lt;O(2^n^)，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。&emsp;&emsp;从图中可见，我们应该尽可能避免指数阶的算法。 常见时间复杂度举例说明 常数阶O(1)无论执行了多少行代码，只要是没有循环等复杂结构，这个代码的时间复杂度都是O(1)。12345int i = 1;int j = 2;++i;j++;int m = i+j; 上述代码在执行的时候，她消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。 对数阶O(log2n)1234int i =1;while(i&lt;n)&#123; i = i * 2;&#125; 说明：在while循环里面，每次都将i乘以2，乘完之后，i距离n就越来越近了。假设循环x之后，i就大于n了，此时这个循环就退出了，也就是说2的x次方等于2，那么x = log2n也就是说当循环log2n次后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)。O(log2n)的这个2实际上是根据代码变化的，i = i * 3，则是O(log3n)。 线性阶O(n)1234for(int i=1;i&lt;=n;i++)&#123; j = i; j++;&#125; 说明：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。 线性对数阶O(nlog2n)123456for(int i=1;i&lt;n;i++)&#123; m = 1; while(m&lt;n)&#123; m = m*2; &#125;&#125; 说明：线性对数阶O(nlog2n)其实非常容易理解，将时间复杂度为O(log2n)的代码循环N遍的话，那么它的时间复杂度就是n*O(log2n)，也就是O(nlog2n)。 平方阶O(n^2^)123456for(int x = 1;x&lt;=n;x++)&#123; for(int i = 1;i&lt;=n;i++)&#123; j = 1; j++; &#125;&#125; 说明：平方阶O(n^2^)就更容易理解了，如果把O(n)的代码再嵌套循环一遍，它的时间复杂度就是O(n^2^)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是O(nn)，即O(n^2^)如果将其中一层循环的n改成m，那么它的时间复杂度就变成了O(mn)。 立方阶 O(n^3^)、k次方阶 O(n^k^)这个可以参考上面的平方阶O(n^2^)去理解，O(n^3^)相当于三层n循环，其它类似。 平均时间复杂度和最坏时间复杂度[1]平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。[2]最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法再任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。[3]平均时间复杂度和最坏时间复杂度是否一致，和算法有关（如下图）。 算法的空间时间复杂度[1]类似于时间复杂度的讨论，一个算法的空间复杂度（Space Complexity）定义为该算法所耗费的存储空间，它也是我问题规模n的函数。[2]空间复杂度（Space Complexity）是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数于解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。[3]在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的是程序执行的速度。一些缓存产品（redis，memcache）和算法（基数排序）本质就是用空间换时间。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-递归","date":"2019-11-29T07:49:27.294Z","path":"2019/11/29/数据结构和算法-递归/","text":"递归的概念：&emsp;&emsp;简单的说，递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。 递归的调用机制递归调用的规则[1]当程序执行到一个方法时，就会开辟一个独立的空间（栈）。[2]每个空间的数据(局部变量)，是独立的。用一个案例，理解递归机制。 1234567891011public class RecursionTest &#123; public static void main(String[] args) &#123; test(3); &#125; public static void test(int n)&#123; if(n&gt;2)&#123; test(n-1); &#125; System.out.println(\"n=\"+n); &#125;&#125; 上面这个程序的过程分析其在控制台的输出为则为n=2n=3 递归能解决什么样的问题[1]各种数学问题：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题。[2]各种算法中也会使用到递归，比如快速排序，归并排序，二分查找，分治算法等。[3]将用栈解决的问题–&gt;递归代码比较简洁。 递归需要遵守的重要规则[1]执行一个方法时，就创建一个新的受保护的独立空间（栈空间）。[2]方法的局部变量是独立的，不会相互影响。[3]但是如果方法中使用的是引用类型的变量(比如说是数组)，就会共享该引用类型的数据。[4]递归必须向退出的条件逼近，否则就是无限递归，会出现StackOverflowError(栈溢出)异常。[5]当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。 递归-迷宫问题说明：[1]小球得到的路径，和程序员设置的找路策略有关即：找路的上下左右顺序相关。[2]再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变[3]测试回溯现象。[4]思考：如何得到最短路径？(把所有的策略走的路径算出来，比较最短路径)代码实现上面的走迷宫问题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class MiGong &#123; public static void main(String[] args) &#123; //先创建一个二位数组，模拟迷宫 //地图 int[][] map = new int[8][7]; //使用1表示墙 //上下全部置为1 for(int i = 0;i&lt;7;i++)&#123; map[0][i]=1;map[7][i]=1; &#125; //左右全部置为1 for(int i = 0;i&lt;8;i++)&#123; map[i][0]=1;map[i][6]=1; &#125; //设置挡板 map[3][1]=1;map[3][2]=1; //输出地图 System.out.println(\"地图情况\"); for(int i = 0;i&lt;8;i++)&#123; for(int j=0;j&lt;7;j++)&#123; System.out.print(map[i][j]+\" \"); &#125; System.out.println(); &#125; //使用递归回溯给小球找路 setWay(map, 1, 1); //输出新的地图，小球走过，并标识过的地图 System.out.println(\"小球走过并标识的地图\"); for(int i = 0;i&lt;8;i++)&#123; for(int j=0;j&lt;7;j++)&#123; System.out.print(map[i][j]+\" \"); &#125; System.out.println(); &#125; &#125; //使用递归回溯来给小球找路 //说明 //1、map表示地图 //2、i，j表示从地图哪个为止开始出发（1，1） //3、如果小球能到达map[6][5]位置，则说明通路找到 //4、约定：当map[i][j]为0表示该点没有走过，当为1表示墙，2表示通路可以走，3表示该为止已经走过，但是走不通 //5、在走迷宫时，必须先确定一个策略（方法）：下-&gt;右-&gt;上-&gt;左，如果该点走不通，再回溯 /** * @param map 表示地图 * @param i 从那个位置开始找 * @param j 从那个位置开始找 * @return 如果找到通路，则返回true，否则返回false */ public static boolean setWay(int[][] map,int i,int j)&#123; if(map[6][5] == 2)&#123;//通路已经找到 return true; &#125;else&#123; if(map[i][j] == 0)&#123;//如果当前这个点没有走过 //按照策略 下-&gt;右-&gt;上-&gt;左 走 map[i][j] = 2;//假定该点是能走通的 if(setWay(map, i+1, j))&#123;//向下走 return true; &#125;else if(setWay(map, i, j+1))&#123;//向右走 return true; &#125;else if(setWay(map, i-1, j))&#123;//向上走 return true; &#125;else if(setWay(map, i, j-1))&#123;//向左走 return true; &#125;else&#123; map[i][j] = 3;//该点走过了，根本走不通 &#125; &#125;else &#123;//如果map[i][j]!=0，可能是1 ，2，3 return false; &#125; &#125; return false; &#125;&#125; 递归-八皇后问题（回溯算法）八皇后问题：&emsp;&emsp;八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8*8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行，同一列或同一斜线上，问有多少种摆法。八皇后问题算法思路分析：[1]第一个皇后先放在第一行第一列[2]第二个皇后放在第二行第一列、然后判断是否ok，如果不ok，继续放在第二列，第三列，依次把所有列都放完，找到一个合适的。[3]继续第三个皇后，还是第一列，第二列…直到第八个皇后也能放在一个不冲突的位置，算是找到了一个正确解释。[4]当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到。[5]然后回头继续第一个皇后放在第二列，后面继续循环执行1，2，3的步骤。说明：理论上应该创建一个二维数组来表示棋盘，但实际上可以通过算法，用一个一维数组即可解决问题。arr[8]={0,4,7,5,2,6,1,3}//对应arr下标表示第几行，即第几个皇后，arr[i]=val 表示第i+1个皇后，方法第i+1行的val+1列。八皇后的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Queue8 &#123; //定义一个max表示共有多少个皇后 int max = 8; //定义一个数组array，保存皇后放置位置的结果，比如array = &#123;0,4,7,5,2,6,1,3&#125; int[] array = new int[max]; static int count = 0; public static void main(String[] args) &#123; Queue8 queue8 = new Queue8(); queue8.check(0); System.out.println(\"一共有\"+count+\"种解法。\"); &#125; //编写一个方法，放置第n个皇后 private void check(int n)&#123; if(n == max)&#123;//n=8,其实八个皇后就已然放好了 print(); return; &#125; //依次放入皇后，并判断是否冲突 for(int i=0;i&lt;max;i++)&#123; //先把当前这个皇后n，放到该行的第1列 array[n] = i; //判断当放置第n个皇后的第i列时，是否冲突 if(judge(n))&#123;//不冲突 //接着放第n+1个皇后，即开始递归 check(n+1); &#125; //如果冲突，没有关系，就继续执行array[n] = i;即将第n个皇后放置在本行的后移的一个位置 &#125; &#125; //查看当我们放置第n个皇后时，就去检查该皇后是否和前面已经摆放的皇后冲突 private boolean judge(int n)&#123; for(int i=0;i&lt;n;i++)&#123; //说明： //1、array[i]==array[n] 表示判断第n个皇后是否和前面的n-1个皇后在同一列 //2、Math.abs(n-i)==Math.abs(array[n]-array[i]) 表示判断第n个皇后和第i个皇后是否在同一斜线 //3、判断是否在同一行，没有必要判断，因为n每次在递增 if(array[i]==array[n] || Math.abs(n-i)==Math.abs(array[n]-array[i]))&#123; return false; &#125; &#125; return true; &#125; //写一个方法，可以将皇后摆放的位置输出 private void print()&#123; count++; for(int i=00;i&lt;array.length;i++)&#123; System.out.print(array[i]+\" \"); &#125; System.out.println(); &#125;&#125; 输出的结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192930 4 7 5 2 6 1 3 0 5 7 2 6 3 1 4 0 6 3 5 7 1 4 2 0 6 4 7 1 3 5 2 1 3 5 7 2 0 6 4 1 4 6 0 2 7 5 3 1 4 6 3 0 7 5 2 1 5 0 6 3 7 2 4 1 5 7 2 0 3 6 4 1 6 2 5 7 4 0 3 1 6 4 7 0 3 5 2 1 7 5 0 2 4 6 3 2 0 6 4 7 1 3 5 2 4 1 7 0 6 3 5 2 4 1 7 5 3 6 0 2 4 6 0 3 1 7 5 2 4 7 3 0 6 1 5 2 5 1 4 7 0 6 3 2 5 1 6 0 3 7 4 2 5 1 6 4 0 7 3 2 5 3 0 7 4 6 1 2 5 3 1 7 4 6 0 2 5 7 0 3 6 4 1 2 5 7 0 4 6 1 3 2 5 7 1 3 0 6 4 2 6 1 7 4 0 3 5 2 6 1 7 5 3 0 4 2 7 3 6 0 5 1 4 3 0 4 7 1 6 2 5 3 0 4 7 5 2 6 1 3 1 4 7 5 0 2 6 3 1 6 2 5 7 0 4 3 1 6 2 5 7 4 0 3 1 6 4 0 7 5 2 3 1 7 4 6 0 2 5 3 1 7 5 0 2 4 6 3 5 0 4 1 7 2 6 3 5 7 1 6 0 2 4 3 5 7 2 0 6 4 1 3 6 0 7 4 1 5 2 3 6 2 7 1 4 0 5 3 6 4 1 5 0 2 7 3 6 4 2 0 5 7 1 3 7 0 2 5 1 6 4 3 7 0 4 6 1 5 2 3 7 4 2 0 6 1 5 4 0 3 5 7 1 6 2 4 0 7 3 1 6 2 5 4 0 7 5 2 6 1 3 4 1 3 5 7 2 0 6 4 1 3 6 2 7 5 0 4 1 5 0 6 3 7 2 4 1 7 0 3 6 2 5 4 2 0 5 7 1 3 6 4 2 0 6 1 7 5 3 4 2 7 3 6 0 5 1 4 6 0 2 7 5 3 1 4 6 0 3 1 7 5 2 4 6 1 3 7 0 2 5 4 6 1 5 2 0 3 7 4 6 1 5 2 0 7 3 4 6 3 0 2 7 5 1 4 7 3 0 2 5 1 6 4 7 3 0 6 1 5 2 5 0 4 1 7 2 6 3 5 1 6 0 2 4 7 3 5 1 6 0 3 7 4 2 5 2 0 6 4 7 1 3 5 2 0 7 3 1 6 4 5 2 0 7 4 1 3 6 5 2 4 6 0 3 1 7 5 2 4 7 0 3 1 6 5 2 6 1 3 7 0 4 5 2 6 1 7 4 0 3 5 2 6 3 0 7 1 4 5 3 0 4 7 1 6 2 5 3 1 7 4 6 0 2 5 3 6 0 2 4 1 7 5 3 6 0 7 1 4 2 5 7 1 3 0 6 4 2 6 0 2 7 5 3 1 4 6 1 3 0 7 4 2 5 6 1 5 2 0 3 7 4 6 2 0 5 7 4 1 3 6 2 7 1 4 0 5 3 6 3 1 4 7 0 2 5 6 3 1 7 5 0 2 4 6 4 2 0 5 7 1 3 7 1 3 0 6 4 2 5 7 1 4 2 0 6 3 5 7 2 0 5 1 4 6 3 7 3 0 2 5 1 6 4 一共有92种解法。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-栈（[逆]波兰表达式）","date":"2019-11-24T11:08:45.539Z","path":"2019/11/24/数据结构和算法-栈（[逆]波兰表达式）/","text":"什么是栈？[1]栈的英文名为Stack[2]栈是一个先入后出（FILO-Firest In Last Out）的有序列表[3]栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶，另一端为固定的一端，称为栈底。[4]根据栈的定义可知，最先放入栈的元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。 出栈和入栈入栈（push）：出栈（pop）： 栈的应用场景[1]子程序的调用：在跳往子程序前，会先将一下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。[2]处理递归调用：和子程序的调用类似，只是除了存储下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。[3]表达式的转换与求值（实际解决）。[4]二叉树的遍历。[5]图形的深度优先（depth-first）搜索算法。 栈的快速入门用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来存储栈的数据内容。思路分析：[1]使用数组模拟栈[2]定义一个top表示栈顶，初始值为-1[3]入栈的操作，当有数据加入到栈时，top++；stack[top]=data；[4]出栈的操作，int value=stack[top];top–,return value;代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//定义一个类表示栈结构class ArrayStack&#123; private int maxSize;//栈的大小 private int[] stack;//数组，模拟栈，数据就放在该数组中 private int top = -1;//栈顶，初始化为-1 //构造器 public ArrayStack(int maxSize)&#123; this.maxSize = maxSize; stack = new int[this.maxSize]; &#125; //栈满 public boolean isFull()&#123; return top == maxSize-1; &#125; //栈空 public boolean isEmpty()&#123; return top == -1; &#125; //入栈 public void push(int value)&#123; //先判断栈是否满 if(isFull())&#123; System.out.println(\"栈满\"); return; &#125; top++; stack[top] = value; &#125; //出栈,将栈顶的数组返回 public int pop()&#123; //先判断栈是否空 if(isEmpty())&#123; //抛出异常 throw new RuntimeException(\"栈空，没有数据~\"); &#125; int value = stack[top]; top--; return value; &#125; //显示栈的情况(遍历栈),遍历时，需要从栈顶开始显示数据 public void list()&#123; if(isEmpty())&#123; System.out.println(\"栈空~\"); return; &#125; for(int i = top;i &gt;= 0;i--)&#123; System.out.printf(\"stack[%d]=%d\\n\",i,stack[i]); &#125; &#125;&#125; 栈实现综合计算器（中缀表达式） 中缀表达式：[1]中缀表达式就是常见的运算表达式：如(3+4)X5-6[2]中缀表达式的求值是我们人最熟悉的，但是对于计算机来说却不好操作，因此在计算结果时，往往会将中缀表达式转换成其它表达式来操作 是用栈完成表达式的计算思路：[1]通过一个index值（索引），来遍历我们的表达式[2]创建两个栈，一个存放数值的栈，一个存放符号的栈[3]如果发现是一个数字，就直接放入数栈[4]如果发现的是一个符号，就分如下情况（1）如果发现当前的符号栈为空，就直接入栈（2）如果符号栈有操作符，就进行比较，如果当前的操作符的有限级小于或者等于栈中的操作符，就需要从数栈栈pop出两个数，在从符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的操作符入符号栈（3）如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈[5]当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号并运行。[6]最后在数栈中只有一个数字，就是表达式的结果。 代码：栈结构：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class ArrayStack2&#123; private int maxSize;//栈的大小 private int[] stack;//数组，模拟栈，数据就放在该数组中 private int top = -1;//栈顶，初始化为-1 public ArrayStack2(int maxSize)&#123;//构造器 this.maxSize = maxSize; stack = new int[this.maxSize]; &#125; //查看栈顶的值，不是真正的出栈 public int peek()&#123; return stack[top]; &#125; public boolean isFull()&#123;//栈满 return top == maxSize-1; &#125; public boolean isEmpty()&#123;//栈空 return top == -1; &#125; public void push(int value)&#123;//入栈 //先判断栈是否满 if(isFull())&#123; System.out.println(\"栈满\"); return; &#125; top++; stack[top] = value; &#125; public int pop()&#123;//出栈,将栈顶的数组返回 //先判断栈是否空 if(isEmpty())&#123; //抛出异常 throw new RuntimeException(\"栈空，没有数据~\"); &#125; int value = stack[top]; top--; return value; &#125; public void list()&#123; //显示栈的情况(遍历栈),遍历时，需要从栈顶开始显示数据 if(isEmpty())&#123; System.out.println(\"栈空~\"); return; &#125; for(int i = top;i &gt;= 0;i--)&#123; System.out.printf(\"stack[%d]=%d\\n\",i,stack[i]); &#125; &#125; //返回运算符的优先级，优先级使用数字表示，数字越大优先级越高 public int priority(int oper)&#123; if(oper == '*' || oper == '/')return 1; else if(oper == '+' || oper == '-') return 0; else return -1;//表达式只有+-*/ &#125; //判断是不是一个运算符 public boolean isOper(char val)&#123; return val == '+' || val == '-' || val == '*' || val == '/'; &#125; //计算方法 public int cal(int num1,int num2,int oper)&#123; int res = 0;//res用于存放计算结果 switch (oper) &#123; case '+': res = num1 + num2; break; case '-': res = num2 - num1;//注意顺序 break; case '*': res = num1 * num2; break; case '/': res = num2 / num1; break; default: break; &#125; return res; &#125;&#125; 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public static void main(String[] args) &#123; //表达式 String expression = \"3+2*6-2\"; //创建两个栈，一个是数栈，一个是符号栈 ArrayStack2 numStack = new ArrayStack2(10); ArrayStack2 operStack = new ArrayStack2(10); //定义相关变量 int index = 0;//用于扫描 int num1 = 0; int num2 = 0; int oper = 0; int res = 0; String keepNum=\"\"; char ch = ' ';//将每次扫描得到的结果保存到ch中 //开始while循环扫描 while(true)&#123; //依次得到expression的每一个字符 ch = expression.substring(index, index+1).charAt(0); //判断ch是什么，然后做相应的处理 if(operStack.isOper(ch))&#123;//如果是运算符 //判断当前的符号栈是否为空 if(!operStack.isEmpty())&#123; //如果符号栈有操作符，就进行比较，如果当前的操作符的有限级小于或者等于栈中的操作符 //就需要从数栈栈pop出两个数，在从符号栈中pop出一个符号，进行运算 //将得到的结果，入数栈，然后将当前的操作符入符号栈 if(operStack.priority(ch) &lt;= operStack.priority(operStack.peek()))&#123; num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); //把运算的结果入数栈 numStack.push(res); //然后把当前的操作符入符号栈 operStack.push(ch); &#125;else&#123; //如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈 operStack.push(ch); &#125; &#125;else&#123; //如果为空，直接入栈 operStack.push(ch); &#125; &#125;else&#123; //如果是数，则直接入数栈 //当处理多为数时，不能发现一个数就直接就入栈，因为可能是多位数】 //在处理数时，需要向expression的表达式的index后再看一位，如果是数就进行扫描，如果是符号就入栈 //因此需要定义一个变量 字符串，用于拼接 keepNum += ch; //如果ch已经是expression的最后一位，就直接入栈 if(index == expression.length() - 1)&#123; numStack.push(Integer.parseInt(keepNum)); &#125;else&#123; //判断字符串是不是数字，如果是数字就继续扫描，如果是运算符就入栈 if(operStack.isOper(expression.substring(index+1,index+2).charAt(0)))&#123; //如果后以为是运算符，则入栈 numStack.push(Integer.parseInt(keepNum)); //这里keepNum要置空 keepNum=\"\"; &#125; &#125; &#125; //让index + 1，并判断是否扫描到expression index++; if(index &gt;= expression.length())&#123; break; &#125; &#125; //当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号并运行。 while(true)&#123; //如果符号栈为空，则计算到最后的结果，数栈只有一个数字，这个就是结果 if(operStack.isEmpty())break; num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); numStack.push(res); &#125; //将数栈最后的结果pop出来 System.out.printf(\"表达式%s = %d\",expression,numStack.pop());&#125; 结果： 1表达式3+2*6-2 = 13 前缀表达式（波兰表达式） 前缀表达式的计算机求值：&emsp;&emsp;从右向左扫描表达式，遇到数字时，将数字压入栈中，遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算（栈顶元素和次顶元素），并将结果入栈；重复上述过程知道表达式最左端，最后运算得出的值即为表达式的结果。 例如：(3+4)X5-6对应的前缀表达式就是- X + 3 4 5 6 ,针对前缀表达式求值步骤如下：[1]从右至左扫描，将6、5、4压入堆栈。[2]遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算3+4的值，得7，再将7入栈。[3]接下来是X运算符，因此弹出7和5，计算出7X5=35，将35入栈。[4]最后是-运算符，计算出35-6的值，即29.由此得出最终结果。后缀表达式（逆波兰表达式） 后缀表达式[1]后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后[2]举例说明：(3+4)X5-6对应的后缀表达式就是3 4 + 5 X 6 -[3]再比如a+b 对应的后缀表达式为 a b +a+(b-c) 对应的后缀表达式为 a b c - +a+(b-c)d 对应的后缀表达式为 a b c - d * +a+d(b-c) 对应的后缀表达式为 a d b c - * +a=1+3 对应的后缀表达式为 a 1 3 + = 后缀表达式的计算机求值从左向右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素和栈顶元素），并将结果入栈；重复上述过程知道表达式最右端，最后运算符得出的值即为表达式的结果。 例如：(3+4)X5-6对应的后缀表达式就是3 4 + 5 X 6 -，针对后缀表达式求值步骤如下：[1]从左向右扫描，将3和4压入堆栈；[2]遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；[3]将5入栈；[4]接下来是X运算符，因此弹出5和7，计算7X5=35，将35入栈;[5]将6入栈；[6]最后是-运算符，计算出35-6的值，即29，由此得出最终结果。逆波兰计算器代码实现 逆波兰计算器，完成任务如下：[1]输入一个逆波兰表达式(后缀表达式)，使用栈（Stack），计算其结果[2]支持小括号和多位数整数 思路：(3+4)X5-6对应的后缀表达式就是3 4 + 5 X 6 -，针对后缀表达式求值步骤如下：[1]从左向右扫描，将3和4压入堆栈；[2]遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；[3]将5入栈；[4]接下来是X运算符，因此弹出5和7，计算7X5=35，将35入栈;[5]将6入栈；[6]最后是-运算符，计算出35-6的值，即29，由此得出最终结果。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.ArrayList;import java.util.List;import java.util.Stack;public class PolandNotation &#123; public static void main(String[] args) &#123; //定义一个逆波兰表达式 //(3+4)x5-6 =&gt; 3 4 + 5 x 6 - //为了方便，逆波兰表达式中的数字和符号使用空格隔开 String suffixExpression = \"3 4 + 5 * 6 -\"; //思路 //1、向将\"3 4 + 5 x 6 -\" =&gt; 放入ArrayList中 //2、将ArrayList传递给一个方法，遍历ArrayList 配合栈完成计算 List&lt;String&gt; list = getListString(suffixExpression); System.out.println(\"rpnList=\"+list); int res = calculate(list); System.out.println(\"计算的结果为=\"+res); &#125; //将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中 public static List&lt;String&gt; getListString(String suffixExpression)&#123; //将suffixExpression分割 String[] split = suffixExpression.split(\" \"); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(String ele : split)&#123; list.add(ele); &#125; return list; &#125; /* 完成对逆波兰表达式的运算 * (3+4)X5-6对应的后缀表达式就是3 4 + 5 X 6 -，针对后缀表达式求值步骤如下： * [1]从左向右扫描，将3和4压入堆栈； * [2]遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈； * [3]将5入栈； * [4]接下来是X运算符，因此弹出5和7，计算7X5=35，将35入栈; * [5]将6入栈； * [6]最后是-运算符，计算出35-6的值，即29，由此得出最终结果。 */ public static int calculate(List&lt;String&gt; ls)&#123; //创建一个栈,只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); //遍历 for(String item : ls)&#123; //这里使用一个正则表达式取出数 if(item.matches(\"\\\\d+\"))&#123;//匹配的是多位数 //入栈 stack.push(item); &#125;else&#123; //pop出两个数，并运算，再入栈 int num2 = Integer.parseInt(stack.pop()); int num1 = Integer.parseInt(stack.pop()); int res = 0; if(item.equals(\"+\"))&#123; res = num1 + num2; &#125;else if(item.equals(\"-\"))&#123; res = num1 - num2; &#125;else if(item.equals(\"*\"))&#123; res = num1 * num2; &#125;else if(item.equals(\"/\"))&#123; res = num1 / num2; &#125;else&#123; throw new RuntimeException(\"运算符有误\"); &#125; //把res入栈 stack.push(res+\"\"); &#125; &#125; //最后留在stack中的数据就是运算结果 return Integer.parseInt(stack.pop()); &#125;&#125; 结果： 12rpnList=[3, 4, +, 5, *, 6, -]计算的结果为=29 中缀表达式转换为后缀表达式&emsp;&emsp;从上面的案例可以看出，后缀表达式适合计算机进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将中缀表达式转成后缀表达式。 具体步骤如下：[1]初始化两个栈：运算符栈s1和储存中间结果的栈s2；[2]从左向右扫描中缀表达式；[3]遇到操作数时，将其压s2；[4]遇到运算符时，比较其与s1栈顶运算符的优先级：（1）如果s1为空，或栈顶运算符为左括号”（“，则直接将此运算符入栈；（2）否则，若优先级比栈顶运算符的高，也将元算符压入s1；（3）否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较。[5]遇到括号时：（1）如果是左括号“（”，则直接压入s1；（2）如果是右括号“）”，则异常弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃。[6]重复步骤2-5，直到表达式的最右边；[7]将s1中剩余的运算符依次弹出并压入s2；[8]依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。 例如：1+((2+3)X4)-5 其转换过程如下表：代码实现：编写一个类Operation 实现可以返回一个运算符对应的优先级数字123456789101112131415161718192021222324252627//编写一个类Operration 可以返回一个运算符对应的优先级class Operation&#123; private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; //写一个方法，返回一个优先级数字 public static int getValue(String operation)&#123; int result = 0; switch (operation) &#123; case \"+\": result = ADD; break; case \"-\": result = SUB; break; case \"*\": result = MUL; break; case \"/\": result = DIV; break; default: &#125; return result; &#125;&#125; 书写可以将一个中缀表达式字符串转换成字符然后返回List的方法 1234567891011121314151617181920212223//将中缀表达式转换成对应的Listpublic static List&lt;String&gt; toInfixExpressionList(String s)&#123; //定义一个list，存放中缀表达式对应的内容 List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); int i = 0;//相当于一个指针，用于遍历中缀表达式字符串 String str;//做多为数的拼接 char c;//每对应一个字符，就放入c中 do&#123; //如果c是一个非数字，就需要加入到ls if((c=s.charAt(i))&lt;48||(c=s.charAt(i))&gt;57)&#123; ls.add(\"\"+c); i++;//i需要后移 &#125;else&#123;//如果c是一个数字，需要考虑多为数的问题 str = \"\";//先将str置成空 while(i &lt; s.length() &amp;&amp; (c=s.charAt(i))&gt;=48 &amp;&amp; (c=s.charAt(i))&lt;=57)&#123; str +=c;//拼接 i++; &#125; ls.add(str); &#125; &#125;while(i&lt;s.length()); return ls;&#125; 书写一个可以将中缀表达式对应的List转换成后缀表达式对应的List的方法 1234567891011121314151617181920212223242526272829303132333435//将中缀表达式转换成对应的后缀表达式//即ArrayList[1,+,(,(,2,+,3,),*,4,),-,5] =&gt; ArrayList[1,2,3,+,4,*,+,5,-]public static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls)&#123; //定义两个栈 Stack&lt;String&gt; s1 = new Stack&lt;String&gt;();// 符号栈 //因为s2这个栈，在转换过程中，没有pop操错，后面还要逆序输出，因此可以直接使用List替代 List&lt;String&gt; s2 = new ArrayList&lt;String&gt;();//存储中间结果的List s2 //遍历ls for(String item : ls)&#123; //如果是一个数，加入s2 if(item.matches(\"\\\\d+\"))&#123; s2.add(item); &#125;else if(item.equals(\"(\"))&#123; s1.push(item); &#125;else if(item.equals(\")\"))&#123; //如果是右括号“）”，则异常弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃。 while(!s1.peek().equals(\"(\"))&#123; s2.add(s1.pop()); &#125; s1.pop();//将这个小括号(弹出s1栈，消除小括号 &#125;else &#123; //当item的优先级小于等于s1栈顶运算符的优先级，将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较 while(s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item))&#123; s2.add(s1.pop()); &#125; //还需要将item压入栈中 s1.push(item); &#125; &#125; //将s1中剩余的运算符依次弹出并加入s2 while(s1.size()!=0)&#123; s2.add(s1.pop()); &#125; return s2; //注意因为是存放到List，因此按顺序输出就是对应的逆波兰表达式&#125; 测试： 123456789101112131415public static void main(String[] args) &#123; //完成将一个中缀表达式转换成后缀表达式的功能 //说明 //1、1+((3+3)*4)-5 转成 1 2 3 + 4 * + 5 - //2、因为直接对一个字符串进行操作，不方便，因此先将“1+((3+3)*4)-5”转成中缀表达式对应的List // 即“1+((3+3)*4)-5” =&gt; ArrayList[1,+,(,(,2,+,3,),*,4,),-,5] //3、得到的中缀表达式对应的List转成一个后缀表达式的List // 即ArrayList[1,+,(,(,2,+,3,),*,4,),-,5] =&gt; ArrayList[1,2,3,+,4,*,+,5,-] String expreession = \"1+((2+3)*4)-5\"; List&lt;String&gt; infixExpressionList = toInfixExpressionList(expreession); System.out.println(\"中缀表达式对应的List：\"+infixExpressionList); List&lt;String&gt; parseSuffixExpressionList = parseSuffixExpressionList(infixExpressionList); System.out.println(\"后缀表达式对应的List：\"+parseSuffixExpressionList);&#125; 结果： 12中缀表达式对应的List：[1, +, (, (, 2, +, 3, ), *, 4, ), -, 5]后缀表达式对应的List：[1, 2, 3, +, 4, *, +, 5, -]","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-单向环形链表(约瑟夫环问题)","date":"2019-11-23T12:56:37.078Z","path":"2019/11/23/数据结构和算法-单向环形链表(约瑟夫环问题)/","text":"Josephu（约瑟夫、约瑟夫环）问题：设编号为1，2，…，n的n个人围坐一圈，约定的编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到的那个人又出列，依此类推，知道所有人出列为止，由此产生一个出队编号的序列。用一个不带头节点的循环链表来处理Josepho问题：先构成一个有n个节点的单循环链表，然后由k节点起从1开始计数，计到m时，对应节点从链表中删除，直到最后一个节点从链表中删除算法结束。 单向环形链表的介绍链表形成一个环状 约瑟夫问题的图释Josephu（约瑟夫、约瑟夫环）问题：设编号为1，2，…，n的n个人围坐一圈，约定的编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到的那个人又出列，依此类推，知道所有人出列为止，由此产生一个出队编号的序列。以上图的出队顺序为：2-&gt;4-&gt;1-&gt;5-&gt;3 约瑟夫问题的代码实现思路：构建一个环形链表[1]创建第一个节点，让一个指针(变量)first指向该节点，并形成一个环形[2]后面当我们每创建一个节点，就把该节点，加入到已有的环形链表中即可遍历环形链表[1]先让一个辅助指针(变量)curBoy，指向first节点[2]然后通过一个while循环遍历该环形链表即可[3]当curBoy.next == first 遍历结束代码：书写节点类Boy 1234567891011121314151617181920//创建一个Boy类，表示一个节点class Boy &#123; private int no;//编号 private Boy next;//指向下一个节点，默认为空 public Boy(int no)&#123; this.no=no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125;&#125; 创建一个环形单向链表 12345678910111213141516171819202122232425262728293031323334353637383940414243//创建一个环形的单向链表class CircleSingkeLinkedList &#123; //创建一个first节点，当前没有编号 private Boy first = null; //添加小孩节点，构成一个环形的链表 public void addBoy(int nums)&#123; //nums 做一个数据校验 if(nums&lt;1)&#123; System.out.println(\"nums的值不正确\"); return; &#125; Boy curBoy = null;//辅助指针，帮助构建环形链表 //使用for循环创建环形链表 for(int i = 1;i &lt;= nums; i++) &#123; //根据编号创建小孩节点 Boy boy = new Boy(i); //如果是第一个小孩 if(i==1) &#123; first = boy; first.setNext(first);//构成环 curBoy = first;//让curBoy指向第一个小孩 &#125; else &#123; curBoy.setNext(boy); boy.setNext(first); curBoy = boy; &#125; &#125; &#125; //遍历当前环形链表 public void showBoy() &#123; //判断链表是否为空 if(first==null) &#123; System.out.println(\"链表为空！\");return; &#125; //因为first不能动，因此仍然使用辅助指针完成遍历 Boy curBoy = first; while(true) &#123; System.out.printf(\"小孩的编号%d\\n\",curBoy.getNo()); if(curBoy.getNext()==first)break;//说明已经遍历完毕 curBoy = curBoy.getNext();//curBoy后移 &#125; &#125;&#125; 根据用户的输入，生成一个小孩出圈的顺序[1]需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这个节点。[2]小孩报数前，先让first和helper移动k-1次[2]当小孩报数时，让first和helper同时移动m-1次[3]这时就可以将first指向的小孩节点出圈first=first.nexthelper.next=first[4]原来first指向的这个节点就没有任何引用了向环形单向链表类CircleSingkeLinkedList中添加出圈这个方法 123456789101112131415161718192021222324252627282930313233343536373839404142//根据用户的输入，计算小孩出圈的顺序/** * @param startNo 表示从第几个小孩开始数数 * @param countNum 表示数几下 * @param nums 表示最初有多少小孩在圈中 */public void countBoy(int startNo,int countNum,int nums) &#123; //先对数据进行校验 if(first==null||startNo&lt;1||startNo&gt;nums)&#123; System.out.println(\"参数输入有误！\");return; &#125; //创建一个辅助指针，帮助完成小孩出圈 Boy helper = first; //需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这个节点。 while(true) &#123; if(helper.getNext() == first) &#123; //说明helper指向最后小孩节点 break; &#125; helper = helper.getNext(); &#125; //小孩报数前，先让first和helper移动k-1次 for(int j = 0;j&lt;startNo - 1;j++)&#123; first = first.getNext(); helper = helper.getNext(); &#125; //当小孩报数时，让first和helper同时移动m-1次,然后出圈 //循环操作，知道圈中只有一个节点 while(true) &#123; if(helper == first)break;//说明圈中只有一个节点 //让first和helper同时移动countNum-1次,然后出圈 for(int j = 0;j&lt;countNum-1;j++) &#123; first = first.getNext(); helper = helper.getNext(); &#125; //这是first指向的这个小孩就是要出圈的小孩节点 System.out.printf(\"小孩%d出圈\\n\",first.getNo()); //这时将first指向的小孩节点出圈 first = first.getNext(); helper.setNext(first); &#125; System.out.printf(\"最后留在圈中的小孩编号%d\\n\",first.getNo());&#125; 测试： 123456public static void main(String[] args) &#123; //测试 CircleSingkeLinkedList c = new CircleSingkeLinkedList(); c.addBoy(5); c.countBoy(1, 2, 5);&#125; 结果： 12345小孩2出圈小孩4出圈小孩1出圈小孩5出圈最后留在圈中的小孩编号3","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-双向链表","date":"2019-11-23T09:51:56.565Z","path":"2019/11/23/数据结构和算法-双向链表/","text":"在学习单向链表的时候，使用带head头的双向链表实现-水浒英雄排行榜管理单项向链表的缺点分析：[1]单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。[2]单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面单链表删除节点时，总是找到temp，temp是代删除节点的前一个节点。分析 双向链表的遍历，添加，修改，删除的操作思路==》代码实现[1]遍历方式和单链表一样，只是可以向前，也可以向后[2]添加（默认添加到双向链表的最后这个节点）（1）先找到双向链表的最后这个节点（2）temp.next=newHeroNode（使最后这个节点直接指向新的节点）（3）newHeroNode.pre=temp（使新添加进来的节点的pre指向上一个节点）[3]修改思路和原理和单向链表一样[4]删除（1）因为是双向链表，因此，可以自我删除某个节点，而不需要想单链表一样找到前一个节点才能删除（2）直接找到要删除的节点，比如temp（3）temp.pre.next=temp.next（要删除节点的上一个节点指向的下一个节点为要删除节点的下一个节点）（4）temp.next.pre=temp.pre（要删除节点的下一个节点指向的上一个节点为要删除节点的上一个节点） 双向链表的代码实现创建节点类HeroNode 12345678910111213141516171819// 创建一个节点类HeroNode，每个HeroNode对象就是一个节点class HeroNode &#123; public int no; public String nickname; public String name; public HeroNode next;// 指向下一个节点 public HeroNode pre;// 指向上一个节点 // 构造器 public HeroNode(int no, String name, String nickname) &#123; this.no = no; this.name = name; this.nickname = nickname; &#125; @Override public String toString() &#123; return \"HeroNode [no=\" + no + \", nickname=\" + nickname + \", name=\" + name + \", next=\" + next + \", pre=\" + pre + \"]\"; &#125;&#125; 创建一个双向链表的类DoubleLinkedList 123456789// 创建一个双向链表的类class DoubleLinkedList &#123; //先初始化一个头节点，头节点不要动，不存放具体的数据 private HeroNode head = new HeroNode(0,\"\",\"\"); //放回头节点 public HeroNode getHead()&#123; return head; &#125;&#125; 双向链表的遍历双向链表的遍历，和单向链表一样。(在双向链表的类DoubleLinkedList中添加方法list()来显示双向链表) 123456789101112131415161718//显示链表public void list()&#123; //判断链表是否为空 if(head.next==null)&#123; System.out.println(\"链表为空\"); return; &#125; //因为头节点不能动，因此我们需要一个辅助变量来遍历 HeroNode temp = head.next; while(true)&#123; //判断是否到最后 if(temp == null)break; //输出节点信息 System.out.println(temp); //将next后移,不后移将会是一个死循环 temp = temp.next; &#125;&#125; 双向链表添加节点思路：（1）先找到双向链表的最后这个节点（2）temp.next=newHeroNode（使最后这个节点直接指向新的节点）（3）newHeroNode.pre=temp（使新添加进来的节点的pre指向上一个节点）代码实现（在双向链表的类DoubleLinkedList中添加方法add()来向双向链表添加节点）： 123456789101112131415public void add(HeroNode heroNode)&#123; //应为head节点不能动，因此需要一个辅助变量 temp HeroNode temp = head; //遍历链表，找到最后 while(true)&#123; //找到最后一个 if(temp.next==null) break; //没有找到最后 temp = temp.next; &#125; //当退出while循环时，temp就指向了链表的最后 //形成一个双向链表 temp.next = heroNode; heroNode.pre = temp;&#125; 双向链表的修改双向链表的节点内容修改，可单向链表的节点内容修改一样，在双向链表的类DoubleLinkedList中添加方法update()来修改双向链表节点内容 1234567891011121314151617181920212223242526//修改双向链表一个节点的内容public void update(HeroNode newHeroNode)&#123; if(head.next==null)&#123; System.out.println(\"链表为空\");return; &#125; //找到需要修改的节点，根据no编号 //定义一个辅助变量 HeroNode temp = head.next; boolean flag = false;//表示是否找到该节点 while(true)&#123; if(temp == null)break;//已经遍历完这个链表了 if(temp.no == newHeroNode.no)&#123;//找到了 flag = true; break; &#125; //后移，相当于遍历 temp = temp.next; &#125; //根据flag判断是否找到要修改的节点 if(flag)&#123; temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; &#125;else&#123; System.out.printf(\"没有找到编号%d的节点，不能修改\",newHeroNode.no); &#125;&#125; 双向链表的节点删除思路：（1）因为是双向链表，因此，可以自我删除某个节点，而不需要想单链表一样找到前一个节点才能删除（2）直接找到要删除的节点，比如temp（3）temp.pre.next=temp.next（要删除节点的上一个节点指向的下一个节点为要删除节点的下一个节点）（4）temp.next.pre=temp.pre（要删除节点的下一个节点指向的上一个节点为要删除节点的上一个节点）代码实现（在双向链表的类DoubleLinkedList中添加方法del()来表示删除双向链表中的某个节点）： 12345678910111213141516171819202122232425262728//删除节点//对于双向链表，可以直接找到要删除这个节点public void del(int no)&#123; //判断当前链表是否为空 if(head.next==null) &#123; System.out.println(\"链表为空~！无法删除\");return; &#125; HeroNode temp = head.next; boolean flag = false; //标志是否找到待删除节点 while(true)&#123; if(temp == null)break;//已经到链表最后 if(temp.no == no)&#123;//找到了待删除节点的前一个节点 flag = true; break; &#125; //后移，遍历 temp = temp.next; &#125; if(flag)&#123;//可以删除 temp.pre.next = temp.next; if(temp.next!=null) temp.next.pre = temp.pre;//如果是最后一个节点就不需要执行下面这句话，否则会出现空指针异常 &#125;else&#123; System.out.printf(\"要删除的节点%d,不存在\",no); &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-单链表","date":"2019-11-10T12:13:34.814Z","path":"2019/11/10/数据结构和算法-单链表/","text":"&emsp;&emsp;单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。 单链表介绍单链表是有序的列表，但它在内存中的存储如下：)(1)连接是以节点的方式来存储。(2)每个节点包含data域，next域：指向写一个节点。(3)如上图：链表的各个节点不一定是连续存储。(4)链表分带头节点的链表和没有头节点的链表，根据实际需求来确定。 单链表节点的添加使用带head头的单向链表实现-水浒英雄排行榜管理(1)完成对英雄任务的增删改查操作(2)第一种方法在添加英雄时，直接添加到链表的尾部（不考虑排序等问题）(3)第二种方法在添加英雄时，根据排名将名将英雄插入到指定位置（如果有这个排名，则添加失败，并给出提示） 第一种方法的实现 { 直接添加到链表的尾部（不考虑排序等问题）}定义HeroNode，每个HeroNode对象就是一个节点12345678910111213141516class HeroNode&#123; public int no; public String name; public String nickname; public HeroNode next;//指向下一个节点 //构造器 public HeroNode(int no,String name, String nickname)&#123; this.no = no; this.name = name; this.nickname = nickname; &#125; @Override public String toString() &#123; return \"HeroNode [no=\" + no + \", name=\" + name + \", nickname=\" + nickname + \"]\"; &#125;&#125; 定义一个SingleLinkedList 管理节点 12345678910111213141516171819202122232425262728293031323334353637383940414243class SingleLinkedList&#123; //先初始化一个头节点，头节点不要动,不存放具体的数据 private HeroNode head = new HeroNode(0,\"\",\"\"); /** * 添加节点到单向链表 * 当不考虑编号顺序时 * 1、找到当前链表的最后节点 * 2、将最后这个节点的next 指向新的节点 */ public void add(HeroNode heroNode)&#123; //应为head节点不能动，因此需要一个辅助变量 temp HeroNode temp = head; //遍历链表，找到最后 while(true)&#123; //找到最后一个 if(temp.next==null) break; //没有找到最后 temp = temp.next; &#125; //当退出while循环时，temp就指向了链表的最后 temp.next = heroNode; &#125; /** * 显示链表（遍历） */ public void list()&#123; //判断链表是否为空 if(head.next==null)&#123; System.out.println(\"链表为空\"); return; &#125; //因为头节点不能动，因此我们需要一个辅助变量来遍历 HeroNode temp = head.next; while(true)&#123; //判断是否到最后 if(temp == null)break; //输出节点信息 System.out.println(temp); //将next后移,不后移将会是一个死循环 temp = temp.next; &#125; &#125;&#125; 测试 12345678910111213141516public static void main(String[] args) &#123; //创建节点 HeroNode hero1 = new HeroNode(1,\"宋江\",\"及时雨\"); HeroNode hero2 = new HeroNode(2,\"卢俊义\",\"及时雨\"); HeroNode hero3 = new HeroNode(3,\"无用\",\"智多星\"); HeroNode hero4 = new HeroNode(4,\"林冲\",\"豹子头\"); //创建一个链表 SingleLinkedList singleLinkedList = new SingleLinkedList(); //加入 singleLinkedList.add(hero1); singleLinkedList.add(hero2); singleLinkedList.add(hero3); singleLinkedList.add(hero4); //显示 singleLinkedList.list();&#125; 结果 1234HeroNode [no=1, name=宋江, nickname=及时雨]HeroNode [no=2, name=卢俊义, nickname=及时雨]HeroNode [no=3, name=无用, nickname=智多星]HeroNode [no=4, name=林冲, nickname=豹子头] 第二种方法的实现 { 根据排名将名将英雄插入到指定位置（如果有这个排名，则添加失败，并给出提示）}在上面已经定义的SingleLinkedList管理HeroNode的类中添加方法addByOrder1234567891011121314151617181920212223public void addByOrder(HeroNode heroNode)&#123; //因为头节点不能动，因此我们仍然通过一个辅助指针（变量）来帮助找到添加位置 //因为单链表，因此找的temp是位于 添加位置的前一个节点，否则插入不了 HeroNode temp = head; boolean flag = false;//标识添加的编号是否存在，默认为false while(true)&#123; if(temp.next == null)break;//说明temp已经在链表最后 if(temp.next.no &gt; heroNode.no)break;//位置找到了，就在temp后面插入 else if(temp.next.no == heroNode.no)&#123;//说明希望添加的heroNode编号已经存在 flag = true;//说明编号存在 break; &#125; temp = temp.next;//后移，遍历当前链表 &#125; //判断flag的值 if(flag)&#123;//不能添加，说明编号存在 System.out.printf(\"准备插入的英雄的编号%d已经存在,不能加入。\\n\",heroNode.no); &#125;else&#123; //插入到链表中 heroNode.next = temp.next; temp.next = heroNode; &#125;&#125; 单链表节点的修改修改原来节点的name和nickname，只需要在上面定义的SingleLinkedList管理HeroNode的类中添加方法update 123456789101112131415161718192021222324252627//修改节点的信息，根据no编号修改，即no不能改//1、根据newHeroNode的no来修改public void update(HeroNode newHeroNode)&#123; if(head.next==null)&#123; System.out.println(\"链表为空\");return; &#125; //找到需要修改的节点，根据no编号 //定义一个辅助变量 HeroNode temp = head.next; boolean flag = false;//表示是否找到该节点 while(true)&#123; if(temp == null)break;//已经变量完这个链表了 if(temp.no == newHeroNode.no)&#123;//找到了 flag = true; break; &#125; //后移，相当于遍历 temp = temp.next; &#125; //根据flag判断是否找到要修改的节点 if(flag)&#123; temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; &#125;else&#123; System.out.printf(\"没有找到编号%d的节点，不能修改\",newHeroNode.no); &#125;&#125; 单链表的节点删除从单链表中删除一个节点的思路1、找到需要删除的节点的前一个节点temp2、temp.next = temp.next.next3、被删除的节点，将不会有其它应用指向，会被垃圾回收机制回收代码实现 123456789101112131415161718192021//删除节点//1、head不能动，因此我们需要一个temp辅助节点找到待删除的节点的前一个节点//2、说明我们在比较时，是temp.next.no 和需要删除的节点的no比较public void del(int no)&#123; HeroNode temp = head; boolean flag = false; //标志是否找到待删除节点 while(true)&#123; if(temp.next == null)break;//已经到链表最后 if(temp.next.no == no)&#123;//找到了待删除节点的前一个节点 flag = true; break; &#125; //后移，遍历 temp = temp.next; &#125; if(flag)&#123;//可以删除 temp.next = temp.next.next; &#125;else&#123; System.out.printf(\"要删除的节点%d,不存在\",no); &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-队列","date":"2019-11-09T07:24:13.170Z","path":"2019/11/09/数据结构和算法-队列/","text":"&emsp;&emsp;队列是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作(先入先出原则)，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列的使用场景银行排队案例：&emsp;&emsp;在银行排队办理业务的时候，如果窗口有人正在办理业务，后面等待的人会按照先后顺序排成一个队列，这个队列的人，先到的先从等待队列中出去办理业务，而后到的人要从这个队列的末尾排队，等待先到的人从这个等待队列出去办理业务之后，后到的人才能从等待队列出去。 用数组模拟队列思路分析&emsp;&emsp;队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图所示，其中maxSize是该队列的最大容量。&emsp;&emsp;因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据输入而改变，如图所示：当我们将数据存入队列时称为“addQueue”，addQueue的处理需要有两个步骤：(1)将尾指针往后移：rear+1，当front==rear 时，为空队列。(2)若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear==maxSize-1 时，为队列满。 数组模拟队列的代码实现模拟一个队列实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//使用数组模拟队列（编写一个ArrayQueue类）class ArrayQueue&#123; private int maxSize;//表示数组的最大容量 private int front;//队列头 private int rear;//队列尾 private int[] arr;//该数组用于存放队列，模拟的队列 //创建队列构造器 public ArrayQueue(int arrMaxSize)&#123; maxSize = arrMaxSize; arr = new int[maxSize]; front = -1;//指向队列头部，分析出front是指向队列头的前一个位置 rear = -1;//指向队列尾部，指向队列尾的数据(就是队列最后一个数据) &#125; //判断队列是否满 public boolean isFull()&#123; return rear == maxSize - 1; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return rear == front; &#125; //添加数据到队列 public void addQueue(int n)&#123; //判断队列是否满 if(isFull())&#123; throw new RuntimeException(\"队列满，不能加入数据！\"); &#125; rear++;//让rear后移 arr[rear] = n; &#125; //数据出队列 public int getQueue()&#123; //判断队列是否空 if(isEmpty())&#123; //通过抛出异常处理 throw new RuntimeException(\"队列空，不能取数据\"); &#125; front++; return arr[front]; &#125; //显示队列的所有数据 public void showQueue()&#123; //遍历 if(isEmpty())&#123; System.out.println(\"队列为空，没有数据！\"); return; &#125; for(int i = 0; i&lt;arr.length;i++)&#123; System.out.printf(\"arr[%d]=%d\\n\",i,arr[i]); &#125; &#125; //显示队列的头数据，注意部署去除数据 public int headQueue()&#123; //判断队列是否为空 if(isEmpty())&#123; throw new RuntimeException(\"队列空，没有头！\"); &#125; return arr[front+1]; &#125;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ArrayQueueDemo &#123; public static void main(String[] args) &#123; //创建一个队列 ArrayQueue arrayQueue = new ArrayQueue(3); char key = ' ';//接收用户的输入 Scanner scanner = new Scanner(System.in); boolean loop = true; //输出一个菜单 while(loop)&#123; System.out.print(\"s(show):显示队列;\"); System.out.print(\"e(exit):退出程序;\"); System.out.print(\"a(add):添加队列;\"); System.out.print(\"g(get):从队列取出数据;\"); System.out.println(\"h(head):查看队列头的数据。\"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': arrayQueue.showQueue(); break; case 'e': scanner.close(); loop = false; break; case 'a': try &#123; System.out.println(\"请输入一个数字：\"); int value = scanner.nextInt(); arrayQueue.addQueue(value); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'g': try &#123; int res = arrayQueue.getQueue(); System.out.printf(\"取出的数据是%d\\n\",res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h': try &#123; int head = arrayQueue.headQueue(); System.out.printf(\"队列头为%d\\n\",head); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; default: break; &#125; &#125; System.out.println(\"程序退出\"); &#125;&#125; 结果：目前代码存在的一些问题(1)目前数字使用一次就不能使用，没有达到复用的效果(2)将这个数字使用算法，改成一个环形的数组 数组模拟环形队列 思路：1、front变量的含义做一个调整：front指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，front的初始值 = 02、rear变量的含义也做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为一个约定。rear的初始值 = 03、当队列满时，条件是：( rear + 1 ) % maxSize = front4、当队列为空，条件是：rear == front5、当这样之后，队列中有效的数据的个数为( rear + maxSize - front ) % maxSize 代码实现模拟一个环形队列实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//使用数组模拟环形队列（编写一个CircleQueue类）class CircleArray&#123; private int maxSize;//表示数组的最大容量 private int front;//front变量的含义做一个调整：front指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，front的初始值 = 0 private int rear;//rear变量的含义也做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为一个约定。rear的初始值 = 0 private int[] arr;//该数组用于存放队列，模拟的队列 //创建队列构造器 public CircleArray(int arrMaxSize)&#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; //判断队列是否满 public boolean isFull()&#123; return (rear+1)%maxSize==front; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return rear == front; &#125; //添加数据到环形队列 public void addQueue(int n)&#123; //判断队列是否满 if(isFull())&#123; throw new RuntimeException(\"队列满，不能加入数据！\"); &#125; arr[rear] = n; rear = (rear+1)%maxSize;//将rear后移，这里必须考虑取模 &#125; //数据出队列 public int getQueue()&#123; //判断队列是否空 if(isEmpty())&#123; //通过抛出异常处理 throw new RuntimeException(\"队列空，不能取数据\"); &#125; //front是指向队列的第一个元素 //1、先把front对应的值保存到一个临时的变量 //2、将front后移 //3、将临时保存的变量返回 int value = arr[front]; front = (front+1)%maxSize; return value; &#125; //显示队列的所有数据 public void showQueue()&#123; //遍历 if(isEmpty())&#123; System.out.println(\"队列为空，没有数据！\"); return; &#125; //从fron开始遍历，遍历多少个元素 for(int i = front; i&lt;front+size();i++)&#123; System.out.printf(\"arr[%d]=%d\\n\",i%maxSize,arr[i%maxSize]); &#125; &#125; //求出当前队列的有效数据 public int size()&#123; return (rear+maxSize-front)%maxSize; &#125; //显示队列的头数据，注意不是去除数据 public int headQueue()&#123; //判断队列是否为空 if(isEmpty())&#123; throw new RuntimeException(\"队列空，没有头！\"); &#125; return arr[front]; &#125;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void main(String[] args) &#123; //测试 System.out.println(\"测试环形队列\"); //创建一个队列 CircleArray circleQueue = new CircleArray(4);//起队列的有效数据最大为3 char key = ' ';//接收用户的输入 Scanner scanner = new Scanner(System.in); boolean loop = true; //输出一个菜单 while(loop)&#123; System.out.print(\"s(show):显示队列;\"); System.out.print(\"e(exit):退出程序;\"); System.out.print(\"a(add):添加队列;\"); System.out.print(\"g(get):从队列取出数据;\"); System.out.println(\"h(head):查看队列头的数据。\"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': circleQueue.showQueue(); break; case 'e': scanner.close(); loop = false; break; case 'a': try &#123; System.out.println(\"请输入一个数字：\"); int value = scanner.nextInt(); circleQueue.addQueue(value); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'g': try &#123; int res = circleQueue.getQueue(); System.out.printf(\"取出的数据是%d\\n\",res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h': try &#123; int head = circleQueue.headQueue(); System.out.printf(\"队列头为%d\\n\",head); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; default: break; &#125; &#125; System.out.println(\"程序退出\");&#125; 结果：","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"数据结构和算法-稀疏数组","date":"2019-11-05T13:54:41.952Z","path":"2019/11/05/数据结构和算法-稀疏数组/","text":"实际需求 编写的五子棋程序中，有存盘退出和继续上盘的功能使用二维数组记录棋盘(用1记录玩家1，用2记录玩家2)0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;1&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;2&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;00&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0&emsp;0 分析存在的问题&emsp;&emsp;因为二维数组的很多值都是默认的值0，因此记录了很多没有意义的数据，这个时候就可以使用稀疏数组解决这个问题。稀疏数组 基本介绍当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存改数组。稀疏数组的处理方法是：（1）记录数组一共有几行几列，有多少个不同的值（2）把具有不同值的元素行列及值记录在一个小规模得数组中，从而缩小程序得规模 举例说明实际二维数组转换为稀疏二维数组&emsp;&emsp;从上面两个数组可以看出，原始的二维数组一共记录了42个数据，而转换为稀疏二维数组之后只需要记录27个数据。 应用实例（1）使用稀疏数组，来保存类似前面的二维数组（棋盘、地图等等）（2）把稀疏数组存盘，并且可以从新恢复原来的二维数组（3）思路分析将原始二维数组转换为稀疏数组的思路①遍历原始的二维数组，得到有效数据的个数sum②根据sum就可以创建稀疏二维数组sparseArr int[sum+1][3]③将原始二维数组的有效数据存入到稀疏数组将稀疏数组转换为原始二维数组的思路①先读取稀疏数组的第一行，根据第一行的数据创建原始的二维数组②在读取稀疏数组后几行的数据，并赋值给原始二维数组即可 稀疏数组的代码实现 此部分是将上面的思路分析转换成代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class SparseArray &#123; public static void main(String[] args) &#123; /** * 将原始二维数组转换为稀疏数组 */ //创建一个原始的二维数组10 * 10 //0：表示每一棋子，1表示黑棋，2表示白棋 int chessArr1[][] = new int[10][10]; chessArr1[3][3]=1; chessArr1[4][4]=2; //输出原始的二维数组 System.out.println(\"原始二维数组：\"); for(int[] row: chessArr1)&#123; for(int data : row)&#123; System.out.printf(\"%d\\t\",data); &#125; System.out.println(); &#125; //将二维数组转换为稀疏数组 //1.先遍历二维数组，得到非0数据的个数 int sum=0; for(int i = 0; i&lt;10;i++)&#123; for(int j = 0; j&lt;10;j++)&#123; if(chessArr1[i][j]!=0)&#123; sum++; &#125; &#125; &#125; //2.创建对应的稀疏数组 int sparseArr[][] = new int[sum+1][3]; //给稀疏数组赋值 sparseArr[0][0] = 10; sparseArr[0][1] = 10; sparseArr[0][2] = 2; //遍历原始二维数组，将非0的值存放到sparseArr中 int count = 0;//count用于记录是第几个非0数据 for(int i = 0; i&lt;10;i++)&#123; for(int j = 0; j&lt;10;j++)&#123; if(chessArr1[i][j]!=0)&#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; //输出稀疏数组的形式 System.out.println(); System.out.println(\"得到的稀疏数组为：\"); for(int i = 0;i&lt;sparseArr.length;i++)&#123; System.out.printf(\"%d\\t%d\\t%d\\t\",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]); System.out.println(); &#125; /** * 将稀疏数组转换为原始二维数组 */ //1.读取稀疏数组第一行，根据第一行数据创建原始二维数组 int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]]; //2.根据稀疏数组第二行以及之后行的数据赋值给原始二维数组 for(int i = 1;i&lt;sparseArr.length;i++)&#123; chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; //输出还原的二维数组 System.out.println(\"恢复之后的二维数组：\"); for(int[] row: chessArr2)&#123; for(int data : row)&#123; System.out.printf(\"%d\\t\",data); &#125; System.out.println(); &#125; &#125;&#125; 运行结果：","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://Xiezhenyu98.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://Xiezhenyu98.github.io/tags/算法/"}]},{"title":"Maven的核心概念","date":"2019-10-27T13:06:14.588Z","path":"2019/10/27/Maven的核心概念/","text":"Maven的目录结构，POM，坐标，仓库，依赖，生命周期，继承，聚合分别是什么呢？ Maven的目录结构这一部分的内容在我的上一篇《快速上手Maven》已经讲过，在这就不在过多赘述。HelloMaven：根目录（工程名）src：源码pom.xml：Maven工程的核心配置文件main：存放主程序test：存放测试程序java：存放java源文件resources：存放框架或者其它工具的配置文件 POM[1]含义：Project Object Model 项目对象模型，类似与DOM Document Object Model 文档对象模型[2]pom.xml对于Maven工程是核心的配置文件，与构建过程相关的一切设置都在这个文件中进行配置。重要程度相当于web.xml对于动态Web工程。 坐标 在Maven中坐标是使用三个向量在仓库中唯一定位一个Maven工程[1]groupId：公司或者组织的唯一标志，一般用公司或组织域名倒序+项目名 1&lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt; [2]artifactId：模块名，项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 1&lt;artifactId&gt;HelloMaven&lt;/artifactId&gt; [3]version：版本号 1&lt;version&gt;1.0&lt;/version&gt; Maven坐标与仓库中路径的对应关系如com.xiezhenyu.maven，maven会将该项目打成的jar包放本地仓库路径：/com/xiezhenyu/maven-1.0.jar。我们自己的 Maven 工程必须执行安装操作才会进入仓库，安装的命令是：mvn install。 仓库 仓库的分类[1]本地仓库：为当前本机电脑上所有的Maven工程服务[2]远程仓库：远程仓库分为私服、中央仓库、中央镜像仓库。私服：架设在当前局域网环境下，为当前局域网范围内的所有Maven工程服务；中央仓库：架设在Internet上，为全世界所有的Maven工程服务；中央仓库镜像：架设在各个大洲上，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。其中仓库的关系可以参照下图： 仓库中的文件(仓库中保存的内容)[1]Maven自身所需要的插件[2]第三方框架或工具的jar包[3]我们自己开发的Maven工程 依赖 概念&emsp;&emsp;当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖，这是概念上的描述。Maven解析依赖信息时会到仓库中查找被依赖的jar包。 如果要使用我们自己开发的jar包，要使用mvn install命令安装后就可以进入仓库。 依赖的范围 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在上面test就是描述依赖的范围，其值可以有 其文字描述为： compile范围依赖※对主程序是否有效：有效※对测试程序是否有效：有效※是否参与打包：参与※是否参与部署：参与※典型例子：spring-core test范围依赖 ※对主程序是否有效：无效 ※对测试程序是否有效：有效 ※是否参与打包：不参与 ※是否参与部署：不参与 ※典型例子：Junit 从开发和运行这两个阶段理解compile 和 provided 的区别 compile围依赖 provided 范围依赖 依赖的传递性&emsp;&emsp;比如A.jar依赖B.jar，B.jar依赖C.jar，A.jar能否使用C.jar呢？这时就需要看B.jar依赖C.jar的范围是不是compile范围的依赖。这就说明，C.jar只是给B.jar单独使用的。 依赖的排除&emsp;&emsp;如果我们当前工程中引入了一个依赖是A.jar，而A.jar又依赖了B.jar，那么Maven会自动将A依赖的B引入当前工程，但是个别情况下B.jar有可能是一个不稳定版本，或对当前工程有不良影响。这时我们可以在引入A.jar的时候将B.jar排除。①情景②配置方式 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt; &lt;artifactId&gt;HelloMaven&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;!-- 配置需要排除的依赖信息 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ③排除后的结果 依赖的原则，解决jar包冲突①路径最短者优先会根据jar包的路径最短的原则依赖jar包②路径相同时先声明者优先，先生命指的是dependency标签声明的顺序。 统一管理所依赖的版本&emsp;&emsp;对同一个框架的一组jar包最好使用相同的版本。为了方便升级架构，可以将jar包的版本信息统一提取出来。①统一声明版本号(其中 jackson.version 部分是自定义标签。) 123&lt;properties&gt; &lt;jackson.version&gt;2.9.6&lt;/jackson.version&gt;&lt;/properties&gt; ②引用前面声明的版本号 (在这里就会统一引用声明好的版本号) 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;&lt;/dependency&gt; ③其实properties标签配合自定义标签声明数据的配置并不是只能用于声明依赖的版本号。凡是需要统一声明后再引用的场合都可以使用。 生命周期 各个构建环节执行的顺序：不能打乱顺序，必须按照既定的正确顺序来执行。 Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。 Maven核心程序为了更好的实现自动化构建，按照这一特点执行生命周期中各个阶段：不论现在要执行生命周期中的哪一阶段，都是从这个生命周期最初的位置开始执行。 Maven有三套相互独立的生命周期，分别是：①Clean Lifecycle 在进行真正的构建之前进行一些清理工作。②Default Lifecycle 构建的核心部分，编译、测试、打包、安装、部署等等。③Site Lifecycle 生成项目报告，站点，发布站点。&emsp;&emsp;他们相互独立。也可以直接运行 mvn clean install site 运行所有这三套生命周期。每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。 Clean声明周期①pre-clean 执行一些需要在clean之前完成的工作②clean 移除所有上一次构建生成的文件③post-clean 执行一些需要在clean 之后立刻完成的工作 Default声明周期Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里标红一些比较重要和常用的阶段：validate（校验） 校验项目是否正确并且所有必要的信息可以完成项目的构建过程。initialize（初始化） 初始化构建状态，比如设置属性值。generate-sources（生成源代码） 生成包含在编译阶段中的任何源代码。process-sources（处理源代码） 处理源代码，比如说，过滤任意值。generate-resources（生成资源文件） 生成将会包含在项目包中的资源文件。process-resources （处理资源文件） 复制和处理资源到目标目录，为打包阶段最好准备。compile（编译） 编译项目的源代码。process-classes（处理类文件） 处理编译生成的文件，比如说对Java class文件做字节码改善优化。generate-test-sources（生成测试源代码） 生成包含在编译阶段中的任何测试源代码。process-test-sources（处理测试源代码） 处理测试源代码，比如说，过滤任意值。generate-test-resources（生成测试资源文件） 为测试创建资源文件。process-test-resources（处理测试资源文件） 复制和处理测试资源到目标目录。test-compile（编译测试源码） 编译测试源代码到测试目标目录.process-test-classes（处理测试类文件） 处理测试源码编译生成的文件。test（测试） 使用合适的单元测试框架运行测试（Juint是其中之一）。prepare-package（准备打包） 在实际打包之前，执行任何的必要的操作为打包做准备。package（打包） 将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件。pre-integration-test（集成测试前） 在执行集成测试前进行必要的动作。比如说，搭建需要的环境。integration-test（集成测试） 处理和部署项目到可以运行集成测试环境中。post-integration-test（集成测试后） 在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境。verify （验证） 运行任意的检查来验证项目包有效且达到质量标准。install（安装） 安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。deploy（部署） 将最终的项目包复制到远程仓库中与其他开发者和项目共享。 Site生命周期①pre-site 执行一些需要在生成站点文档之前完成的工作②site 生成项目的站点文档③post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备④site-deploy 将生成的站点文档部署到特定的服务器上 插件和目标①生命周期的各个阶段仅仅定义了要执行的任务是生命②各个阶段和插件的目标是对应的③相似的目标由特定的插件来完成例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。 继承 现状Hello依赖的Junit：4.0HelloFriend依赖的Junit：4.0MakeFriends依赖的Junit：4.9由于test范围的依赖不能传递，所以必然会分散在各个模块工程中，很容易造成版本不一致。 需求：统一管理各个模块工程中对Junit依赖的版本。 解决思路：将Junit依赖统一提取到“父”工程中，在子工程中声明Junit依赖是不指定版本，以父工程中统一设定的为准。同时也便于修改。 操作步骤：①创建一个Maven工程作为父工程。注意：打包方式为pom 1234&lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt;&lt;artifactId&gt;Parent&lt;/artifactId&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt; ②在子工程中声明对父工程的引用 12345678&lt;!-- 在子过程中声明父工程 --&gt;&lt;parent&gt; &lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!-- 以当前工程的pom.xml文件为基准的父工程pom.xml文件的相对路径 --&gt; &lt;relativePath&gt;&lt;/relativePath&gt;&lt;/parent&gt; ③将子工程的坐标中与父工程坐标中重复的内容删除 ④在父工程中统一管理Junit的依赖 1234567891011&lt;!-- 配置依赖的管理 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; ⑤在子工程中删除Junit依赖的版本号部分 注意：配置集成后，执行安装命令时要先安装父工程。 聚合&emsp;&emsp;如果我们写了很多模块，在我们安装的时候就需要我们一个个安装，这样就整加了工作量，而聚合可以解决这个问题。 聚合作用：一键安装各个模块工程。 配置方式：在一个“总的聚合工程”中配置各个参与聚合的模块（比如说在父工程配置） 1234567&lt;!-- 配置聚合 --&gt;&lt;modules&gt; &lt;!-- 配置一起安装的各个工程 --&gt; &lt;module&gt;../Hello&lt;/module&gt; &lt;module&gt;../HelloFriend&lt;/module&gt; &lt;module&gt;../MakeFriends&lt;/module&gt;&lt;/modules&gt; 使用方式：在聚合工程的pom.xml 上点右键-&gt;run as-&gt;maven install","tags":[{"name":"Maven","slug":"Maven","permalink":"https://Xiezhenyu98.github.io/tags/Maven/"}]},{"title":"【快速上手】Maven的使用","date":"2019-10-27T05:02:36.618Z","path":"2019/10/27/[快速上手]Maven的使用/","text":"首先需要了解一下为什么要使用Maven 一个项目就是一个工程&emsp;&emsp;如果一个项目非常庞大，就不适合继续使用Package来划分模块。最好是每一个模块对应一个工程，利于分工协作。而利用Maven就可以将一个项目拆分为多个工程。 项目中需要jar包必须手动“复制”、“粘贴”到WEB-INF/lib目录下&emsp;&emsp;带来的问题：同样的jar包文件重复出现在不同的项目工程中，一方面浪费存储空间，另外也让工程比较臃肿。借助Maven，可以将jar包仅仅保存在“仓库”中，有需要使用的工程“引用”这个文件接口，并不需要真的把jar包复制过来。 jar包需要别人替我们准备好，或者到官网下载&emsp;&emsp;不同技术的官网提供的jar包下载方式是不同的，有些jar包我们进不去别人的官网，只能从第三方网站下载，而第三方的网站的jar包可能是不规范的。而借助于Maven我们可以以一种规范的方式下载jar包。因为所有知名的jar包都会以规范的方式下载jar包，内容可靠。 一个jar包依赖的其它jar包需要自己手动加入工程中&emsp;&emsp;有些jar包会依赖很多个jar包，而被依赖的jar包也可能依赖其它jar包，这些依赖关系我们必须记下来，这样就会使程序员整加学习成本。不然我们把不完整的jar包导入到工程中，将会出现报错。而使用Maven将会自动把依赖的jar包导入进来。我们来了解一下什么是Maven&emsp;&emsp;Maven是一款服务于java平台的自动化构建工具。构建就是以java源文件、框架配置文件、JSP、HTML、图片等资源为原材料，去生产一个可运行的项目的过程。这个过程主要分为编译、部署、搭建。构建的各个环节：[1]清理：将以前编译得到的旧的class字节码文件删除，为下一次编译做准备[2]编译：将Java源程序编译为字节码文件。[3]测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。[4]报告：将每一次测试后以标准的格式记录和展示测试结果。[5]打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java工程对应jar包，Web工程对象war包。[6]安装：在Maven环境下特指将打包的结果——Jar包或War包安装到本地仓库中。[7]部署：将打包的结果部署到远程仓库或将war包部署到服务器上运行。如何使用和创建一个Maven工程 安装jdk、配置java环境变量 下载并解压Maven核心程序压缩包 【点击下载http://maven.apache.org/download.cgi】 配置Maven环境变量MAVEN_HOME：解压Maven核心程序的路径\\apache-maven-3.6.1-binpath：%MAVEN_HOME%\\bin 验证Maven是否配置成功（在控制台输入mvn -v） 创建Maven工程&emsp;&emsp;在创建之前必须要知道Maven所约定的Maven目录结构，我们创建这个工程必须按照这个约定的结构去创建，因为我们写的代码最终是要交给Maven去处理的，比如说java源代码编译，只有按照这个Maven约定好的目录去创建，Maven才知道去哪找java源代码编译。Maven的目录结构：HelloMaven：根目录（工程名）src：源码pom.xml：Maven工程的核心配置文件main：存放主程序test：存放测试程序java：存放java源文件resources：存放框架或者其它工具的配置文件 编写Maven项目[1]编写pom.xml文件1234567891011121314151617181920212223&lt;?xml version=\"1.0\" ?&gt;&lt;project xmlns = \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;!-- 模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt; &lt;groupId&gt;com.xiezhenyu.maven&lt;/groupId&gt; &lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt; &lt;artifactId&gt;HelloMaven&lt;/artifactId&gt; &lt;!-- 版本号 --&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!-- 依赖的jar包 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; [2]编写主程序代码&emsp;&emsp;在src/main/java/com/xiezhenyu/maven（一般以公司域名倒写的方式命名）目录下新建文件HelloMaven.java，其内容如下 1234567package com.xiezhenyu.maven;public class HelloMaven&#123; public String sayHelloMaven(String name)&#123; System.out.println(\"HelloMaven!\"); return \"Hello \"+name+\"!\"; &#125;&#125; [3]编写测试代码&emsp;&emsp;在src/test/java/com/xiezhenyu/maven（一般以公司域名倒写的方式命名）目录下新建文件HelloMavenTest.java，其内容如下 1234567891011package com.xiezhenyu.maven;import org.junit.Test;import static junit.framework.Assert.*;public class HelloMavenTest&#123; @Test public void testHelloMaven()&#123; HelloMaven helloMaven = new HelloMaven(); String results = helloMaven.sayHelloMaven(\"xiezhenyu\"); assertEquals(\"Hello xiezhenyu!\",results); &#125;&#125; 以上一个简单的Maven项目就搭建起来了。 如何测试运行一个Maven项目在测试之前先要了解一下Maven的常用命令 注意：执行与构建过程有关的Maven命令的时候，必须进入pom.xml所在的目录 常用命令[1]mvn clean : 清理[2]mvn compile : 编译主程序[3]mvn test-compile : 编译测试程序[4]mvn test : 执行测试[5]mvn package : 打包[6]mvn install ： 安装[7]mvn site ：生成站点 在编译之前，我们如果是第一次使用maven我们本地仓库中没有项目所需的jar包，我们需要联网[1]Maven 的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须有特定的插件来完成。而插件本身不包含在Maven核心程序中。[2]当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。[3]本地仓库的默认位置：[系统登陆用户的家目录] \\ .m2\\repository[4]Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载。[5]如果此时无法连接外网，则构建失败。[6]修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找插件&emsp;①找到Maven解压目录\\conf\\settings.xml&emsp;②在setting.xml 文件中找到 localRepository 标签&emsp;③将 &lt; localRepository&gt;/path/to/local/repo&lt; /localRepository&gt;从注释中取出&emsp;④将标签体内容修改为自定义的Maven仓库目录 执行mvn compile命令（cmd必须进入pom.xml所在的目录）&emsp;&emsp;可以发现我们在目录中生成了target目录，里面有classes，里面生成的是主程序编译后的结果（其中生成的maven-status目录是maven的状态，保存一些创建和输出的信息等） 执行mvn test-compile命令可以发现target目录新加了test-class目录，里面，里面生成的是测试程序编译后的结果 执行mvn test命令可以发现target目录新加了surefire-reports目录，里面生成的是测试报告相关的文件，控制台输出如下可以发现，我们的测试运行已经成功了。 执行mvn package命令&emsp;&emsp;可以发现，在target目录新生成了一个目录和一个jar包，maven-archiver目录存放的是这个jar包的基本信息，jar包是主程序编译结果打成的一个jar包，将jar包解压，我们可以看一下jar包的内容&emsp;&emsp;我们可以发现打包出来的并没有测试程序的内容，只有主程序的内容，里面也并没有这个工程所依赖的jar包，这样我们的工程就不会显得臃肿，如果我们将我们开发的这个模块导入到其它工程中就会方便很多。我们再看一下执行mvn package命令控制台的输出可以发现我们在执行打包命令时它也执行了测试，这就涉及到Maven的生命周期了。（与本篇无关，详情查看下一篇Maven） 以上就是如何快速使用Maven的方法","tags":[{"name":"Maven","slug":"Maven","permalink":"https://Xiezhenyu98.github.io/tags/Maven/"}]},{"title":"学习Python的第一步-卸载Python","date":"2019-10-27T02:55:14.363Z","path":"2019/10/27/学习Python的第一步-卸载Python/","text":"&emsp;&emsp;相信很多人都已经听说过或者学过Python了，但是有的人没有坚持下去，过了几个月一年或者更久之后Python的版本发生了很大的变化，我们学习当然要学习最新的内容。而要学习最新的内容就必须把电脑里已经安装过的Python旧版本卸载掉（没有安装过的当我没说） 检查是否安装PythonWin+R→输入cmd→打开→在cmd输入python→回车如果出现这个界面就证明你已经安装了Python，如果没有安装，是windows10系统的话会自动弹出python获取界面或者会出现 12'python' 不是内部或外部命令，也不是可运行的程序或批处理文件。 卸载Python进入电脑的控制面版。找到Python 3.7.3(或者不是Python的其它不是最新的版本)和Python Launcher，并把这两个卸载掉。 Python卸载成功","tags":[{"name":"Python","slug":"Python","permalink":"https://Xiezhenyu98.github.io/tags/Python/"}]},{"title":"Spring的模块","date":"2019-10-20T09:48:48.999Z","path":"2019/10/20/Spring的模块/","text":"Spring下载：http://repo.spring.io/release/org/springframework/spring/ Test：Spring的单元测试模块spring-test-5.0.8.RELEASE.jar Core Container：核心容器（IOC）；黑色代表这部分的功能由哪些jar包组成，要使用这个部分的完整功能们这些jar都需要导入：spring-beans-5.0.8.RELEASE.jarspring-core-5.0.8.RELEASE.jarspring-context-5.0.8.RELEASE.jarspring-expression-5.0.8.RELEASE.jar AOP+Aspects：面向切面编程模块spring-aop-5.0.8.RELEASE.jarspring-aspects-5.0.8.RELEASE.jar Data Access/Integration：数据访问（Spring访问数据库的模块）spring-jdbc-5.0.8.RELEASE.jarspring-orm-5.0.8.RELEASE.jar（Object Relation Mapping 对象关系映射）spring-oxm-5.0.8.RELEASE.jar（x表示xml）spring-jms-5.0.8.RELEASE.jarspring-tx-5.0.8.RELEASE.jar Web：Spring开发web应用的模块spring-websocket-5.0.8.RELEASE.jarspring-web-5.0.8.RELEASE.jar（和原生的web相关的(servlet)）spring-webmvc-5.0.8.RELEASE.jar（开发web应用的组件集成） Instrumentation：该模块提供了为JVM添加代理的功能，该模块包含spring-instrument，spring-instrument-tomcat组件，使用较少，不必过分关注。 用哪个模块导哪个包","tags":[{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"Mybatis和Spring整合","date":"2019-10-20T06:20:57.133Z","path":"2019/10/20/Mybatis和Spring整合/","text":"1、Mybatis和Spring框架整合1.1、导入所需的包我所需要的包是 1.2、创建Mybatis主配置文件sqlMapConfig.xml1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 类型别名,推荐使用package包的形式 --&gt; &lt;typeAliases&gt; &lt;!-- 扫描该包主包及子包下的所有类都起别名,别名为类名,而且大小写不敏感,推荐使用小写 --&gt; &lt;package name=\"com.xiezhenyu.bean\"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 1.3、创建Spring主配置文件applicationContext.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd \"&gt; &lt;!-- 读取db.properties --&gt; &lt;context:property-placeholder location=\"db.properties\"/&gt; &lt;!-- 配置c3p0连接池 --&gt; &lt;bean name=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.jdbcUrl&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.user&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 配置MyBatis sqlSessionFactory --&gt; &lt;bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 配置数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!-- 告诉spring mybatis的核心配置文件 --&gt; &lt;property name=\"configLocation\" value=\"classpath:sqlMapConfig.xml\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.4、创建log4j.properties和db.properties123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 1234jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql://localhost:3306/ssm_mybatis?serverTimezone=Asia/Shanghaijdbc.user=rootjdbc.password=p123456 1.5、测试12345public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); SqlSessionFactoryBean bean = ac.getBean(SqlSessionFactoryBean.class); System.out.println(bean);&#125; 1.6、结果1org.mybatis.spring.SqlSessionFactoryBean@708f5957 输出以上结果代表已经成功！ 2、Dao式开发在传统dao层上使用MyBatis和spring整合开发 2.1、创建实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.xiezhenyu.bean;import java.util.Date;public class User &#123; private Integer u_id; private String u_username; private String u_password; private String u_sex; private Date u_createTime; private Integer u_cid; public Integer getU_id() &#123; return u_id; &#125; public void setU_id(Integer u_id) &#123; this.u_id = u_id; &#125; public String getU_username() &#123; return u_username; &#125; public void setU_username(String u_username) &#123; this.u_username = u_username; &#125; public String getU_password() &#123; return u_password; &#125; public void setU_password(String u_password) &#123; this.u_password = u_password; &#125; public String getU_sex() &#123; return u_sex; &#125; public void setU_sex(String u_sex) &#123; this.u_sex = u_sex; &#125; public Date getU_createTime() &#123; return u_createTime; &#125; public void setU_createTime(Date u_createTime) &#123; this.u_createTime = u_createTime; &#125; public Integer getU_cid() &#123; return u_cid; &#125; public void setU_cid(Integer u_cid) &#123; this.u_cid = u_cid; &#125; @Override public String toString() &#123; return \"User [u_id=\" + u_id + \", u_username=\" + u_username + \", u_password=\" + u_password + \", u_sex=\" + u_sex + \", u_createTime=\" + u_createTime + \", u_cid=\" + u_cid + \"]\"; &#125;&#125; 2.2、书写Dao和DaoImpldao 123456package com.xiezhenyu.dao;import com.xiezhenyu.bean.User;public interface UserDao &#123; //根据id查询用户 public User getUserById(Integer id);&#125; &emsp;&emsp;daoImpl继承SqlSessionDaoSupport，可以通过父类的getSqlSession()方法直接获得session，而父类中的sqlSessionFactory可以通过spring注入。 123456789101112package com.xiezhenyu.dao;import org.apache.ibatis.session.SqlSession;import org.mybatis.spring.support.SqlSessionDaoSupport;import com.xiezhenyu.bean.User;public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123; @Override public User getUserById(Integer id) &#123; //通过父类的方法直接获得session SqlSession session = getSqlSession(); return session.selectOne(\"UserMapper.selectUserById\",id); &#125;&#125; 2.3、配置spring配置文件applicationContext.xml将工厂注入dao的父类 sqlSessionFactory属性中 1234&lt;!-- 将工厂注入dao的父类 sqlSessionFactory属性中 --&gt;&lt;bean id=\"userDaoImpl\" class=\"com.xiezhenyu.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactoryBean\"/&gt;&lt;/bean&gt; 2.4、配置mybatis配置文件123&lt;mappers&gt; &lt;mapper resource=\"com/xiezhenyu/mapper/UserMapper.xml\"/&gt;&lt;/mappers&gt; 2.5、测试1234567@Testpublic void DaoTest() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDaoImpl userDao = ac.getBean(UserDaoImpl.class); User user = userDao.getUserById(1); System.out.println(user);&#125; 2.6、结果1User [u_id=1, u_username=老王, u_password=123, u_sex=1, u_createTime=null, u_cid=1] 3、Mapper动态代理开发3.1、创建实体类该过程和上面dao层开发的实体类一致，就不给出代码。 3.2、创建UserMapper接口，修改UserMapper.xml将UserMapper.xml的namespace修改为UserMapper接口的路径 123public interface UserMapper &#123; public User selectUserById(Integer id);&#125; 123456&lt;mapper namespace=\"com.xiezhenyu.mapper.UserMapper\"&gt; &lt;!-- 查找用户 --&gt; &lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"user\"&gt; select * from user where u_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 3.3、让sqlMapConfig.xml以包的形式扫描mapper.xml123&lt;mappers&gt; &lt;package name=\"com.xiezhenyu.mapper\"/&gt;&lt;/mappers&gt; 3.4、配置spring配置文件applicationContext.xml&emsp;&emsp;将MapperFactoryBean交给Spring管理。MapperFactoryBean中拥有属性mapperInterface可以配置mapper的接口，而MapperFactoryBean是继承SqlSessionDaoSupport，使用可以注入sqlSessionFactory。 1234567&lt;!-- Mapper动态代理开发 --&gt;&lt;bean id=\"UserMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactoryBean\"/&gt; &lt;!-- 配置接口 --&gt; &lt;property name=\"mapperInterface\" value=\"com.xiezhenyu.mapper.UserMapper\"/&gt;&lt;/bean&gt; 3.5、编写测试方法获取mapper的方法可以用传递applicationContext.xml中id的方法，也可以直接传递接口。 123456789@Testpublic void Test1() &#123; //获取主配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //UserMapper mapper = (UserMapper)ac.getBean(\"UserMapper\"); UserMapper mapper = ac.getBean(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user);&#125; 3.6、结果1User [u_id=1, u_username=老王, u_password=123, u_sex=1, u_createTime=null, u_cid=1] 4、Mapper动态扫描开发(推荐使用)&emsp;&emsp;在mapper动态扫描开发中只需要配置以下即可，他会自动扫描某个包下的全部mapper，它不用手动注入sqlSessionFactory。 1234&lt;!-- mapper动态扫描开发 --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.xiezhenyu.mapper\"/&gt;&lt;/bean&gt;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"https://Xiezhenyu98.github.io/tags/Spring/"}]},{"title":"MyBatis动态sql：更方便的拼接sql语句","date":"2019-10-19T08:06:18.167Z","path":"2019/10/19/MyBatis动态sql：更方便的拼接sql语句/","text":"if标签&emsp;&emsp;if标签是最常用的判断语句，相当于java中的if语句。在MyBatis中使用if标签，我们先看一下不使用if标签的时候会有什么情况。 12345678910&lt;!-- 多条件查询 用过用户对象中的条件查询用户列表 --&gt;&lt;select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\"&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍id --&gt; select * from user where u_sex = #&#123;u_sex&#125; and u_username like \"%\"#&#123;u_username&#125;\"%\" and u_cid = #&#123;u_cid&#125;&lt;/select&gt; &emsp;&emsp;在上面的案例中，多条件查询用户性别u_sex，模糊查询用户名u_username，查询用户国籍c_id，返回一个集合。我们在使用条sql语句的时候，我们必须把所有的参数传过来，如果出现我只有查询用户性别u_sex，模糊查询用户名u_username的情况，我们又必须再写一条sql语句。而使用了if标签之后可以解决这个问题。 12345678910111213141516&lt;!-- 多条件查询 用过用户对象中的条件查询用户列表 --&gt;&lt;select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\"&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍id --&gt; select * from user where &lt;if test=\"u_sex!=null\"&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt;';l., &lt;if test=\"u_username!=null\"&gt; and u_username like \"%\"#&#123;u_username&#125;\"%\" &lt;/if&gt; &lt;if test=\"u_cid!=null\"&gt; and u_cid = #&#123;u_cid&#125; &lt;/if&gt;&lt;/select&gt; &emsp;&emsp;在上面的案例中，当参数u_username传递进映射器时，如果参数不为空则再sql语句上拼接上对用户名的模糊查询，如果为空，则不拼接。这样我们就可以不用写多条sql语句了。但是，如果我们u_sex为空u_username不为空，在sql语句拼接时就会出现select * from user where and u_username like &quot;%&quot;#{u_username}&quot;%&quot;的错误语法格式。接下来的where标签可以解决这个问题。 where标签&emsp;&emsp;where标签，当标签内的条件成立时，才会加入where这个SQL关键字到组装的SQL里面，否则就不加入，where还可以去掉一些特殊的SQL语法，比如说and、or，它去掉的时前缀的and和or。 12345678910111213141516&lt;select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\"&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍id --&gt; select * from user &lt;where&gt; &lt;if test=\"u_sex!=null\"&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt; &lt;if test=\"u_username!=null\"&gt; and u_username like \"%\"#&#123;u_username&#125;\"%\" &lt;/if&gt; &lt;if test=\"u_cid!=null\"&gt; and u_cid = #&#123;u_cid&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; &emsp;&emsp;在上面的案例中，如果and全写在sql拼接语句的后面，当c_cid==null的话，使用where语句就去不掉结尾的and。接下来的trim标签可以解决这个问题。 trim标签&emsp;&emsp;trim标签是要去掉一些特殊的字符串，它又四个属性，prefix、suffix、prefixOverrides、suffixOverrides。下面通过一个例子说一下这四个属性分别代表的意义。 12345678910111213141516&lt;select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\"&gt; &lt;!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍id --&gt; select * from user &lt;trim prefix=\"where\" suffixOverrides=\"and\"&gt; &lt;if test=\"u_sex!=null\"&gt; u_sex = #&#123;u_sex&#125; and &lt;/if&gt; &lt;if test=\"u_username!=null\"&gt; u_username like \"%\"#&#123;u_username&#125;\"%\" and &lt;/if&gt; &lt;if test=\"u_cid!=null\"&gt; u_cid = #&#123;u_cid&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; &emsp;&emsp;prefix=”where”，的意思是在trim头标签加上where之后再拼接上trim内的SQL语句，如果将其换成suffix=”where”的话，就会在trim内的的SQL语句后面接上where，显然在上面的案例中是不对的。&emsp;&emsp;suffixOverrides=”and”，的意思是去掉拼接语句尾部一些不合法的一些特殊字符，比如说and、or，如果将其换成prefixOverrides=”and”的话，就是去掉拼接语句开头一些不合法的的特殊字符。 set标签set标签在跟新表属性的时候，如果遇上不合法的逗号，会将其去掉。例如： 123456789101112131415&lt;update id=\"updateSetUser\" parameterType=\"User\"&gt; &lt;!-- 修改用户名和用户密码以及性别以id为限制 --&gt; update user set &lt;if test=\"u_username!=null and u_username!=''\"&gt; u_username = #&#123;u_username&#125;, &lt;/if&gt; &lt;if test=\"u_password!=null and u_password!=''\"&gt; u_password = #&#123;u_password&#125;, &lt;/if&gt; &lt;if test=\"u_sex!=null and u_sex!=''\"&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt; where u_id = #&#123;u_id&#125;&lt;/update&gt; &emsp;&emsp;在上面这个案例中，如果if语句最后一个不成立而它上一个if语句成立的时候，在拼接SQL语句的时候，就会出现SQL语法的错误，而使用set标签可以很好的解决这个错误。下面是使用set标签的案例。 12345678910111213141516&lt;update id=\"updateSetUser\" parameterType=\"User\"&gt; &lt;!-- 修改用户名和用户密码以及性别以id为限制 --&gt; update user &lt;set&gt; &lt;if test=\"u_username!=null and u_username!=''\"&gt; u_username = #&#123;u_username&#125;, &lt;/if&gt; &lt;if test=\"u_password!=null and u_password!=''\"&gt; u_password = #&#123;u_password&#125;, &lt;/if&gt; &lt;if test=\"u_sex!=null and u_sex!=''\"&gt; u_sex = #&#123;u_sex&#125; &lt;/if&gt; &lt;/set&gt; where u_id = #&#123;u_id&#125;&lt;/update&gt; &emsp;&emsp;如果最后一个条件12345678910111213### foreach标签&amp;emsp;&amp;emsp;foreach标签是一个循环语句，它的作用是遍历集合，它能够很好地支持数组和List、Set接口的集合，对此提供遍历的功能。&amp;emsp;&amp;emsp;比如说，我要查找数据库中id为1、3、5的用户，SQL语句应该这样写```select * from user where u_id in(1,3,5)```只能固定查3个id的用户，如果要查4个，必须再写一条sql语句，而foreach可以很好的解决这个问题。```xml&lt;select id=&quot;selectUserListByIds&quot; resultType=&quot;User&quot;&gt; select * from user where u_id in &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; collection表示传入的是数组还是集合是数组用array，是集合用list、set等，但如果是包装类的话，则需要使用包装类里面数组或集合的字段名。 item表示用什么表示数据或者集合里面的数，即循环中当前的元素。 open、close表示用什么元素把集合两端包起来。 separate表示用什么分隔。 index表示当前元素在集合中的位置。choose、when、otherwise标签&emsp;&emsp;choose、when、otherwise标签类似于java里面的wsitch…case…default…功能语句。下面是一个简单的案例。1234567891011121314151617&lt;select id=\"selectUserByUser\" parameterType=\"com.xiezhenyu.bean.User\" resultType=\"com.xiezhenyu.bean.User\"&gt; select * from user &lt;where&gt; &lt;choose&gt; &lt;when test=\"u_id!=null\"&gt; and u_id=#&#123;u_id&#125; &lt;/when&gt; &lt;when test=\"u_username!=null\"&gt; and u_username=#&#123;u_username&#125; &lt;/when&gt; &lt;otherwise&gt; and 1=2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; &emsp;&emsp;当传过来的user的id不为空时，按照id为条件去查找，当传过来的id为空而username不为空时按照username去查找，当两个都为空时，查找不到。 sql标签&emsp;&emsp;在写sql语句的时候，有很多重复的语句片段，比如说，* from user```这句话就被重复了很多次，而使用sql标签可以将这些重复的字段提出来，什么时候用就引入一下就可以了。12345678910111213```xml&lt;sql id=&quot;selectUser&quot;&gt; select * from user&lt;/sql&gt;&lt;select id=&quot;selectUserListByIds&quot; resultType=&quot;User&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; where u_id in &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; index=&quot;2&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; bind标签&emsp;&emsp;bind标签的作用是用过ONGL表达式去定义一个上下文变量，这样更方便使用，例如在进行模糊查询时，MySQL需要用到%和参数连接。定义接口方法 1public List&lt;User&gt; selectUserLikeUsername(@Param(\"str\")String str); 定义映射文件和一个新的变量，然后执行模糊查询 1234567&lt;select id=\"selectUserLikeUsername\" parameterType=\"string\" resultType=\"com.xiezhenyu.bean.User\"&gt; &lt;bind name=\"pattern\" value=\"'%'+str+'%'\"/&gt; select * from user where u_username like #&#123;pattern&#125;&lt;/select&gt; 测试方法 1234567891011121314151617@Testpublic void Test11() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; list = mapper.selectUserLikeUsername(\"王\"); for(User u : list) &#123; System.out.println(u); &#125;&#125;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"MyBatis的输入和输出映射","date":"2019-10-17T11:11:41.165Z","path":"2019/10/17/MyBatis的输入和输出映射/","text":"&emsp;&emsp;MyBatis的输入和输出映射，通过parameterType完成输入映射，通过resultType和resultMap完成输出映射。 1、输入映射parameterType&emsp;&emsp;输入映射中，可以给出类的全名，也可以给出类的别名，但是别名必须是MyBatis内部定义或者自定义的，可以选择JavaBean、Map等简单的参数类型传递给SQL。 1.1基本类型&emsp;&emsp;基本类型可以使用别名的方式，如果想要查看常见的 Java 类型内建的相应的类型别名，点击这里，它们都是不区分大小写的。(具体的测试方法可以看我上一篇写的博客) 123&lt;delete id=\"deleteUserById\" parameterType=\"Integer\"&gt; delete from user where u_id = #&#123;id&#125;&lt;/delete&gt; 1.2自定义对象&emsp;&emsp;输入类型还可以为自定义的对象，在书写Sql语句获取数值的时候，可以使用”#{对象字段名}”的方式取得数值。以下就是通过输入一个自定义对象的方式将参数传递给SQL，实现修改指定用户名的功能。(具体的测试方法可以看我上一篇写的博客) 123&lt;update id=\"updateUser\" parameterType=\"io.xiezhenyu98.bean.User\"&gt; update user set u_username = #&#123;u_username&#125; where u_id=#&#123;u_id&#125;&lt;/update&gt; 1.3自定义包装类&emsp;&emsp;输入类型还可以为自定义的包装类，在书写SQL语句获取数值的时候，可以使用”#{包装类字段.被包装类字段}”的方法获得数值。UserVo.java包装类 123456789101112public class UserVo &#123; //包装类 //需要全部的user对象信息 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; //需要表B的id name属性&#125; UserMapper.java接口 12//通过UserVo id查询一个用户public User selectUserByUserVoId(UserVo vo); UserMapper.xml映射文件 1234&lt;!-- 查找用户UserVo --&gt;&lt;select id=\"selectUserByUserVoId\" parameterType=\"UserVo\" resultType=\"user\"&gt; select * from user where u_id = #&#123;user.u_id&#125;&lt;/select&gt; 测试方法 12345678910111213141516171819@Testpublic void Test3() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserVo vo = new UserVo(); User user = new User(); user.setU_id(1); vo.setUser(user); User resultUser = mapper.selectUserByUserVoId(vo); System.out.println(resultUser);&#125; 结果 1User [u_id=1, u_username=老王, u_password=123, u_sex=1, u_createTime=null, u_cid=1] 2、输出映射resultType、resultMap2.1resultType&emsp;&emsp;resultType，定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射，数据库中表的字段名和JavaBean中的字段名对应，或定义为int、double、float、map等参数，也可以使用别名，但是要符合别名的规范，且不能和resultMap同时使用。resultType是常用的参数之一，比如统计总条数时可以把它设置为int。 2.1.1基本类型&emsp;&emsp;输出映射的基本类型和输入映射的基本类型一样，可以使用别名的方式，如果想要查看常见的 Java 类型内建的相应的类型别名，点击这里，它们都是不区分大小写的。以下是查询用户总数返回Integer的返回值。 1234&lt;!-- 查询用户总条数 --&gt;&lt;select id=\"selectUserCount\" resultType=\"Integer\"&gt; select count(*) from user&lt;/select&gt; 2.1.2自定义类型输出映射的自定义类型(具体的测试方法可以看我上一篇写的博客) 1234&lt;!-- 查找用户 --&gt;&lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"user\"&gt; select * from user where u_id = #&#123;id&#125;&lt;/select&gt; 2.2resultMap&emsp;&emsp;resultMap，它是映射集的引用，将执行强大的映射功能。可以使用resultType、resultMap的其中一个，resultMap能提供自定义映射规则的机会，数据库中表的字段名和JavaBean中的字段名不对应，则需要添加自定义映射。resultMap是MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler等等。 2.2.1Bean对象字段与数据库中字段不匹配创建Country实例，实例中Country的id与数据库中的不匹配(数据库中的为c_id) 123456789101112131415161718192021222324252627public class Country &#123; private Integer id; private String c_countryname; private String c_capital; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getC_countryname() &#123; return c_countryname; &#125; public void setC_countryname(String c_countryname) &#123; this.c_countryname = c_countryname; &#125; public String getC_capital() &#123; return c_capital; &#125; public void setC_capital(String c_capital) &#123; this.c_capital = c_capital; &#125; @Override public String toString() &#123; return \"Country [id=\" + id + \", c_countryname=\" + c_countryname + \", c_capital=\" + c_capital + \"]\"; &#125;&#125; 创建CountryMapper接口 123456import java.util.List;import com.siliedu.bean.Country;public interface CountryMapper &#123; //查询所有 public List&lt;Country&gt; selectAll();&#125; 创建CountryMapper映射文件 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.siliedu.mapper.CountryMapper\"&gt; &lt;!-- 查询所有 --&gt; &lt;!-- country为resultMap起一个名字 --&gt; &lt;resultMap type=\"Country\" id=\"country\"&gt; &lt;!-- id为javaBean中的字段，c_id为数据库中的字段，两个字段不匹配 --&gt; &lt;result property=\"id\" column=\"c_id\"/&gt; &lt;/resultMap&gt; &lt;!-- country为使用名为country的resultMap --&gt; &lt;select id=\"selectAll\" resultMap=\"country\"&gt; select * from country &lt;/select&gt;&lt;/mapper&gt; 测试方法 1234567891011121314151617@Testpublic void Test5() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); CountryMapper mapper = session.getMapper(CountryMapper.class); List&lt;Country&gt; list = mapper.selectAll(); for(Country c : list) &#123; System.out.println(c); &#125;&#125; 结果 1234Country [id=1, c_countryname=中国, c_capital=北京]Country [id=3, c_countryname=美国, c_capital=华盛顿]Country [id=4, c_countryname=英国, c_capital=伦敦]Country [id=5, c_countryname=日本, c_capital=东京] 在这里如果我们将resultMap改成resultType的话，id将查询不到。 123&lt;select id=\"selectAll\" resultType=\"country\"&gt; select * from country&lt;/select&gt; 结果 1234Country [id=null, c_countryname=中国, c_capital=北京]Country [id=null, c_countryname=美国, c_capital=华盛顿]Country [id=null, c_countryname=英国, c_capital=伦敦]Country [id=null, c_countryname=日本, c_capital=东京] 2.2.2关联查询2.2.2.1一对一&emsp;&emsp;一个用户只对应一个国家。(在单表查询的时候，javaBean对象的字段和数据库字段一致的时候可以省略但在多表查询的时候，我们要查询什么字段，就必须把什么字段列在映射文件上)UserVo包装类 1234567891011121314public class UserVo extends User&#123; private Country country; public Country getCountry() &#123; return country; &#125; public void setCountry(Country country) &#123; this.country = country; &#125; @Override public String toString() &#123; return \"UserVo [country=\" + country + \", getU_id()=\" + getU_id() + \", getU_username()=\" + getU_username() + \", getU_sex()=\" + getU_sex() + \"]\"; &#125;&#125; UserMapper接口 12//查询所有用户的包装类public List&lt;UserVo&gt; selectAllUserVo(); UserMapper.xml映射文件 123456789101112131415&lt;!-- 查询所有用户的包装类 --&gt;&lt;resultMap type=\"UserVo\" id=\"uservolist\"&gt; &lt;!-- 在单表查询的时候，javaBean对象的字段和数据库字段一致的时候可以省略 但在多表查询的时候，我们要查询什么字段，就必须把什么字段列上去 --&gt; &lt;id property=\"u_id\" column=\"u_id\"/&gt; &lt;id property=\"u_username\" column=\"u_username\"/&gt; &lt;id property=\"u_sex\" column=\"u_sex\"/&gt; &lt;association property=\"country\" javaType=\"Country\"&gt; &lt;result property=\"id\" column=\"c_id\"/&gt; &lt;result property=\"c_countryname\" column=\"c_countryname\"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"selectAllUserVo\" resultMap=\"uservolist\"&gt; select u.u_id,u.u_username,u.u_sex,c.c_id,c.c_countryname from user u left join country c on u.u_cid=c.c_id&lt;/select&gt; 测试方法 1234567891011121314151617@Testpublic void Test6() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;UserVo&gt; list = mapper.selectAllUserVo(); for(UserVo userVo : list) &#123; System.out.println(userVo); &#125;&#125; 结果：查询到了所有的用户，以及用户的国家，没有国家的用户也查询到了 123456789101112UserVo [country=Country [id=1, c_countryname=中国, c_capital=null], getU_id()=1, getU_username()=老王, getU_sex()=1]UserVo [country=Country [id=3, c_countryname=美国, c_capital=null], getU_id()=2, getU_username()=jack, getU_sex()=1]UserVo [country=Country [id=3, c_countryname=美国, c_capital=null], getU_id()=3, getU_username()=alice, getU_sex()=0]UserVo [country=Country [id=1, c_countryname=中国, c_capital=null], getU_id()=4, getU_username()=王司机, getU_sex()=1]UserVo [country=Country [id=4, c_countryname=英国, c_capital=null], getU_id()=5, getU_username()=anna, getU_sex()=0]UserVo [country=Country [id=1, c_countryname=中国, c_capital=null], getU_id()=6, getU_username()=李师傅, getU_sex()=1]UserVo [country=Country [id=5, c_countryname=日本, c_capital=null], getU_id()=7, getU_username()=漩涡鸣人, getU_sex()=1]UserVo [country=Country [id=5, c_countryname=日本, c_capital=null], getU_id()=8, getU_username()=娜美, getU_sex()=0]UserVo [country=Country [id=1, c_countryname=中国, c_capital=null], getU_id()=9, getU_username()=王五, getU_sex()=1]UserVo [country=null, getU_id()=10, getU_username()=老赵, getU_sex()=null]UserVo [country=null, getU_id()=11, getU_username()=老孙, getU_sex()=null]UserVo [country=null, getU_id()=12, getU_username()=98k, getU_sex()=null] 2.2.2.1一对多一个国家有多个用户。CountryVo包装类 123456789101112131415import java.util.List;public class CountryVo extends Country&#123; //需要维护一个User集合 private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() &#123; return userList; &#125; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; @Override public String toString() &#123; return \"CountryVo [userList=\" + userList + \", toString()=\" + super.toString() + \"]\"; &#125;&#125; CountryMapper接口 12//查询所有的CountryVopublic List&lt;CountryVo&gt; selectAllCountryVo(); CountryMapper映射文件 1234567891011121314151617181920212223&lt;!-- 查询所有的CountryVo --&gt;&lt;resultMap type=\"CountryVo\" id=\"countryvo\"&gt; &lt;id property=\"id\" column=\"c_id\"/&gt; &lt;result property=\"c_countryname\" column=\"c_countryname\"/&gt; &lt;result property=\"c_capital\" column=\"c_capital\"/&gt; &lt;!-- 一对多关系 --&gt; &lt;collection property=\"userList\" ofType=\"User\"&gt; &lt;id property=\"u_id\" column=\"u_id\"/&gt; &lt;result property=\"u_username\" column=\"u_username\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"selectAllCountryVo\" resultMap=\"countryvo\"&gt; select c.c_id, c.c_countryname, c.c_capital, u.u_id, u.u_username from country c left join user u on u.u_cid=c.c_id&lt;/select&gt; 测试方法 1234567891011121314151617@Testpublic void Test7() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); CountryMapper mapper = session.getMapper(CountryMapper.class); List&lt;CountryVo&gt; list = mapper.selectAllCountryVo(); for(CountryVo countryVo : list) &#123; System.out.println(countryVo); &#125;&#125; 结果：查询出了，一个国家有几个用户 1234CountryVo [userList=[User [u_id=1, u_username=老王, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=4, u_username=王司机, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=6, u_username=李师傅, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=9, u_username=王五, u_password=null, u_sex=null, u_createTime=null, u_cid=null]], toString()=Country [id=1, c_countryname=中国, c_capital=北京]]CountryVo [userList=[User [u_id=2, u_username=jack, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=3, u_username=alice, u_password=null, u_sex=null, u_createTime=null, u_cid=null]], toString()=Country [id=3, c_countryname=美国, c_capital=华盛顿]]CountryVo [userList=[User [u_id=5, u_username=anna, u_password=null, u_sex=null, u_createTime=null, u_cid=null]], toString()=Country [id=4, c_countryname=英国, c_capital=伦敦]]CountryVo [userList=[User [u_id=7, u_username=漩涡鸣人, u_password=null, u_sex=null, u_createTime=null, u_cid=null], User [u_id=8, u_username=娜美, u_password=null, u_sex=null, u_createTime=null, u_cid=null]], toString()=Country [id=5, c_countryname=日本, c_capital=东京]]","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"MaBatis的Mapper动态代理开发","date":"2019-10-17T03:53:03.885Z","path":"2019/10/17/MaBatis的Mapper动态代理开发/","text":"1 SqlSession的介绍&emsp;&emsp;SqlSession中封装了对数据库的操作，比如：更新、删除、查询等。通过SqlSessionFactory创建SqlSession，而SqlSessionFactory是由SqlSessionFactoryBuilder来创建的。 1.1 SqlSessionFactoryBuilderSqlSessionFactoryBuilder的作用是创建SqlSessionFacoty，SqlSessionFacoty创建了之后就不需要SqlSessionFactoryBuilder了，由于SqlSession是通过SqlSessionFactory生产，所以一般是将SqlSessionFactoryBuilder当成一个工具类使用，需要创建sqlSessionFactory时就new一个 SqlSessionFactoryBuilder，和Spring整合后由Spring以单例方式管理sqlSessionFactory。 1.2 SqlSessionFactorySqlSession是一个面向用户的接口， sqlSession中定义了数据库操作，默认使用DefaultSqlSession实现类。 2 MaBatis对Dao层的开发方式2.1 不使用Mapper动态代理开发编写dao层接口 1234public interface UserDao &#123; //根据id查询用户 public User getUserById(Integer id);&#125; 编写dao层接口实现类 1234567891011121314151617public class UserDaoImpl implements UserDao &#123; //sqlSession 工厂 private SqlSessionFactory ssf; //通过构造器给ssf赋值 public UserDaoImpl(SqlSessionFactory ssf) &#123; super(); this.ssf = ssf; &#125; @Override public User getUserById(Integer id) &#123; //生产一个sqlSession SqlSession session = ssf.openSession(); User user session.selectOne(\"UserMapper.selectUserById\",id); session.close(); return user; &#125;&#125; 编写测试方法 12345678910111213141516171819202122public class UserDaoTest &#123; //sqlSession 工厂 private static SqlSessionFactory ssf; static &#123; String resource = \"sqlMapConfig.xml\"; InputStream in; try &#123; in = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); ssf = ssfb.build(in); in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void DaoTest() &#123; UserDao dao = new UserDaoImpl(ssf); User user = dao.getUserById(1); System.out.println(user); &#125;&#125; &emsp;&emsp;不使用Mapper动态代理开发可以从代码中看到一些问题，每次我们调用SqlSession都要完成打开session、调用session完成与数据库的交互、关闭session，这三步，这些都是重复的代码。 2.2 使用Mapper动态代理开发首先想使用Mapper动态代理开发必须遵循四大原则加一个注意： 接口方法名需要与mapper.xml的要调用的sql语句的id一致 接口的形参类型需要与mapper.xml中的parameterType一致 接口的返回值需要与mapper.xml中的resultType一致 mapper.xml中的namespace要与接口的全包名一致注意：mapper动态代理开发中，根据返回值类型自动选择方法 UserMapper接口(mybatis提出mapper接口,相当于dao接口,mapper接口的命名方式建议为表名加Mapper) 1234public interface UserMapper &#123; //通过id查询一个用户 public User selectUserById(Integer id);&#125; UserMapper映射文件(mapper映射文件的命名方式建议表名加Mapper.xml,namespace指定为mapper接口的全限定名) 1234567&lt;!-- mapper.xml中的namespace要与接口的全包名一致 --&gt;&lt;mapper namespace=\"com.xiezhenyu.mapper.UserMapper\"&gt; &lt;!-- 查找用户 --&gt; &lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"user\"&gt; select * from user where u_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 将mapper.xml在SqlMapConfing.xml中进行注册 123&lt;mappers&gt; &lt;package name=\"com.xiezhenyu.mapper\"/&gt;&lt;/mappers&gt; 编写测试方法 123456789101112131415@Testpublic void Test1() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user);&#125; 结果： 1User [u_id=1, u_username=老王, u_password=123, u_sex=1, u_createTime=null, u_cid=1] 总结：使用Mapper代理进行开发&emsp;&emsp;优点：可以使我们只需要关注UserMapper.java接口中的方法，它的实现类由Mapper自动为我们生成，带来了很大的方便。&emsp;&emsp;缺点：如果UserMapper.java接口中的方法调用的statement中返回是多条记录，而mapper.java方法的返回值为JavaBean对象，此时代理对象通过selectOne调用，但由于返回的是多条记录所以会报错。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"傻瓜式使用MyBatis","date":"2019-10-13T09:59:27.728Z","path":"2019/10/13/傻瓜式使用MyBatis/","text":"MyBatis如何快速使用？ MyBatis框架图 1、下载MyBatis、创建项目、导包&emsp;&emsp;下载MyBatis：https://github.com/mybatis/mybatis-3/releases&emsp;&emsp;创建项目之后导入MyBatis的核心包和依赖包以及MySQL的连接包 2、创建测试用例，测试数据库、测试Bean对象&emsp;&emsp;创建测试数据库，直接运行以下SQL语句即可 123456789101112131415161718192021222324252627282930313233343536373839404142/*SQLyog Professional v12.08 (64 bit)MySQL - 5.5.49 : Database - ssm_mybatis**********************************************************************//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`ssm_mybatis` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `ssm_mybatis`;/*Table structure for table `country` */DROP TABLE IF EXISTS `country`;CREATE TABLE `country` ( `c_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '国家id', `c_countryname` varchar(128) NOT NULL COMMENT '国家名称', `c_capital` varchar(128) DEFAULT NULL COMMENT '国家首都名称', PRIMARY KEY (`c_id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;/*Data for the table `country` */insert into `country`(`c_id`,`c_countryname`,`c_capital`) values (1,'中国','北京'),(3,'美国','华盛顿'),(4,'英国','伦敦'),(5,'日本','东京');/*Table structure for table `user` */DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `u_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id', `u_username` varchar(64) NOT NULL COMMENT '用户名', `u_password` varchar(64) DEFAULT NULL COMMENT '用户密码', `u_sex` varchar(16) DEFAULT NULL COMMENT '用户性别', `u_createTime` datetime DEFAULT NULL COMMENT '用户创建时间', `u_cid` int(11) DEFAULT NULL COMMENT '用户国家id', PRIMARY KEY (`u_id`), KEY `FK_user_cid` (`u_cid`), CONSTRAINT `FK_user_cid` FOREIGN KEY (`u_cid`) REFERENCES `country` (`c_Id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;/*Data for the table `user` */insert into `user`(`u_id`,`u_username`,`u_password`,`u_sex`,`u_createTime`,`u_cid`) values (1,'老王','123','1',NULL,1),(2,'jack','123321','1',NULL,3),(3,'alice','ali111','0',NULL,3),(4,'王司机','666','1',NULL,1),(5,'anna','ali111','0',NULL,4),(6,'李师傅','222','1',NULL,1),(7,'漩涡鸣人','233','1',NULL,5),(8,'娜美','233','0',NULL,5),(9,'王五','abc','1',NULL,1),(10,'老赵',NULL,NULL,NULL,NULL),(11,'老孙',NULL,NULL,NULL,NULL),(12,'98k',NULL,NULL,NULL,NULL);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; &emsp;&emsp;创建测试Bean对象，与数据库创建的字段一致，并生成GET和SET方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class User &#123; private Integer u_id; private String u_username; private String u_password; private String u_sex; private Date u_createTime; private Integer u_cid; public Integer getU_id() &#123; return u_id; &#125; public void setU_id(Integer u_id) &#123; this.u_id = u_id; &#125; public String getU_username() &#123; return u_username; &#125; public void setU_username(String u_username) &#123; this.u_username = u_username; &#125; public String getU_password() &#123; return u_password; &#125; public void setU_password(String u_password) &#123; this.u_password = u_password; &#125; public String getU_sex() &#123; return u_sex; &#125; public void setU_sex(String u_sex) &#123; this.u_sex = u_sex; &#125; public Date getU_createTime() &#123; return u_createTime; &#125; public void setU_createTime(Date u_createTime) &#123; this.u_createTime = u_createTime; &#125; public Integer getU_cid() &#123; return u_cid; &#125; public void setU_cid(Integer u_cid) &#123; this.u_cid = u_cid; &#125; @Override public String toString() &#123; return \"User [u_id=\" + u_id + \", u_username=\" + u_username + \", u_password=\" + u_password + \", u_sex=\" + u_sex + \", u_createTime=\" + u_createTime + \", u_cid=\" + u_cid + \"]\"; &#125;&#125; 3、创建sqlMapConfig.xml主配置文件&emsp;&emsp;以下只是sqlMapConfig.xml主配置文件的一部分(会在快速使用MyBatis中使用到的一部分)，如果想要查看完整的配置文件请查看官方文档：https://mybatis.org/mybatis-3/zh/configuration.html 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 在集成spring时不用 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 使用jdbc的事务 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 使用连接池 链接数据库 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm_mybatis?serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf-8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"p123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4、创建Mapper.xml映射文件&emsp;&emsp;Mapper.xml映射文件中可以书写了查找用户、模糊查找用户、添加用户、修改用户、删除用户的sql语句，其中模糊查找中如果用字符串拼接的形式是不安全的，推荐使用占位符模糊查找。&emsp;&emsp;由于使用占位符查找，如果这样使用#{id}，如果传过来的id为1，他会在#{id}这个位置上显示’1’，加上了单引号，我们都知道模糊查找是 1select * from user where u_username like %你% &emsp;&emsp;如果我们使用占位符的话%’你’%这样是不行的，所以我们书写SQL语句的时候可以这样用 1select * from user where u_username like \"%\"'你'\"%\" &emsp;&emsp;以下是Mapper.xml映射文件 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"UserMapper\"&gt; &lt;!-- 查找用户 --&gt; &lt;select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"com.siliedu.bean.User\"&gt; select * from user where u_id = #&#123;id&#125; &lt;/select&gt; &lt;!-- #&#123;&#125;占位符 尽量选用占位符解决问题 --&gt; &lt;!-- $&#123;&#125;字符串拼接 --&gt; &lt;!-- 模糊查找用户 --&gt; &lt;select id=\"selectUserByName\" parameterType=\"String\" resultType=\"com.siliedu.bean.User\"&gt; &lt;!-- select * from user where u_username like '%$&#123;value&#125;%' --&gt; select * from user where u_username like \"%\"#&#123;name&#125;\"%\" &lt;/select&gt; &lt;!-- 添加用户 --&gt; &lt;insert id=\"insertUser\" parameterType=\"com.siliedu.bean.User\"&gt; insert into user values(null,#&#123;u_username&#125;,#&#123;u_password&#125;,#&#123;u_sex&#125;,#&#123;u_createTime&#125;,#&#123;u_cid&#125;) &lt;/insert&gt; &lt;!-- 修改用户 --&gt; &lt;update id=\"updateUser\" parameterType=\"com.siliedu.bean.User\"&gt; update user set u_username = #&#123;u_username&#125; where u_id=#&#123;u_id&#125; &lt;/update&gt; &lt;!-- 删除用户 --&gt; &lt;delete id=\"deleteUserById\" parameterType=\"Integer\"&gt; delete from user where u_id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 5、书写测试方法测试通过id查找用户1234567891011121314151617@Test//通过ID查询用户public void Test1() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 User user = session.selectOne(\"UserMapper.selectUserById\", 1); System.out.println(user);&#125; 测试通过名字模糊查询用户12345678910111213141516171819@Test//通过name模糊查询用户public void Test2() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 List&lt;User&gt; list = session.selectList(\"UserMapper.selectUserByName\", \"王\"); for(User u : list) &#123; System.out.println(u); &#125;&#125; 测试新增用户由于对数据库进行了更新，session必须commit才能使事务提交，数据库才会更新 1234567891011121314151617181920212223@Test//通过新增用户public void Test3() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 User user = new User(); user.setU_username(\"小明\"); user.setU_password(\"123456789\"); user.setU_sex(\"1\"); user.setU_createTime(new Date()); user.setU_cid(1); session.insert(\"UserMapper.insertUser\", user); session.commit();&#125; 测试修改用户1234567891011121314151617181920@Test//修改用户public void Test4() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 User user = new User(); user.setU_id(13); user.setU_username(\"小刚\"); session.update(\"UserMapper.updateUser\", user); session.commit();&#125; 测试删除用户1234567891011121314151617@Test//删除用户public void Test5() throws IOException &#123; String resource = \"sqlMapConfig.xml\"; //读取配置文件 InputStream in = Resources.getResourceAsStream(resource); //需要sqlSessionFactoryBulider SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); //创建sqlSessionFactory SqlSessionFactory ssf = ssfb.build(in); //生产一个sqlSession SqlSession session = ssf.openSession(); //操作数据库 //参数1:要操作的sql语句(对应UserMapper.xml里面的namespace.id) 参数2:sql语句的参数 session.delete(\"UserMapper.deleteUserById\", 13); session.commit();&#125; 以上就是MyBatis的简单使用。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Xiezhenyu98.github.io/tags/MyBatis/"}]},{"title":"聊聊struts.xml配置文件-Struts(二)","date":"2019-10-08T11:47:44.023Z","path":"2019/10/08/聊聊struts.xml配置文件-Struts(二)/","text":"&emsp;&emsp;上一篇写了一下struts怎么快速上手使用，下面是struts的配置文件struts.xml中一些配置的解释(●’◡’●)。 &emsp;&emsp;struts.xml是整个程序的工作流程的依据，该文件的根元素是&lt;struts&gt;，其中可以包含4个子元素，分别是：&lt;include&gt;、&lt;constant&gt;、&lt;bean&gt;、&lt;package&gt; &lt;include&gt;元素&emsp;&emsp;由于用struts开发一个大型的项目时，struts中的配置信息会越来越多，这样就会使配置文件的可读性和维护性变差，但使用了&lt;include&gt;就会解决这个问题，我们可以按照不同的功能或者模块将配置文件分割成多个配置文件。 1234&lt;struts&gt; &lt;include file=\"login.xml\"&gt;&lt;/include&gt; &lt;include file=\"register.xml\"&gt;&lt;/include&gt;&lt;/struts&gt; &lt;constant&gt;元素&emsp;&emsp;&lt;constant&gt;元素用于配置一些常量信息，这些常量用于控制struts2的某些特性，相当于当他运行时，给你准备哪些功能。由于&lt;constant&gt;元素的常量值过多，我只列一些常用的，以下例子是&lt;constant&gt;元素使用的常用设置 12345678910111213141516171819202122232425&lt;struts&gt; &lt;!-- 匹配所有以\".action\"为后缀的请求都由struts处理，其中action可变 如果需要匹配多个后缀都由struts处理，则使用英文\",\"号分隔，例如value=\"do,action\" 如果不写这一句，则会默认映射Action名字 --&gt; &lt;constant name=\"struts.action.extension\" value=\"action\" /&gt; &lt;!-- 是否启用开发者模式，在开发者模式下可打印出更加详细的报错信息 --&gt; &lt;constant name=\"struts.devMode\" value=\"true\" /&gt; &lt;!-- 当struts配置文件改动后，是否重新加载，默认不写是false --&gt; &lt;constant name=\"struts.configuration.xml.reload\" value=\"true\" /&gt; &lt;!-- 设置浏览器是否缓存静态内容，默认不写为true缓存，在开发环境下最好关闭，可以提高开发效率 --&gt; &lt;constant name=\"struts.serve.static.browserCache\" value=\"true\" /&gt; &lt;!-- 设置请求参数的编码方式，实际上相当于相当调用HttpServletRequest中的setCharacterEncoding方法 --&gt; &lt;constant name=\"struts.i18n.encoding\" value=\"utf-8\" /&gt; &lt;!-- 每次HTTP请求系统都重新加载资源文件 --&gt; &lt;constant name=\"struts.i18n.reload\" value=\"false\" /&gt; &lt;!-- 文件上传的最大值，单位为字节 --&gt; &lt;constant name=\"struts.multipart.maxSize\" value=\"1024\" /&gt; &lt;!-- 让Struts支持动态方法调用 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" /&gt; &lt;!-- 在URL中的Action段中是否支持斜线 --&gt; &lt;constant name=\"struts.enable.SlashesInActionNames\" value=\"false\" /&gt; &lt;!-- 标签中是否支持ognl表达式 --&gt; &lt;constant name=\"struts.tag.altSyntax\" value=\"true\" /&gt;&lt;/struts&gt; &lt;bean&gt;元素&emsp;&emsp;struts2是一个可扩展的框架，核心组件都是可以配置的，当我们需要扩展或替换struts2的核心组件时，只需要提供自己的组件实现类，并部署到struts2的容器中即可。&emsp;&emsp;例子：使用一个自定义的ObjectFactory替换struts2内置的ObjectFactory： 1&lt;bean name=\"myFactory\" type=\"com.opensymphony.xwork2.ObjectFactory\" class=\"xiezhenyu.ObjectFactory\" /&gt; &lt;package&gt;元素&emsp;&emsp;&lt;package&gt;元素提供了将多个Action组织为一个模块的方式，package的name在整个struts配置文件中必须是唯一的，并且一个package可以扩展自另一个package。此时改package会在本身配置的基础上加入扩展package的配置，但要注意父package必须在子package前配置。 123456789&lt;!-- package的属性name:package名称，作为其他包引用本包的标识，必填属性extends:继承的父package名称，可选属性。通常设置为struts-default，继承struts-default.xml，它里面定义了许多跳转类型、拦截器等一些常用的东西abstract:设置package的属性为抽象的，抽象的package不能定义Action，可选属性。namespace:可选属性。浏览器地址是根据namespace/action名称去访问的action其中namespace可以是虚路径--&gt;&lt;package name=\"MyStruts\" extends=\"struts-default\" namespace=\"/\"&gt;&lt;/package&gt; &lt;package&gt;子元素列表 子元素 功能 default-action-ref 配置默认的Action default-class-ref 配置默认class default-interceptor-ref 配置默认拦截器，对package范围内的所有Action有效 global-results 配置全局结果集，对package范围内的所有Action有效 global-exception-mapping 配置全局异常映射，对package范围内的所有Action有效 result-types 配置定义返回结果类型 interceptors 配置拦截器信息 action 配置Action信息 &lt;default-action-ref&gt;&emsp;&emsp;&lt;default-action-ref&gt;元素用于配置默认的Action，当一个Action请求在配置文件中找不到时，就会执行这个默认的Action，该元素只有一个name属性。 1&lt;default-action-ref name=\"Error\"&gt;&lt;/default-action-ref&gt; &lt;default-class-ref&gt;&emsp;&emsp;&lt;default-class-ref&gt;元素用户配置默认的类，在配置Action时，如果没有指定具体的class属性，系统就会使用&lt;default-class-ref&gt;元素中的配置。&lt;default-class-ref&gt;只有一个class属性。当使用&lt;default-class-ref&gt;元素指定了默认类后，Struts原来默认的类会被覆盖，而且默认的Action类必须包含execute()方法。 &lt;default-interceptor-ref&gt;&emsp;&emsp;&lt;default-interceptor-ref&gt;元素用于配置默认类拦截器，如果package继承了“struts-default”，那么也会继承父类package的默认拦截器。 &lt;global-result&gt;&emsp;&emsp;&lt;global-result&gt;元素用于配置package范围内的全局结果集。他的子元素是&lt;result&gt;。当一个package中多个Action都使用了一个或多个结果的时候，则将其配置在全局结果集中，增强代码的可读性和维护性。例如下面这个案列：当每个Action都返回了error的时候，全都使用这个全局结果去执行。 123&lt;global-result&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt;&lt;/global-result&gt; &lt;global-exception-mapping&gt;&emsp;&emsp;&lt;global-exception-mapping&gt;元素用于配置全局异常映射，如果&lt;action&gt;元素内配置了自己的异常映射，则Action内的优先级高于此配置。他的子元素是&lt;exception-mapping&gt;。 123&lt;global-exception-mapping&gt; &lt;exception-mapping result=\"error\" exception=\"异常类型\"&gt;&lt;/exception-mapping&gt;&lt;/global-exception-mapping&gt; &lt;result-type&gt;&emsp;&emsp;&lt;result-type&gt;元素用于配置自定义返回结果类型，该元素基本不用。 &lt;interceptors&gt;&emsp;&emsp;&lt;interceptors&gt;元素用于配置拦截器的拦截器栈，他有两个子元素：&lt;interceptor&gt;和&lt;interceptor-stack&gt;，分别用来定义拦截器和拦截器栈。 &lt;action&gt;&lt;action&gt;元素是比较重要的一个元素，也是我们开发中使用最多的一个元素。它有4个属性： name：必选属性，Action的名字。 class：可选属性，Action处理类的名字。 method：可选属性，指定Action中的方法。如果没有配置该属性，所有请求都会被转发到execute()方法去处理。如果有多个请求需要分别交给不同的方法去处理，就可以使用该属性来指明。 converter：可选属性，指定Action使用的类型转换器。 &emsp;&emsp;method属性除了可以填固定的函数名外，还可以使用通配符的方法实现动态方法调用，使用它的前提是必须要配置&lt;constant&gt;元素和&lt;global-allowed-methods&gt;，使其能实现动态方法调用和适配所有的方法。 123456789101112 &lt;struts&gt; &lt;!-- 让Struts支持动态方法调用 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" /&gt; &lt;package name=\"Struts\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 适配所有的通配符方法 --&gt; &lt;global-allowed-methods&gt;regex:.*&lt;/global-allowed-methods&gt; &lt;action name=\"*User\" class=\"xiezhenyu.UserAction\" method=\"&#123;1&#125;User\"&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt; &lt;result name=\"success\"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; &emsp;&emsp;如上代码所示，name属性值中的”*“就是通配符，表示所有以User结尾的亲求都会有这个Action处理；method属性值中的“{1}”是表达式，表示name属性中”*“的值，比如请求为loginUser，那么将传递给method属性，这是会调用Action中loginUser()方法。 &lt;action&gt;中还有以下几个子元素 &lt;interceptor-ref&gt;：用于配置拦截器 &lt;exception-mapping&gt;：用于配置异常映射 &lt;result&gt;：用于配置Action的结果映射，除了常规的结果映射外，也可以像method属性值一样使用表达式，实行动态结果。&lt;result&gt;有两个属性，name、type。name为Action类在处理完成返回的都是字符串类型的结果，这个结果作为逻辑视图存在，对应&lt;result&gt;元素的name属性值，然后找到与之对应的视图资源。type为指定结果的类型，其取值如下表所示。（我们只需要记住dispatcher、redirect和chain三个常用的即可，其它的略作了解） type可取值 解释 dispatcher 转发，默认结果类型，对应视图为JSP界面 chain 将Action和另一个Action链接起来 freemarker 返回结果的对应视图为FreeMarker模板 HttpHeaderResult 返回一个已配置好的HTTP头信息响应 redirect 将用户重定向到一个配置好的URL redirectAction 将用户重定向到一个已定义好的Action stream 将原数据作为流传递会浏览器，一般用于下载 velocity 返回结果的对应视图为Velocity模板 xslt 呈现XML到浏览器，该XML可以通过XSL模板进行转换 plaintext 返回普通文本内容 以上就是struts2配置文件的大部分内容。","tags":[{"name":"struts","slug":"struts","permalink":"https://Xiezhenyu98.github.io/tags/struts/"}]},{"title":"傻瓜式使用Struts-Struts(一)","date":"2019-10-07T06:53:12.957Z","path":"2019/10/07/傻瓜式使用Struts-Struts(一)/","text":"我现在大三了，很多同学都想转行JAVA(还好我大一就确定目标学java了(●’◡’●))，今天有人问我struts怎么用，为了同学的方便，我写了这篇傻瓜式使用struts框架的博客，希望能让同学们快速使用struts框架。(本篇本着可复现的态度写的，测试可用) 1、导入strurs需要用到的jar包经过本人整理出以下需要用到的一些包commons-fileupload-1.3.3.jarcommons-io-2.5.jarcommons-lang3-3.6.jarcommons-logging-1.1.3.jarfreemarker-2.3.26-incubating.jarjavassist-3.20.0-GA.jarlog4j-api-2.10.0.jarlog4j-core-2.11.0.jarognl-3.1.15.jarstruts2-core-2.5.16.jar你可以通过 点击这里下载 2、配置web.xml在web.xml中配置struts(添加filter) 12345678&lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3、创建Action创建一个Action并继承ActionSupport，从写里面的execute方法或者写一个带有String返回值并抛出一个异常的函数（异常可以抛出也可以不抛出） 123456public class SturtsAction extends ActionSupport&#123; public String test() throws Exception &#123; System.out.println(\"sss\"); return \"index\"; &#125;&#125; 4、配置struts.xmlstruts.xml必须创建在src根目录下 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- name:可以随便写 namespace:浏览器地址是根据namespace/action名称去访问的action其中namespace可以是虚路径 extends:struts-default 为继承struts的默认结果集，就是继承struts-default.xml，它里面定义了许多跳转类型、拦截器等一些常用的东西 --&gt; &lt;package name=\"Struts\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- name:浏览器访问的路径 class:这个类的路径 method:方法名 这三个连起来可以理解为：浏览器访问的路径是访问的哪个类中的哪个方法 --&gt; &lt;action name=\"StrutsAction\" class=\"com.xiezhenyu.web.SturtsAction\" method=\"test\"&gt; &lt;!-- name:与test方法中返回的字符串对应，后面的是跳转到哪一个页面 --&gt; &lt;result name=\"index\"&gt;/index.html&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 5、测试struts在eclipse跑起来之后输入地址，使用struts成功！！ 注意：其中struts.xml的配置文件只是其中一部分配置，目前并不能当成万金油使用，本篇只是介绍struts如何快速使用，就不一一介绍struts的详细配置文件，后续我会一一写出。","tags":[{"name":"struts","slug":"struts","permalink":"https://Xiezhenyu98.github.io/tags/struts/"}]}]